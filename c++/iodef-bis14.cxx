// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "iodef-bis14.hxx"

namespace iodef_2_0
{
  // incident_purpose_type
  // 

  incident_purpose_type::
  incident_purpose_type (value v)
  : ::xml_schema::nmtoken (_xsd_incident_purpose_type_literals_[v])
  {
  }

  incident_purpose_type::
  incident_purpose_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  incident_purpose_type::
  incident_purpose_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  incident_purpose_type::
  incident_purpose_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  incident_purpose_type::
  incident_purpose_type (const incident_purpose_type& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  incident_purpose_type& incident_purpose_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_incident_purpose_type_literals_[v]);

    return *this;
  }


  // incident_status_type
  // 

  incident_status_type::
  incident_status_type (value v)
  : ::xml_schema::nmtoken (_xsd_incident_status_type_literals_[v])
  {
  }

  incident_status_type::
  incident_status_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  incident_status_type::
  incident_status_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  incident_status_type::
  incident_status_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  incident_status_type::
  incident_status_type (const incident_status_type& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  incident_status_type& incident_status_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_incident_status_type_literals_[v]);

    return *this;
  }


  // IncidentIDType
  // 

  const IncidentIDType::name_type& IncidentIDType::
  name () const
  {
    return this->name_.get ();
  }

  IncidentIDType::name_type& IncidentIDType::
  name ()
  {
    return this->name_.get ();
  }

  void IncidentIDType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void IncidentIDType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const IncidentIDType::instance_optional& IncidentIDType::
  instance () const
  {
    return this->instance_;
  }

  IncidentIDType::instance_optional& IncidentIDType::
  instance ()
  {
    return this->instance_;
  }

  void IncidentIDType::
  instance (const instance_type& x)
  {
    this->instance_.set (x);
  }

  void IncidentIDType::
  instance (const instance_optional& x)
  {
    this->instance_ = x;
  }

  void IncidentIDType::
  instance (::std::auto_ptr< instance_type > x)
  {
    this->instance_.set (x);
  }

  const IncidentIDType::restriction_type& IncidentIDType::
  restriction () const
  {
    return this->restriction_.get ();
  }

  IncidentIDType::restriction_type& IncidentIDType::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void IncidentIDType::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void IncidentIDType::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const IncidentIDType::restriction_type& IncidentIDType::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }

  const IncidentIDType::ext_restriction_optional& IncidentIDType::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  IncidentIDType::ext_restriction_optional& IncidentIDType::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void IncidentIDType::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void IncidentIDType::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void IncidentIDType::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // contact_role_type
  // 

  contact_role_type::
  contact_role_type (value v)
  : ::xml_schema::nmtoken (_xsd_contact_role_type_literals_[v])
  {
  }

  contact_role_type::
  contact_role_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  contact_role_type::
  contact_role_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  contact_role_type::
  contact_role_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  contact_role_type::
  contact_role_type (const contact_role_type& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  contact_role_type& contact_role_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_contact_role_type_literals_[v]);

    return *this;
  }


  // contact_type_type
  // 

  contact_type_type::
  contact_type_type (value v)
  : ::xml_schema::nmtoken (_xsd_contact_type_type_literals_[v])
  {
  }

  contact_type_type::
  contact_type_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  contact_type_type::
  contact_type_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  contact_type_type::
  contact_type_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  contact_type_type::
  contact_type_type (const contact_type_type& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  contact_type_type& contact_type_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_contact_type_type_literals_[v]);

    return *this;
  }


  // registryhandle_registry_type
  // 

  registryhandle_registry_type::
  registryhandle_registry_type (value v)
  : ::xml_schema::nmtoken (_xsd_registryhandle_registry_type_literals_[v])
  {
  }

  registryhandle_registry_type::
  registryhandle_registry_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  registryhandle_registry_type::
  registryhandle_registry_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  registryhandle_registry_type::
  registryhandle_registry_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  registryhandle_registry_type::
  registryhandle_registry_type (const registryhandle_registry_type& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  registryhandle_registry_type& registryhandle_registry_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_registryhandle_registry_type_literals_[v]);

    return *this;
  }


  // ContactMeansType
  // 

  const ContactMeansType::meaning_optional& ContactMeansType::
  meaning () const
  {
    return this->meaning_;
  }

  ContactMeansType::meaning_optional& ContactMeansType::
  meaning ()
  {
    return this->meaning_;
  }

  void ContactMeansType::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void ContactMeansType::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void ContactMeansType::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }


  // TimezoneType
  // 


  // discovery_source_type
  // 

  discovery_source_type::
  discovery_source_type (value v)
  : ::xml_schema::nmtoken (_xsd_discovery_source_type_literals_[v])
  {
  }

  discovery_source_type::
  discovery_source_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  discovery_source_type::
  discovery_source_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  discovery_source_type::
  discovery_source_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  discovery_source_type::
  discovery_source_type (const discovery_source_type& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  discovery_source_type& discovery_source_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_discovery_source_type_literals_[v]);

    return *this;
  }


  // systemimpact_type_type
  // 

  systemimpact_type_type::
  systemimpact_type_type (value v)
  : ::xml_schema::nmtoken (_xsd_systemimpact_type_type_literals_[v])
  {
  }

  systemimpact_type_type::
  systemimpact_type_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  systemimpact_type_type::
  systemimpact_type_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  systemimpact_type_type::
  systemimpact_type_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  systemimpact_type_type::
  systemimpact_type_type (const systemimpact_type_type& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  systemimpact_type_type& systemimpact_type_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_systemimpact_type_type_literals_[v]);

    return *this;
  }


  // MLStringType
  // 

  const MLStringType::translation_id_optional& MLStringType::
  translation_id () const
  {
    return this->translation_id_;
  }

  MLStringType::translation_id_optional& MLStringType::
  translation_id ()
  {
    return this->translation_id_;
  }

  void MLStringType::
  translation_id (const translation_id_type& x)
  {
    this->translation_id_.set (x);
  }

  void MLStringType::
  translation_id (const translation_id_optional& x)
  {
    this->translation_id_ = x;
  }

  void MLStringType::
  translation_id (::std::auto_ptr< translation_id_type > x)
  {
    this->translation_id_.set (x);
  }

  const MLStringType::lang_optional& MLStringType::
  lang () const
  {
    return this->lang_;
  }

  MLStringType::lang_optional& MLStringType::
  lang ()
  {
    return this->lang_;
  }

  void MLStringType::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void MLStringType::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void MLStringType::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // BusinessImpactType
  // 

  const BusinessImpactType::severity_optional& BusinessImpactType::
  severity () const
  {
    return this->severity_;
  }

  BusinessImpactType::severity_optional& BusinessImpactType::
  severity ()
  {
    return this->severity_;
  }

  void BusinessImpactType::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void BusinessImpactType::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void BusinessImpactType::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const BusinessImpactType::ext_severity_optional& BusinessImpactType::
  ext_severity () const
  {
    return this->ext_severity_;
  }

  BusinessImpactType::ext_severity_optional& BusinessImpactType::
  ext_severity ()
  {
    return this->ext_severity_;
  }

  void BusinessImpactType::
  ext_severity (const ext_severity_type& x)
  {
    this->ext_severity_.set (x);
  }

  void BusinessImpactType::
  ext_severity (const ext_severity_optional& x)
  {
    this->ext_severity_ = x;
  }

  void BusinessImpactType::
  ext_severity (::std::auto_ptr< ext_severity_type > x)
  {
    this->ext_severity_.set (x);
  }

  const BusinessImpactType::type_optional& BusinessImpactType::
  type () const
  {
    return this->type_;
  }

  BusinessImpactType::type_optional& BusinessImpactType::
  type ()
  {
    return this->type_;
  }

  void BusinessImpactType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void BusinessImpactType::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void BusinessImpactType::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const BusinessImpactType::ext_type_optional& BusinessImpactType::
  ext_type () const
  {
    return this->ext_type_;
  }

  BusinessImpactType::ext_type_optional& BusinessImpactType::
  ext_type ()
  {
    return this->ext_type_;
  }

  void BusinessImpactType::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void BusinessImpactType::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void BusinessImpactType::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }


  // businessimpact_severity_type
  // 

  businessimpact_severity_type::
  businessimpact_severity_type (value v)
  : ::xml_schema::nmtoken (_xsd_businessimpact_severity_type_literals_[v])
  {
  }

  businessimpact_severity_type::
  businessimpact_severity_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  businessimpact_severity_type::
  businessimpact_severity_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  businessimpact_severity_type::
  businessimpact_severity_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  businessimpact_severity_type::
  businessimpact_severity_type (const businessimpact_severity_type& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  businessimpact_severity_type& businessimpact_severity_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_businessimpact_severity_type_literals_[v]);

    return *this;
  }


  // businessimpact_type_type
  // 

  businessimpact_type_type::
  businessimpact_type_type (value v)
  : ::xml_schema::nmtoken (_xsd_businessimpact_type_type_literals_[v])
  {
  }

  businessimpact_type_type::
  businessimpact_type_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  businessimpact_type_type::
  businessimpact_type_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  businessimpact_type_type::
  businessimpact_type_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  businessimpact_type_type::
  businessimpact_type_type (const businessimpact_type_type& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  businessimpact_type_type& businessimpact_type_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_businessimpact_type_type_literals_[v]);

    return *this;
  }


  // timeimpact_metric_type
  // 

  timeimpact_metric_type::
  timeimpact_metric_type (value v)
  : ::xml_schema::nmtoken (_xsd_timeimpact_metric_type_literals_[v])
  {
  }

  timeimpact_metric_type::
  timeimpact_metric_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  timeimpact_metric_type::
  timeimpact_metric_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  timeimpact_metric_type::
  timeimpact_metric_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  timeimpact_metric_type::
  timeimpact_metric_type (const timeimpact_metric_type& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  timeimpact_metric_type& timeimpact_metric_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_timeimpact_metric_type_literals_[v]);

    return *this;
  }


  // confidence_rating_type
  // 

  confidence_rating_type::
  confidence_rating_type (value v)
  : ::xml_schema::nmtoken (_xsd_confidence_rating_type_literals_[v])
  {
  }

  confidence_rating_type::
  confidence_rating_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  confidence_rating_type::
  confidence_rating_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  confidence_rating_type::
  confidence_rating_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  confidence_rating_type::
  confidence_rating_type (const confidence_rating_type& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  confidence_rating_type& confidence_rating_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_confidence_rating_type_literals_[v]);

    return *this;
  }


  // system_category_type
  // 

  system_category_type::
  system_category_type (value v)
  : ::xml_schema::nmtoken (_xsd_system_category_type_literals_[v])
  {
  }

  system_category_type::
  system_category_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system_category_type::
  system_category_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system_category_type::
  system_category_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system_category_type::
  system_category_type (const system_category_type& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  system_category_type& system_category_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_system_category_type_literals_[v]);

    return *this;
  }


  // system_ownership_type
  // 

  system_ownership_type::
  system_ownership_type (value v)
  : ::xml_schema::nmtoken (_xsd_system_ownership_type_literals_[v])
  {
  }

  system_ownership_type::
  system_ownership_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system_ownership_type::
  system_ownership_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system_ownership_type::
  system_ownership_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  system_ownership_type::
  system_ownership_type (const system_ownership_type& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  system_ownership_type& system_ownership_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_system_ownership_type_literals_[v]);

    return *this;
  }


  // address_category_type
  // 

  address_category_type::
  address_category_type (value v)
  : ::xml_schema::nmtoken (_xsd_address_category_type_literals_[v])
  {
  }

  address_category_type::
  address_category_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  address_category_type::
  address_category_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  address_category_type::
  address_category_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  address_category_type::
  address_category_type (const address_category_type& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  address_category_type& address_category_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_address_category_type_literals_[v]);

    return *this;
  }


  // noderole_category_type
  // 

  noderole_category_type::
  noderole_category_type (value v)
  : ::xml_schema::nmtoken (_xsd_noderole_category_type_literals_[v])
  {
  }

  noderole_category_type::
  noderole_category_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  noderole_category_type::
  noderole_category_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  noderole_category_type::
  noderole_category_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  noderole_category_type::
  noderole_category_type (const noderole_category_type& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  noderole_category_type& noderole_category_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_noderole_category_type_literals_[v]);

    return *this;
  }


  // counter_type_type
  // 

  counter_type_type::
  counter_type_type (value v)
  : ::xml_schema::nmtoken (_xsd_counter_type_type_literals_[v])
  {
  }

  counter_type_type::
  counter_type_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  counter_type_type::
  counter_type_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  counter_type_type::
  counter_type_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  counter_type_type::
  counter_type_type (const counter_type_type& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  counter_type_type& counter_type_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_counter_type_type_literals_[v]);

    return *this;
  }


  // counter_unit_type
  // 

  counter_unit_type::
  counter_unit_type (value v)
  : ::xml_schema::nmtoken (_xsd_counter_unit_type_literals_[v])
  {
  }

  counter_unit_type::
  counter_unit_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  counter_unit_type::
  counter_unit_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  counter_unit_type::
  counter_unit_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  counter_unit_type::
  counter_unit_type (const counter_unit_type& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  counter_unit_type& counter_unit_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_counter_unit_type_literals_[v]);

    return *this;
  }


  // domaindata_system_status_type
  // 

  domaindata_system_status_type::
  domaindata_system_status_type (value v)
  : ::xml_schema::string (_xsd_domaindata_system_status_type_literals_[v])
  {
  }

  domaindata_system_status_type::
  domaindata_system_status_type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  domaindata_system_status_type::
  domaindata_system_status_type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  domaindata_system_status_type::
  domaindata_system_status_type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  domaindata_system_status_type::
  domaindata_system_status_type (const domaindata_system_status_type& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  domaindata_system_status_type& domaindata_system_status_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_domaindata_system_status_type_literals_[v]);

    return *this;
  }


  // domaindata_domain_status_type
  // 

  domaindata_domain_status_type::
  domaindata_domain_status_type (value v)
  : ::xml_schema::string (_xsd_domaindata_domain_status_type_literals_[v])
  {
  }

  domaindata_domain_status_type::
  domaindata_domain_status_type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  domaindata_domain_status_type::
  domaindata_domain_status_type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  domaindata_domain_status_type::
  domaindata_domain_status_type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  domaindata_domain_status_type::
  domaindata_domain_status_type (const domaindata_domain_status_type& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  domaindata_domain_status_type& domaindata_domain_status_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_domaindata_domain_status_type_literals_[v]);

    return *this;
  }


  // recordpattern_type_type
  // 

  recordpattern_type_type::
  recordpattern_type_type (value v)
  : ::xml_schema::nmtoken (_xsd_recordpattern_type_type_literals_[v])
  {
  }

  recordpattern_type_type::
  recordpattern_type_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  recordpattern_type_type::
  recordpattern_type_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  recordpattern_type_type::
  recordpattern_type_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  recordpattern_type_type::
  recordpattern_type_type (const recordpattern_type_type& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  recordpattern_type_type& recordpattern_type_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_recordpattern_type_type_literals_[v]);

    return *this;
  }


  // recordpattern_offsetunit_type
  // 

  recordpattern_offsetunit_type::
  recordpattern_offsetunit_type (value v)
  : ::xml_schema::nmtoken (_xsd_recordpattern_offsetunit_type_literals_[v])
  {
  }

  recordpattern_offsetunit_type::
  recordpattern_offsetunit_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  recordpattern_offsetunit_type::
  recordpattern_offsetunit_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  recordpattern_offsetunit_type::
  recordpattern_offsetunit_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  recordpattern_offsetunit_type::
  recordpattern_offsetunit_type (const recordpattern_offsetunit_type& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  recordpattern_offsetunit_type& recordpattern_offsetunit_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_recordpattern_offsetunit_type_literals_[v]);

    return *this;
  }


  // key_registryaction_type
  // 

  key_registryaction_type::
  key_registryaction_type (value v)
  : ::xml_schema::nmtoken (_xsd_key_registryaction_type_literals_[v])
  {
  }

  key_registryaction_type::
  key_registryaction_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  key_registryaction_type::
  key_registryaction_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  key_registryaction_type::
  key_registryaction_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  key_registryaction_type::
  key_registryaction_type (const key_registryaction_type& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  key_registryaction_type& key_registryaction_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_key_registryaction_type_literals_[v]);

    return *this;
  }


  // hashdata_scope_type
  // 

  hashdata_scope_type::
  hashdata_scope_type (value v)
  : ::xml_schema::nmtoken (_xsd_hashdata_scope_type_literals_[v])
  {
  }

  hashdata_scope_type::
  hashdata_scope_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  hashdata_scope_type::
  hashdata_scope_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  hashdata_scope_type::
  hashdata_scope_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  hashdata_scope_type::
  hashdata_scope_type (const hashdata_scope_type& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  hashdata_scope_type& hashdata_scope_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_hashdata_scope_type_literals_[v]);

    return *this;
  }


  // SoftwareType
  // 

  const SoftwareType::SoftwareReference_optional& SoftwareType::
  SoftwareReference () const
  {
    return this->SoftwareReference_;
  }

  SoftwareType::SoftwareReference_optional& SoftwareType::
  SoftwareReference ()
  {
    return this->SoftwareReference_;
  }

  void SoftwareType::
  SoftwareReference (const SoftwareReference_type& x)
  {
    this->SoftwareReference_.set (x);
  }

  void SoftwareType::
  SoftwareReference (const SoftwareReference_optional& x)
  {
    this->SoftwareReference_ = x;
  }

  void SoftwareType::
  SoftwareReference (::std::auto_ptr< SoftwareReference_type > x)
  {
    this->SoftwareReference_.set (x);
  }

  const SoftwareType::URL_sequence& SoftwareType::
  URL () const
  {
    return this->URL_;
  }

  SoftwareType::URL_sequence& SoftwareType::
  URL ()
  {
    return this->URL_;
  }

  void SoftwareType::
  URL (const URL_sequence& s)
  {
    this->URL_ = s;
  }

  const SoftwareType::Description_sequence& SoftwareType::
  Description () const
  {
    return this->Description_;
  }

  SoftwareType::Description_sequence& SoftwareType::
  Description ()
  {
    return this->Description_;
  }

  void SoftwareType::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }


  // softwarereference_spec_name_type
  // 

  softwarereference_spec_name_type::
  softwarereference_spec_name_type (value v)
  : ::xml_schema::nmtoken (_xsd_softwarereference_spec_name_type_literals_[v])
  {
  }

  softwarereference_spec_name_type::
  softwarereference_spec_name_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  softwarereference_spec_name_type::
  softwarereference_spec_name_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  softwarereference_spec_name_type::
  softwarereference_spec_name_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  softwarereference_spec_name_type::
  softwarereference_spec_name_type (const softwarereference_spec_name_type& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  softwarereference_spec_name_type& softwarereference_spec_name_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_softwarereference_spec_name_type_literals_[v]);

    return *this;
  }


  // softwarereference_dtype_type
  // 

  softwarereference_dtype_type::
  softwarereference_dtype_type (value v)
  : ::xml_schema::nmtoken (_xsd_softwarereference_dtype_type_literals_[v])
  {
  }

  softwarereference_dtype_type::
  softwarereference_dtype_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  softwarereference_dtype_type::
  softwarereference_dtype_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  softwarereference_dtype_type::
  softwarereference_dtype_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  softwarereference_dtype_type::
  softwarereference_dtype_type (const softwarereference_dtype_type& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  softwarereference_dtype_type& softwarereference_dtype_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_softwarereference_dtype_type_literals_[v]);

    return *this;
  }


  // observable_type_type
  // 

  observable_type_type::
  observable_type_type (value v)
  : ::xml_schema::nmtoken (_xsd_observable_type_type_literals_[v])
  {
  }

  observable_type_type::
  observable_type_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  observable_type_type::
  observable_type_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  observable_type_type::
  observable_type_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  observable_type_type::
  observable_type_type (const observable_type_type& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  observable_type_type& observable_type_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_observable_type_type_literals_[v]);

    return *this;
  }


  // indicatorexpression_operator_type
  // 

  indicatorexpression_operator_type::
  indicatorexpression_operator_type (value v)
  : ::xml_schema::nmtoken (_xsd_indicatorexpression_operator_type_literals_[v])
  {
  }

  indicatorexpression_operator_type::
  indicatorexpression_operator_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  indicatorexpression_operator_type::
  indicatorexpression_operator_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  indicatorexpression_operator_type::
  indicatorexpression_operator_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  indicatorexpression_operator_type::
  indicatorexpression_operator_type (const indicatorexpression_operator_type& v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  indicatorexpression_operator_type& indicatorexpression_operator_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_indicatorexpression_operator_type_literals_[v]);

    return *this;
  }


  // PositiveFloatType
  // 


  // PortlistType
  // 


  // ExtensionType
  // 

  const ExtensionType::dtype_type& ExtensionType::
  dtype () const
  {
    return this->dtype_.get ();
  }

  ExtensionType::dtype_type& ExtensionType::
  dtype ()
  {
    return this->dtype_.get ();
  }

  void ExtensionType::
  dtype (const dtype_type& x)
  {
    this->dtype_.set (x);
  }

  void ExtensionType::
  dtype (::std::auto_ptr< dtype_type > x)
  {
    this->dtype_.set (x);
  }

  const ExtensionType::meaning_optional& ExtensionType::
  meaning () const
  {
    return this->meaning_;
  }

  ExtensionType::meaning_optional& ExtensionType::
  meaning ()
  {
    return this->meaning_;
  }

  void ExtensionType::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void ExtensionType::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void ExtensionType::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }

  const ExtensionType::formatid_optional& ExtensionType::
  formatid () const
  {
    return this->formatid_;
  }

  ExtensionType::formatid_optional& ExtensionType::
  formatid ()
  {
    return this->formatid_;
  }

  void ExtensionType::
  formatid (const formatid_type& x)
  {
    this->formatid_.set (x);
  }

  void ExtensionType::
  formatid (const formatid_optional& x)
  {
    this->formatid_ = x;
  }

  void ExtensionType::
  formatid (::std::auto_ptr< formatid_type > x)
  {
    this->formatid_.set (x);
  }

  const ExtensionType::restriction_optional& ExtensionType::
  restriction () const
  {
    return this->restriction_;
  }

  ExtensionType::restriction_optional& ExtensionType::
  restriction ()
  {
    return this->restriction_;
  }

  void ExtensionType::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void ExtensionType::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void ExtensionType::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const ExtensionType::ext_restriction_optional& ExtensionType::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  ExtensionType::ext_restriction_optional& ExtensionType::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void ExtensionType::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void ExtensionType::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void ExtensionType::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // ApplicationHeaderType
  // 

  const ApplicationHeaderType::proto_optional& ApplicationHeaderType::
  proto () const
  {
    return this->proto_;
  }

  ApplicationHeaderType::proto_optional& ApplicationHeaderType::
  proto ()
  {
    return this->proto_;
  }

  void ApplicationHeaderType::
  proto (const proto_type& x)
  {
    this->proto_.set (x);
  }

  void ApplicationHeaderType::
  proto (const proto_optional& x)
  {
    this->proto_ = x;
  }

  const ApplicationHeaderType::proto_name_optional& ApplicationHeaderType::
  proto_name () const
  {
    return this->proto_name_;
  }

  ApplicationHeaderType::proto_name_optional& ApplicationHeaderType::
  proto_name ()
  {
    return this->proto_name_;
  }

  void ApplicationHeaderType::
  proto_name (const proto_name_type& x)
  {
    this->proto_name_.set (x);
  }

  void ApplicationHeaderType::
  proto_name (const proto_name_optional& x)
  {
    this->proto_name_ = x;
  }

  const ApplicationHeaderType::field_type& ApplicationHeaderType::
  field () const
  {
    return this->field_.get ();
  }

  ApplicationHeaderType::field_type& ApplicationHeaderType::
  field ()
  {
    return this->field_.get ();
  }

  void ApplicationHeaderType::
  field (const field_type& x)
  {
    this->field_.set (x);
  }

  void ApplicationHeaderType::
  field (::std::auto_ptr< field_type > x)
  {
    this->field_.set (x);
  }

  const ApplicationHeaderType::dtype_type& ApplicationHeaderType::
  dtype () const
  {
    return this->dtype_.get ();
  }

  ApplicationHeaderType::dtype_type& ApplicationHeaderType::
  dtype ()
  {
    return this->dtype_.get ();
  }

  void ApplicationHeaderType::
  dtype (const dtype_type& x)
  {
    this->dtype_.set (x);
  }

  void ApplicationHeaderType::
  dtype (::std::auto_ptr< dtype_type > x)
  {
    this->dtype_.set (x);
  }

  const ApplicationHeaderType::observable_id_optional& ApplicationHeaderType::
  observable_id () const
  {
    return this->observable_id_;
  }

  ApplicationHeaderType::observable_id_optional& ApplicationHeaderType::
  observable_id ()
  {
    return this->observable_id_;
  }

  void ApplicationHeaderType::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void ApplicationHeaderType::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void ApplicationHeaderType::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // yes_no_type
  // 

  yes_no_type::
  yes_no_type (value v)
  : ::xml_schema::nmtoken (_xsd_yes_no_type_literals_[v])
  {
  }

  yes_no_type::
  yes_no_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yes_no_type::
  yes_no_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yes_no_type::
  yes_no_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yes_no_type::
  yes_no_type (const yes_no_type& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  yes_no_type& yes_no_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_yes_no_type_literals_[v]);

    return *this;
  }


  // yes_no_unknown_type
  // 

  yes_no_unknown_type::
  yes_no_unknown_type (value v)
  : ::xml_schema::nmtoken (_xsd_yes_no_unknown_type_literals_[v])
  {
  }

  yes_no_unknown_type::
  yes_no_unknown_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yes_no_unknown_type::
  yes_no_unknown_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yes_no_unknown_type::
  yes_no_unknown_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  yes_no_unknown_type::
  yes_no_unknown_type (const yes_no_unknown_type& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  yes_no_unknown_type& yes_no_unknown_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_yes_no_unknown_type_literals_[v]);

    return *this;
  }


  // restriction_type
  // 

  restriction_type::
  restriction_type (value v)
  : ::xml_schema::nmtoken (_xsd_restriction_type_literals_[v])
  {
  }

  restriction_type::
  restriction_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  restriction_type::
  restriction_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  restriction_type::
  restriction_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  restriction_type::
  restriction_type (const restriction_type& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  restriction_type& restriction_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_restriction_type_literals_[v]);

    return *this;
  }


  // severity_type
  // 

  severity_type::
  severity_type (value v)
  : ::xml_schema::nmtoken (_xsd_severity_type_literals_[v])
  {
  }

  severity_type::
  severity_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  severity_type::
  severity_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  severity_type::
  severity_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  severity_type::
  severity_type (const severity_type& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  severity_type& severity_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_severity_type_literals_[v]);

    return *this;
  }


  // duration_type
  // 

  duration_type::
  duration_type (value v)
  : ::xml_schema::nmtoken (_xsd_duration_type_literals_[v])
  {
  }

  duration_type::
  duration_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  duration_type::
  duration_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  duration_type::
  duration_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  duration_type::
  duration_type (const duration_type& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  duration_type& duration_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_duration_type_literals_[v]);

    return *this;
  }


  // action_type
  // 

  action_type::
  action_type (value v)
  : ::xml_schema::nmtoken (_xsd_action_type_literals_[v])
  {
  }

  action_type::
  action_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  action_type::
  action_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  action_type::
  action_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  action_type::
  action_type (const action_type& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  action_type& action_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_action_type_literals_[v]);

    return *this;
  }


  // dtype_type
  // 

  dtype_type::
  dtype_type (value v)
  : ::xml_schema::nmtoken (_xsd_dtype_type_literals_[v])
  {
  }

  dtype_type::
  dtype_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dtype_type::
  dtype_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dtype_type::
  dtype_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dtype_type::
  dtype_type (const dtype_type& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  dtype_type& dtype_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_dtype_type_literals_[v]);

    return *this;
  }


  // proto_dtype_type
  // 

  proto_dtype_type::
  proto_dtype_type (value v)
  : ::xml_schema::nmtoken (_xsd_proto_dtype_type_literals_[v])
  {
  }

  proto_dtype_type::
  proto_dtype_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  proto_dtype_type::
  proto_dtype_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  proto_dtype_type::
  proto_dtype_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  proto_dtype_type::
  proto_dtype_type (const proto_dtype_type& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  proto_dtype_type& proto_dtype_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_proto_dtype_type_literals_[v]);

    return *this;
  }


  // IODEF_Document
  // 

  const IODEF_Document::Incident_sequence& IODEF_Document::
  Incident () const
  {
    return this->Incident_;
  }

  IODEF_Document::Incident_sequence& IODEF_Document::
  Incident ()
  {
    return this->Incident_;
  }

  void IODEF_Document::
  Incident (const Incident_sequence& s)
  {
    this->Incident_ = s;
  }

  const IODEF_Document::AdditionalData_sequence& IODEF_Document::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  IODEF_Document::AdditionalData_sequence& IODEF_Document::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void IODEF_Document::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const IODEF_Document::version_type& IODEF_Document::
  version () const
  {
    return this->version_.get ();
  }

  const IODEF_Document::version_type& IODEF_Document::
  version_default_value ()
  {
    return version_default_value_;
  }

  const IODEF_Document::lang_optional& IODEF_Document::
  lang () const
  {
    return this->lang_;
  }

  IODEF_Document::lang_optional& IODEF_Document::
  lang ()
  {
    return this->lang_;
  }

  void IODEF_Document::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void IODEF_Document::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void IODEF_Document::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const IODEF_Document::format_id_optional& IODEF_Document::
  format_id () const
  {
    return this->format_id_;
  }

  IODEF_Document::format_id_optional& IODEF_Document::
  format_id ()
  {
    return this->format_id_;
  }

  void IODEF_Document::
  format_id (const format_id_type& x)
  {
    this->format_id_.set (x);
  }

  void IODEF_Document::
  format_id (const format_id_optional& x)
  {
    this->format_id_ = x;
  }

  void IODEF_Document::
  format_id (::std::auto_ptr< format_id_type > x)
  {
    this->format_id_.set (x);
  }

  const IODEF_Document::private_enum_name_optional& IODEF_Document::
  private_enum_name () const
  {
    return this->private_enum_name_;
  }

  IODEF_Document::private_enum_name_optional& IODEF_Document::
  private_enum_name ()
  {
    return this->private_enum_name_;
  }

  void IODEF_Document::
  private_enum_name (const private_enum_name_type& x)
  {
    this->private_enum_name_.set (x);
  }

  void IODEF_Document::
  private_enum_name (const private_enum_name_optional& x)
  {
    this->private_enum_name_ = x;
  }

  void IODEF_Document::
  private_enum_name (::std::auto_ptr< private_enum_name_type > x)
  {
    this->private_enum_name_.set (x);
  }

  const IODEF_Document::private_enum_id_optional& IODEF_Document::
  private_enum_id () const
  {
    return this->private_enum_id_;
  }

  IODEF_Document::private_enum_id_optional& IODEF_Document::
  private_enum_id ()
  {
    return this->private_enum_id_;
  }

  void IODEF_Document::
  private_enum_id (const private_enum_id_type& x)
  {
    this->private_enum_id_.set (x);
  }

  void IODEF_Document::
  private_enum_id (const private_enum_id_optional& x)
  {
    this->private_enum_id_ = x;
  }

  void IODEF_Document::
  private_enum_id (::std::auto_ptr< private_enum_id_type > x)
  {
    this->private_enum_id_.set (x);
  }


  // Incident
  // 

  const Incident::IncidentID_type& Incident::
  IncidentID () const
  {
    return this->IncidentID_.get ();
  }

  Incident::IncidentID_type& Incident::
  IncidentID ()
  {
    return this->IncidentID_.get ();
  }

  void Incident::
  IncidentID (const IncidentID_type& x)
  {
    this->IncidentID_.set (x);
  }

  void Incident::
  IncidentID (::std::auto_ptr< IncidentID_type > x)
  {
    this->IncidentID_.set (x);
  }

  const Incident::AlternativeID_optional& Incident::
  AlternativeID () const
  {
    return this->AlternativeID_;
  }

  Incident::AlternativeID_optional& Incident::
  AlternativeID ()
  {
    return this->AlternativeID_;
  }

  void Incident::
  AlternativeID (const AlternativeID_type& x)
  {
    this->AlternativeID_.set (x);
  }

  void Incident::
  AlternativeID (const AlternativeID_optional& x)
  {
    this->AlternativeID_ = x;
  }

  void Incident::
  AlternativeID (::std::auto_ptr< AlternativeID_type > x)
  {
    this->AlternativeID_.set (x);
  }

  const Incident::RelatedActivity_sequence& Incident::
  RelatedActivity () const
  {
    return this->RelatedActivity_;
  }

  Incident::RelatedActivity_sequence& Incident::
  RelatedActivity ()
  {
    return this->RelatedActivity_;
  }

  void Incident::
  RelatedActivity (const RelatedActivity_sequence& s)
  {
    this->RelatedActivity_ = s;
  }

  const Incident::DetectTime_optional& Incident::
  DetectTime () const
  {
    return this->DetectTime_;
  }

  Incident::DetectTime_optional& Incident::
  DetectTime ()
  {
    return this->DetectTime_;
  }

  void Incident::
  DetectTime (const DetectTime_type& x)
  {
    this->DetectTime_.set (x);
  }

  void Incident::
  DetectTime (const DetectTime_optional& x)
  {
    this->DetectTime_ = x;
  }

  void Incident::
  DetectTime (::std::auto_ptr< DetectTime_type > x)
  {
    this->DetectTime_.set (x);
  }

  const Incident::StartTime_optional& Incident::
  StartTime () const
  {
    return this->StartTime_;
  }

  Incident::StartTime_optional& Incident::
  StartTime ()
  {
    return this->StartTime_;
  }

  void Incident::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void Incident::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void Incident::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const Incident::EndTime_optional& Incident::
  EndTime () const
  {
    return this->EndTime_;
  }

  Incident::EndTime_optional& Incident::
  EndTime ()
  {
    return this->EndTime_;
  }

  void Incident::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void Incident::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void Incident::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const Incident::RecoveryTime_optional& Incident::
  RecoveryTime () const
  {
    return this->RecoveryTime_;
  }

  Incident::RecoveryTime_optional& Incident::
  RecoveryTime ()
  {
    return this->RecoveryTime_;
  }

  void Incident::
  RecoveryTime (const RecoveryTime_type& x)
  {
    this->RecoveryTime_.set (x);
  }

  void Incident::
  RecoveryTime (const RecoveryTime_optional& x)
  {
    this->RecoveryTime_ = x;
  }

  void Incident::
  RecoveryTime (::std::auto_ptr< RecoveryTime_type > x)
  {
    this->RecoveryTime_.set (x);
  }

  const Incident::ReportTime_type& Incident::
  ReportTime () const
  {
    return this->ReportTime_.get ();
  }

  Incident::ReportTime_type& Incident::
  ReportTime ()
  {
    return this->ReportTime_.get ();
  }

  void Incident::
  ReportTime (const ReportTime_type& x)
  {
    this->ReportTime_.set (x);
  }

  void Incident::
  ReportTime (::std::auto_ptr< ReportTime_type > x)
  {
    this->ReportTime_.set (x);
  }

  const Incident::GenerationTime_optional& Incident::
  GenerationTime () const
  {
    return this->GenerationTime_;
  }

  Incident::GenerationTime_optional& Incident::
  GenerationTime ()
  {
    return this->GenerationTime_;
  }

  void Incident::
  GenerationTime (const GenerationTime_type& x)
  {
    this->GenerationTime_.set (x);
  }

  void Incident::
  GenerationTime (const GenerationTime_optional& x)
  {
    this->GenerationTime_ = x;
  }

  void Incident::
  GenerationTime (::std::auto_ptr< GenerationTime_type > x)
  {
    this->GenerationTime_.set (x);
  }

  const Incident::Description_sequence& Incident::
  Description () const
  {
    return this->Description_;
  }

  Incident::Description_sequence& Incident::
  Description ()
  {
    return this->Description_;
  }

  void Incident::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Incident::Discovery_sequence& Incident::
  Discovery () const
  {
    return this->Discovery_;
  }

  Incident::Discovery_sequence& Incident::
  Discovery ()
  {
    return this->Discovery_;
  }

  void Incident::
  Discovery (const Discovery_sequence& s)
  {
    this->Discovery_ = s;
  }

  const Incident::Assessment_sequence& Incident::
  Assessment () const
  {
    return this->Assessment_;
  }

  Incident::Assessment_sequence& Incident::
  Assessment ()
  {
    return this->Assessment_;
  }

  void Incident::
  Assessment (const Assessment_sequence& s)
  {
    this->Assessment_ = s;
  }

  const Incident::Method_sequence& Incident::
  Method () const
  {
    return this->Method_;
  }

  Incident::Method_sequence& Incident::
  Method ()
  {
    return this->Method_;
  }

  void Incident::
  Method (const Method_sequence& s)
  {
    this->Method_ = s;
  }

  const Incident::Contact_sequence& Incident::
  Contact () const
  {
    return this->Contact_;
  }

  Incident::Contact_sequence& Incident::
  Contact ()
  {
    return this->Contact_;
  }

  void Incident::
  Contact (const Contact_sequence& s)
  {
    this->Contact_ = s;
  }

  const Incident::EventData_sequence& Incident::
  EventData () const
  {
    return this->EventData_;
  }

  Incident::EventData_sequence& Incident::
  EventData ()
  {
    return this->EventData_;
  }

  void Incident::
  EventData (const EventData_sequence& s)
  {
    this->EventData_ = s;
  }

  const Incident::History_optional& Incident::
  History () const
  {
    return this->History_;
  }

  Incident::History_optional& Incident::
  History ()
  {
    return this->History_;
  }

  void Incident::
  History (const History_type& x)
  {
    this->History_.set (x);
  }

  void Incident::
  History (const History_optional& x)
  {
    this->History_ = x;
  }

  void Incident::
  History (::std::auto_ptr< History_type > x)
  {
    this->History_.set (x);
  }

  const Incident::AdditionalData_sequence& Incident::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Incident::AdditionalData_sequence& Incident::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Incident::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Incident::purpose_type& Incident::
  purpose () const
  {
    return this->purpose_.get ();
  }

  Incident::purpose_type& Incident::
  purpose ()
  {
    return this->purpose_.get ();
  }

  void Incident::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void Incident::
  purpose (::std::auto_ptr< purpose_type > x)
  {
    this->purpose_.set (x);
  }

  const Incident::ext_purpose_optional& Incident::
  ext_purpose () const
  {
    return this->ext_purpose_;
  }

  Incident::ext_purpose_optional& Incident::
  ext_purpose ()
  {
    return this->ext_purpose_;
  }

  void Incident::
  ext_purpose (const ext_purpose_type& x)
  {
    this->ext_purpose_.set (x);
  }

  void Incident::
  ext_purpose (const ext_purpose_optional& x)
  {
    this->ext_purpose_ = x;
  }

  void Incident::
  ext_purpose (::std::auto_ptr< ext_purpose_type > x)
  {
    this->ext_purpose_.set (x);
  }

  const Incident::status_optional& Incident::
  status () const
  {
    return this->status_;
  }

  Incident::status_optional& Incident::
  status ()
  {
    return this->status_;
  }

  void Incident::
  status (const status_type& x)
  {
    this->status_.set (x);
  }

  void Incident::
  status (const status_optional& x)
  {
    this->status_ = x;
  }

  void Incident::
  status (::std::auto_ptr< status_type > x)
  {
    this->status_.set (x);
  }

  const Incident::ext_status_optional& Incident::
  ext_status () const
  {
    return this->ext_status_;
  }

  Incident::ext_status_optional& Incident::
  ext_status ()
  {
    return this->ext_status_;
  }

  void Incident::
  ext_status (const ext_status_type& x)
  {
    this->ext_status_.set (x);
  }

  void Incident::
  ext_status (const ext_status_optional& x)
  {
    this->ext_status_ = x;
  }

  void Incident::
  ext_status (::std::auto_ptr< ext_status_type > x)
  {
    this->ext_status_.set (x);
  }

  const Incident::lang_optional& Incident::
  lang () const
  {
    return this->lang_;
  }

  Incident::lang_optional& Incident::
  lang ()
  {
    return this->lang_;
  }

  void Incident::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void Incident::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void Incident::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const Incident::restriction_type& Incident::
  restriction () const
  {
    return this->restriction_.get ();
  }

  Incident::restriction_type& Incident::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void Incident::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Incident::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Incident::restriction_type& Incident::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }

  const Incident::ext_restriction_optional& Incident::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Incident::ext_restriction_optional& Incident::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Incident::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Incident::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Incident::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }

  const Incident::observable_id_optional& Incident::
  observable_id () const
  {
    return this->observable_id_;
  }

  Incident::observable_id_optional& Incident::
  observable_id ()
  {
    return this->observable_id_;
  }

  void Incident::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void Incident::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void Incident::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // AlternativeID
  // 

  const AlternativeID::IncidentID_sequence& AlternativeID::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  AlternativeID::IncidentID_sequence& AlternativeID::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void AlternativeID::
  IncidentID (const IncidentID_sequence& s)
  {
    this->IncidentID_ = s;
  }

  const AlternativeID::restriction_optional& AlternativeID::
  restriction () const
  {
    return this->restriction_;
  }

  AlternativeID::restriction_optional& AlternativeID::
  restriction ()
  {
    return this->restriction_;
  }

  void AlternativeID::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void AlternativeID::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void AlternativeID::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const AlternativeID::ext_restriction_optional& AlternativeID::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  AlternativeID::ext_restriction_optional& AlternativeID::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void AlternativeID::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void AlternativeID::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void AlternativeID::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // RelatedActivity
  // 

  const RelatedActivity::IncidentID_sequence& RelatedActivity::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  RelatedActivity::IncidentID_sequence& RelatedActivity::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void RelatedActivity::
  IncidentID (const IncidentID_sequence& s)
  {
    this->IncidentID_ = s;
  }

  const RelatedActivity::URL_sequence& RelatedActivity::
  URL () const
  {
    return this->URL_;
  }

  RelatedActivity::URL_sequence& RelatedActivity::
  URL ()
  {
    return this->URL_;
  }

  void RelatedActivity::
  URL (const URL_sequence& s)
  {
    this->URL_ = s;
  }

  const RelatedActivity::ThreatActor_sequence& RelatedActivity::
  ThreatActor () const
  {
    return this->ThreatActor_;
  }

  RelatedActivity::ThreatActor_sequence& RelatedActivity::
  ThreatActor ()
  {
    return this->ThreatActor_;
  }

  void RelatedActivity::
  ThreatActor (const ThreatActor_sequence& s)
  {
    this->ThreatActor_ = s;
  }

  const RelatedActivity::Campaign_sequence& RelatedActivity::
  Campaign () const
  {
    return this->Campaign_;
  }

  RelatedActivity::Campaign_sequence& RelatedActivity::
  Campaign ()
  {
    return this->Campaign_;
  }

  void RelatedActivity::
  Campaign (const Campaign_sequence& s)
  {
    this->Campaign_ = s;
  }

  const RelatedActivity::Confidence_optional& RelatedActivity::
  Confidence () const
  {
    return this->Confidence_;
  }

  RelatedActivity::Confidence_optional& RelatedActivity::
  Confidence ()
  {
    return this->Confidence_;
  }

  void RelatedActivity::
  Confidence (const Confidence_type& x)
  {
    this->Confidence_.set (x);
  }

  void RelatedActivity::
  Confidence (const Confidence_optional& x)
  {
    this->Confidence_ = x;
  }

  void RelatedActivity::
  Confidence (::std::auto_ptr< Confidence_type > x)
  {
    this->Confidence_.set (x);
  }

  const RelatedActivity::Description_sequence& RelatedActivity::
  Description () const
  {
    return this->Description_;
  }

  RelatedActivity::Description_sequence& RelatedActivity::
  Description ()
  {
    return this->Description_;
  }

  void RelatedActivity::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const RelatedActivity::AdditionalData_sequence& RelatedActivity::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  RelatedActivity::AdditionalData_sequence& RelatedActivity::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void RelatedActivity::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const RelatedActivity::restriction_optional& RelatedActivity::
  restriction () const
  {
    return this->restriction_;
  }

  RelatedActivity::restriction_optional& RelatedActivity::
  restriction ()
  {
    return this->restriction_;
  }

  void RelatedActivity::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void RelatedActivity::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void RelatedActivity::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const RelatedActivity::ext_restriction_optional& RelatedActivity::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  RelatedActivity::ext_restriction_optional& RelatedActivity::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void RelatedActivity::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void RelatedActivity::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void RelatedActivity::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // ThreatActor
  // 

  const ThreatActor::ThreatActorID_optional& ThreatActor::
  ThreatActorID () const
  {
    return this->ThreatActorID_;
  }

  ThreatActor::ThreatActorID_optional& ThreatActor::
  ThreatActorID ()
  {
    return this->ThreatActorID_;
  }

  void ThreatActor::
  ThreatActorID (const ThreatActorID_type& x)
  {
    this->ThreatActorID_.set (x);
  }

  void ThreatActor::
  ThreatActorID (const ThreatActorID_optional& x)
  {
    this->ThreatActorID_ = x;
  }

  void ThreatActor::
  ThreatActorID (::std::auto_ptr< ThreatActorID_type > x)
  {
    this->ThreatActorID_.set (x);
  }

  const ThreatActor::Description_sequence& ThreatActor::
  Description () const
  {
    return this->Description_;
  }

  ThreatActor::Description_sequence& ThreatActor::
  Description ()
  {
    return this->Description_;
  }

  void ThreatActor::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const ThreatActor::AdditionalData_sequence& ThreatActor::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  ThreatActor::AdditionalData_sequence& ThreatActor::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void ThreatActor::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const ThreatActor::restriction_optional& ThreatActor::
  restriction () const
  {
    return this->restriction_;
  }

  ThreatActor::restriction_optional& ThreatActor::
  restriction ()
  {
    return this->restriction_;
  }

  void ThreatActor::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void ThreatActor::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void ThreatActor::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const ThreatActor::ext_restriction_optional& ThreatActor::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  ThreatActor::ext_restriction_optional& ThreatActor::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void ThreatActor::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void ThreatActor::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void ThreatActor::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // Campaign
  // 

  const Campaign::CampaignID_optional& Campaign::
  CampaignID () const
  {
    return this->CampaignID_;
  }

  Campaign::CampaignID_optional& Campaign::
  CampaignID ()
  {
    return this->CampaignID_;
  }

  void Campaign::
  CampaignID (const CampaignID_type& x)
  {
    this->CampaignID_.set (x);
  }

  void Campaign::
  CampaignID (const CampaignID_optional& x)
  {
    this->CampaignID_ = x;
  }

  void Campaign::
  CampaignID (::std::auto_ptr< CampaignID_type > x)
  {
    this->CampaignID_.set (x);
  }

  const Campaign::Description_sequence& Campaign::
  Description () const
  {
    return this->Description_;
  }

  Campaign::Description_sequence& Campaign::
  Description ()
  {
    return this->Description_;
  }

  void Campaign::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Campaign::AdditionalData_sequence& Campaign::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Campaign::AdditionalData_sequence& Campaign::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Campaign::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Campaign::restriction_optional& Campaign::
  restriction () const
  {
    return this->restriction_;
  }

  Campaign::restriction_optional& Campaign::
  restriction ()
  {
    return this->restriction_;
  }

  void Campaign::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Campaign::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Campaign::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Campaign::ext_restriction_optional& Campaign::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Campaign::ext_restriction_optional& Campaign::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Campaign::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Campaign::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Campaign::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // Contact
  // 

  const Contact::ContactName_sequence& Contact::
  ContactName () const
  {
    return this->ContactName_;
  }

  Contact::ContactName_sequence& Contact::
  ContactName ()
  {
    return this->ContactName_;
  }

  void Contact::
  ContactName (const ContactName_sequence& s)
  {
    this->ContactName_ = s;
  }

  const Contact::ContactTitle_sequence& Contact::
  ContactTitle () const
  {
    return this->ContactTitle_;
  }

  Contact::ContactTitle_sequence& Contact::
  ContactTitle ()
  {
    return this->ContactTitle_;
  }

  void Contact::
  ContactTitle (const ContactTitle_sequence& s)
  {
    this->ContactTitle_ = s;
  }

  const Contact::Description_sequence& Contact::
  Description () const
  {
    return this->Description_;
  }

  Contact::Description_sequence& Contact::
  Description ()
  {
    return this->Description_;
  }

  void Contact::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Contact::RegistryHandle_sequence& Contact::
  RegistryHandle () const
  {
    return this->RegistryHandle_;
  }

  Contact::RegistryHandle_sequence& Contact::
  RegistryHandle ()
  {
    return this->RegistryHandle_;
  }

  void Contact::
  RegistryHandle (const RegistryHandle_sequence& s)
  {
    this->RegistryHandle_ = s;
  }

  const Contact::PostalAddress_optional& Contact::
  PostalAddress () const
  {
    return this->PostalAddress_;
  }

  Contact::PostalAddress_optional& Contact::
  PostalAddress ()
  {
    return this->PostalAddress_;
  }

  void Contact::
  PostalAddress (const PostalAddress_type& x)
  {
    this->PostalAddress_.set (x);
  }

  void Contact::
  PostalAddress (const PostalAddress_optional& x)
  {
    this->PostalAddress_ = x;
  }

  void Contact::
  PostalAddress (::std::auto_ptr< PostalAddress_type > x)
  {
    this->PostalAddress_.set (x);
  }

  const Contact::Email_sequence& Contact::
  Email () const
  {
    return this->Email_;
  }

  Contact::Email_sequence& Contact::
  Email ()
  {
    return this->Email_;
  }

  void Contact::
  Email (const Email_sequence& s)
  {
    this->Email_ = s;
  }

  const Contact::Telephone_sequence& Contact::
  Telephone () const
  {
    return this->Telephone_;
  }

  Contact::Telephone_sequence& Contact::
  Telephone ()
  {
    return this->Telephone_;
  }

  void Contact::
  Telephone (const Telephone_sequence& s)
  {
    this->Telephone_ = s;
  }

  const Contact::Fax_optional& Contact::
  Fax () const
  {
    return this->Fax_;
  }

  Contact::Fax_optional& Contact::
  Fax ()
  {
    return this->Fax_;
  }

  void Contact::
  Fax (const Fax_type& x)
  {
    this->Fax_.set (x);
  }

  void Contact::
  Fax (const Fax_optional& x)
  {
    this->Fax_ = x;
  }

  void Contact::
  Fax (::std::auto_ptr< Fax_type > x)
  {
    this->Fax_.set (x);
  }

  const Contact::Timezone_optional& Contact::
  Timezone () const
  {
    return this->Timezone_;
  }

  Contact::Timezone_optional& Contact::
  Timezone ()
  {
    return this->Timezone_;
  }

  void Contact::
  Timezone (const Timezone_type& x)
  {
    this->Timezone_.set (x);
  }

  void Contact::
  Timezone (const Timezone_optional& x)
  {
    this->Timezone_ = x;
  }

  void Contact::
  Timezone (::std::auto_ptr< Timezone_type > x)
  {
    this->Timezone_.set (x);
  }

  const Contact::Contact1_sequence& Contact::
  Contact1 () const
  {
    return this->Contact1_;
  }

  Contact::Contact1_sequence& Contact::
  Contact1 ()
  {
    return this->Contact1_;
  }

  void Contact::
  Contact1 (const Contact1_sequence& s)
  {
    this->Contact1_ = s;
  }

  const Contact::AdditionalData_sequence& Contact::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Contact::AdditionalData_sequence& Contact::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Contact::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Contact::role_type& Contact::
  role () const
  {
    return this->role_.get ();
  }

  Contact::role_type& Contact::
  role ()
  {
    return this->role_.get ();
  }

  void Contact::
  role (const role_type& x)
  {
    this->role_.set (x);
  }

  void Contact::
  role (::std::auto_ptr< role_type > x)
  {
    this->role_.set (x);
  }

  const Contact::ext_role_optional& Contact::
  ext_role () const
  {
    return this->ext_role_;
  }

  Contact::ext_role_optional& Contact::
  ext_role ()
  {
    return this->ext_role_;
  }

  void Contact::
  ext_role (const ext_role_type& x)
  {
    this->ext_role_.set (x);
  }

  void Contact::
  ext_role (const ext_role_optional& x)
  {
    this->ext_role_ = x;
  }

  void Contact::
  ext_role (::std::auto_ptr< ext_role_type > x)
  {
    this->ext_role_.set (x);
  }

  const Contact::type_type& Contact::
  type () const
  {
    return this->type_.get ();
  }

  Contact::type_type& Contact::
  type ()
  {
    return this->type_.get ();
  }

  void Contact::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Contact::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const Contact::ext_type_optional& Contact::
  ext_type () const
  {
    return this->ext_type_;
  }

  Contact::ext_type_optional& Contact::
  ext_type ()
  {
    return this->ext_type_;
  }

  void Contact::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void Contact::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void Contact::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const Contact::restriction_optional& Contact::
  restriction () const
  {
    return this->restriction_;
  }

  Contact::restriction_optional& Contact::
  restriction ()
  {
    return this->restriction_;
  }

  void Contact::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Contact::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Contact::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Contact::ext_restriction_optional& Contact::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Contact::ext_restriction_optional& Contact::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Contact::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Contact::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Contact::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // RegistryHandle
  // 

  const RegistryHandle::registry_optional& RegistryHandle::
  registry () const
  {
    return this->registry_;
  }

  RegistryHandle::registry_optional& RegistryHandle::
  registry ()
  {
    return this->registry_;
  }

  void RegistryHandle::
  registry (const registry_type& x)
  {
    this->registry_.set (x);
  }

  void RegistryHandle::
  registry (const registry_optional& x)
  {
    this->registry_ = x;
  }

  void RegistryHandle::
  registry (::std::auto_ptr< registry_type > x)
  {
    this->registry_.set (x);
  }

  const RegistryHandle::ext_registry_optional& RegistryHandle::
  ext_registry () const
  {
    return this->ext_registry_;
  }

  RegistryHandle::ext_registry_optional& RegistryHandle::
  ext_registry ()
  {
    return this->ext_registry_;
  }

  void RegistryHandle::
  ext_registry (const ext_registry_type& x)
  {
    this->ext_registry_.set (x);
  }

  void RegistryHandle::
  ext_registry (const ext_registry_optional& x)
  {
    this->ext_registry_ = x;
  }

  void RegistryHandle::
  ext_registry (::std::auto_ptr< ext_registry_type > x)
  {
    this->ext_registry_.set (x);
  }


  // PostalAddress
  // 

  const PostalAddress::meaning_optional& PostalAddress::
  meaning () const
  {
    return this->meaning_;
  }

  PostalAddress::meaning_optional& PostalAddress::
  meaning ()
  {
    return this->meaning_;
  }

  void PostalAddress::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void PostalAddress::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void PostalAddress::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }


  // History
  // 

  const History::HistoryItem_sequence& History::
  HistoryItem () const
  {
    return this->HistoryItem_;
  }

  History::HistoryItem_sequence& History::
  HistoryItem ()
  {
    return this->HistoryItem_;
  }

  void History::
  HistoryItem (const HistoryItem_sequence& s)
  {
    this->HistoryItem_ = s;
  }

  const History::restriction_type& History::
  restriction () const
  {
    return this->restriction_.get ();
  }

  History::restriction_type& History::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void History::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void History::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const History::restriction_type& History::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }

  const History::ext_restriction_optional& History::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  History::ext_restriction_optional& History::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void History::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void History::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void History::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // HistoryItem
  // 

  const HistoryItem::DateTime_type& HistoryItem::
  DateTime () const
  {
    return this->DateTime_.get ();
  }

  HistoryItem::DateTime_type& HistoryItem::
  DateTime ()
  {
    return this->DateTime_.get ();
  }

  void HistoryItem::
  DateTime (const DateTime_type& x)
  {
    this->DateTime_.set (x);
  }

  void HistoryItem::
  DateTime (::std::auto_ptr< DateTime_type > x)
  {
    this->DateTime_.set (x);
  }

  const HistoryItem::IncidentID_optional& HistoryItem::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  HistoryItem::IncidentID_optional& HistoryItem::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void HistoryItem::
  IncidentID (const IncidentID_type& x)
  {
    this->IncidentID_.set (x);
  }

  void HistoryItem::
  IncidentID (const IncidentID_optional& x)
  {
    this->IncidentID_ = x;
  }

  void HistoryItem::
  IncidentID (::std::auto_ptr< IncidentID_type > x)
  {
    this->IncidentID_.set (x);
  }

  const HistoryItem::Contact_optional& HistoryItem::
  Contact () const
  {
    return this->Contact_;
  }

  HistoryItem::Contact_optional& HistoryItem::
  Contact ()
  {
    return this->Contact_;
  }

  void HistoryItem::
  Contact (const Contact_type& x)
  {
    this->Contact_.set (x);
  }

  void HistoryItem::
  Contact (const Contact_optional& x)
  {
    this->Contact_ = x;
  }

  void HistoryItem::
  Contact (::std::auto_ptr< Contact_type > x)
  {
    this->Contact_.set (x);
  }

  const HistoryItem::Description_sequence& HistoryItem::
  Description () const
  {
    return this->Description_;
  }

  HistoryItem::Description_sequence& HistoryItem::
  Description ()
  {
    return this->Description_;
  }

  void HistoryItem::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const HistoryItem::DefinedCOA_sequence& HistoryItem::
  DefinedCOA () const
  {
    return this->DefinedCOA_;
  }

  HistoryItem::DefinedCOA_sequence& HistoryItem::
  DefinedCOA ()
  {
    return this->DefinedCOA_;
  }

  void HistoryItem::
  DefinedCOA (const DefinedCOA_sequence& s)
  {
    this->DefinedCOA_ = s;
  }

  const HistoryItem::AdditionalData_sequence& HistoryItem::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  HistoryItem::AdditionalData_sequence& HistoryItem::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void HistoryItem::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const HistoryItem::restriction_optional& HistoryItem::
  restriction () const
  {
    return this->restriction_;
  }

  HistoryItem::restriction_optional& HistoryItem::
  restriction ()
  {
    return this->restriction_;
  }

  void HistoryItem::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void HistoryItem::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void HistoryItem::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const HistoryItem::ext_restriction_optional& HistoryItem::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  HistoryItem::ext_restriction_optional& HistoryItem::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void HistoryItem::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void HistoryItem::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void HistoryItem::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }

  const HistoryItem::action_type& HistoryItem::
  action () const
  {
    return this->action_.get ();
  }

  HistoryItem::action_type& HistoryItem::
  action ()
  {
    return this->action_.get ();
  }

  void HistoryItem::
  action (const action_type& x)
  {
    this->action_.set (x);
  }

  void HistoryItem::
  action (::std::auto_ptr< action_type > x)
  {
    this->action_.set (x);
  }

  const HistoryItem::ext_action_optional& HistoryItem::
  ext_action () const
  {
    return this->ext_action_;
  }

  HistoryItem::ext_action_optional& HistoryItem::
  ext_action ()
  {
    return this->ext_action_;
  }

  void HistoryItem::
  ext_action (const ext_action_type& x)
  {
    this->ext_action_.set (x);
  }

  void HistoryItem::
  ext_action (const ext_action_optional& x)
  {
    this->ext_action_ = x;
  }

  void HistoryItem::
  ext_action (::std::auto_ptr< ext_action_type > x)
  {
    this->ext_action_.set (x);
  }

  const HistoryItem::observable_id_optional& HistoryItem::
  observable_id () const
  {
    return this->observable_id_;
  }

  HistoryItem::observable_id_optional& HistoryItem::
  observable_id ()
  {
    return this->observable_id_;
  }

  void HistoryItem::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void HistoryItem::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void HistoryItem::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // Expectation
  // 

  const Expectation::Description_sequence& Expectation::
  Description () const
  {
    return this->Description_;
  }

  Expectation::Description_sequence& Expectation::
  Description ()
  {
    return this->Description_;
  }

  void Expectation::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Expectation::DefinedCOA_sequence& Expectation::
  DefinedCOA () const
  {
    return this->DefinedCOA_;
  }

  Expectation::DefinedCOA_sequence& Expectation::
  DefinedCOA ()
  {
    return this->DefinedCOA_;
  }

  void Expectation::
  DefinedCOA (const DefinedCOA_sequence& s)
  {
    this->DefinedCOA_ = s;
  }

  const Expectation::StartTime_optional& Expectation::
  StartTime () const
  {
    return this->StartTime_;
  }

  Expectation::StartTime_optional& Expectation::
  StartTime ()
  {
    return this->StartTime_;
  }

  void Expectation::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void Expectation::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void Expectation::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const Expectation::EndTime_optional& Expectation::
  EndTime () const
  {
    return this->EndTime_;
  }

  Expectation::EndTime_optional& Expectation::
  EndTime ()
  {
    return this->EndTime_;
  }

  void Expectation::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void Expectation::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void Expectation::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const Expectation::Contact_optional& Expectation::
  Contact () const
  {
    return this->Contact_;
  }

  Expectation::Contact_optional& Expectation::
  Contact ()
  {
    return this->Contact_;
  }

  void Expectation::
  Contact (const Contact_type& x)
  {
    this->Contact_.set (x);
  }

  void Expectation::
  Contact (const Contact_optional& x)
  {
    this->Contact_ = x;
  }

  void Expectation::
  Contact (::std::auto_ptr< Contact_type > x)
  {
    this->Contact_.set (x);
  }

  const Expectation::restriction_type& Expectation::
  restriction () const
  {
    return this->restriction_.get ();
  }

  Expectation::restriction_type& Expectation::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void Expectation::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Expectation::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Expectation::restriction_type& Expectation::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }

  const Expectation::ext_restriction_optional& Expectation::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Expectation::ext_restriction_optional& Expectation::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Expectation::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Expectation::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Expectation::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }

  const Expectation::severity_optional& Expectation::
  severity () const
  {
    return this->severity_;
  }

  Expectation::severity_optional& Expectation::
  severity ()
  {
    return this->severity_;
  }

  void Expectation::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void Expectation::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void Expectation::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const Expectation::action_type& Expectation::
  action () const
  {
    return this->action_.get ();
  }

  Expectation::action_type& Expectation::
  action ()
  {
    return this->action_.get ();
  }

  void Expectation::
  action (const action_type& x)
  {
    this->action_.set (x);
  }

  void Expectation::
  action (::std::auto_ptr< action_type > x)
  {
    this->action_.set (x);
  }

  const Expectation::action_type& Expectation::
  action_default_value ()
  {
    return action_default_value_;
  }

  const Expectation::ext_action_optional& Expectation::
  ext_action () const
  {
    return this->ext_action_;
  }

  Expectation::ext_action_optional& Expectation::
  ext_action ()
  {
    return this->ext_action_;
  }

  void Expectation::
  ext_action (const ext_action_type& x)
  {
    this->ext_action_.set (x);
  }

  void Expectation::
  ext_action (const ext_action_optional& x)
  {
    this->ext_action_ = x;
  }

  void Expectation::
  ext_action (::std::auto_ptr< ext_action_type > x)
  {
    this->ext_action_.set (x);
  }

  const Expectation::observable_id_optional& Expectation::
  observable_id () const
  {
    return this->observable_id_;
  }

  Expectation::observable_id_optional& Expectation::
  observable_id ()
  {
    return this->observable_id_;
  }

  void Expectation::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void Expectation::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void Expectation::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // Discovery
  // 

  const Discovery::Description_sequence& Discovery::
  Description () const
  {
    return this->Description_;
  }

  Discovery::Description_sequence& Discovery::
  Description ()
  {
    return this->Description_;
  }

  void Discovery::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Discovery::Contact_sequence& Discovery::
  Contact () const
  {
    return this->Contact_;
  }

  Discovery::Contact_sequence& Discovery::
  Contact ()
  {
    return this->Contact_;
  }

  void Discovery::
  Contact (const Contact_sequence& s)
  {
    this->Contact_ = s;
  }

  const Discovery::DetectionPattern_sequence& Discovery::
  DetectionPattern () const
  {
    return this->DetectionPattern_;
  }

  Discovery::DetectionPattern_sequence& Discovery::
  DetectionPattern ()
  {
    return this->DetectionPattern_;
  }

  void Discovery::
  DetectionPattern (const DetectionPattern_sequence& s)
  {
    this->DetectionPattern_ = s;
  }

  const Discovery::source_type& Discovery::
  source () const
  {
    return this->source_.get ();
  }

  Discovery::source_type& Discovery::
  source ()
  {
    return this->source_.get ();
  }

  void Discovery::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void Discovery::
  source (::std::auto_ptr< source_type > x)
  {
    this->source_.set (x);
  }

  const Discovery::source_type& Discovery::
  source_default_value ()
  {
    return source_default_value_;
  }

  const Discovery::ext_source_optional& Discovery::
  ext_source () const
  {
    return this->ext_source_;
  }

  Discovery::ext_source_optional& Discovery::
  ext_source ()
  {
    return this->ext_source_;
  }

  void Discovery::
  ext_source (const ext_source_type& x)
  {
    this->ext_source_.set (x);
  }

  void Discovery::
  ext_source (const ext_source_optional& x)
  {
    this->ext_source_ = x;
  }

  void Discovery::
  ext_source (::std::auto_ptr< ext_source_type > x)
  {
    this->ext_source_.set (x);
  }

  const Discovery::restriction_optional& Discovery::
  restriction () const
  {
    return this->restriction_;
  }

  Discovery::restriction_optional& Discovery::
  restriction ()
  {
    return this->restriction_;
  }

  void Discovery::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Discovery::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Discovery::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Discovery::ext_restriction_optional& Discovery::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Discovery::ext_restriction_optional& Discovery::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Discovery::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Discovery::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Discovery::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // DetectionPattern
  // 

  const DetectionPattern::Application_type& DetectionPattern::
  Application () const
  {
    return this->Application_.get ();
  }

  DetectionPattern::Application_type& DetectionPattern::
  Application ()
  {
    return this->Application_.get ();
  }

  void DetectionPattern::
  Application (const Application_type& x)
  {
    this->Application_.set (x);
  }

  void DetectionPattern::
  Application (::std::auto_ptr< Application_type > x)
  {
    this->Application_.set (x);
  }

  const DetectionPattern::Description_sequence& DetectionPattern::
  Description () const
  {
    return this->Description_;
  }

  DetectionPattern::Description_sequence& DetectionPattern::
  Description ()
  {
    return this->Description_;
  }

  void DetectionPattern::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const DetectionPattern::DetectionConfiguration_sequence& DetectionPattern::
  DetectionConfiguration () const
  {
    return this->DetectionConfiguration_;
  }

  DetectionPattern::DetectionConfiguration_sequence& DetectionPattern::
  DetectionConfiguration ()
  {
    return this->DetectionConfiguration_;
  }

  void DetectionPattern::
  DetectionConfiguration (const DetectionConfiguration_sequence& s)
  {
    this->DetectionConfiguration_ = s;
  }

  const DetectionPattern::restriction_optional& DetectionPattern::
  restriction () const
  {
    return this->restriction_;
  }

  DetectionPattern::restriction_optional& DetectionPattern::
  restriction ()
  {
    return this->restriction_;
  }

  void DetectionPattern::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void DetectionPattern::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void DetectionPattern::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const DetectionPattern::ext_restriction_optional& DetectionPattern::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  DetectionPattern::ext_restriction_optional& DetectionPattern::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void DetectionPattern::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void DetectionPattern::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void DetectionPattern::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // Method
  // 

  const Method::Reference_sequence& Method::
  Reference () const
  {
    return this->Reference_;
  }

  Method::Reference_sequence& Method::
  Reference ()
  {
    return this->Reference_;
  }

  void Method::
  Reference (const Reference_sequence& s)
  {
    this->Reference_ = s;
  }

  const Method::Description_sequence& Method::
  Description () const
  {
    return this->Description_;
  }

  Method::Description_sequence& Method::
  Description ()
  {
    return this->Description_;
  }

  void Method::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Method::AdditionalData_sequence& Method::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Method::AdditionalData_sequence& Method::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Method::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Method::restriction_optional& Method::
  restriction () const
  {
    return this->restriction_;
  }

  Method::restriction_optional& Method::
  restriction ()
  {
    return this->restriction_;
  }

  void Method::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Method::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Method::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Method::ext_restriction_optional& Method::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Method::ext_restriction_optional& Method::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Method::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Method::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Method::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // Reference
  // 

  const Reference::ReferenceName_optional& Reference::
  ReferenceName () const
  {
    return this->ReferenceName_;
  }

  Reference::ReferenceName_optional& Reference::
  ReferenceName ()
  {
    return this->ReferenceName_;
  }

  void Reference::
  ReferenceName (const ReferenceName_type& x)
  {
    this->ReferenceName_.set (x);
  }

  void Reference::
  ReferenceName (const ReferenceName_optional& x)
  {
    this->ReferenceName_ = x;
  }

  void Reference::
  ReferenceName (::std::auto_ptr< ReferenceName_type > x)
  {
    this->ReferenceName_.set (x);
  }

  const Reference::URL_sequence& Reference::
  URL () const
  {
    return this->URL_;
  }

  Reference::URL_sequence& Reference::
  URL ()
  {
    return this->URL_;
  }

  void Reference::
  URL (const URL_sequence& s)
  {
    this->URL_ = s;
  }

  const Reference::Description_sequence& Reference::
  Description () const
  {
    return this->Description_;
  }

  Reference::Description_sequence& Reference::
  Description ()
  {
    return this->Description_;
  }

  void Reference::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Reference::observable_id_optional& Reference::
  observable_id () const
  {
    return this->observable_id_;
  }

  Reference::observable_id_optional& Reference::
  observable_id ()
  {
    return this->observable_id_;
  }

  void Reference::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void Reference::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void Reference::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // Assessment
  // 

  const Assessment::IncidentCategory_sequence& Assessment::
  IncidentCategory () const
  {
    return this->IncidentCategory_;
  }

  Assessment::IncidentCategory_sequence& Assessment::
  IncidentCategory ()
  {
    return this->IncidentCategory_;
  }

  void Assessment::
  IncidentCategory (const IncidentCategory_sequence& s)
  {
    this->IncidentCategory_ = s;
  }

  const Assessment::SystemImpact_sequence& Assessment::
  SystemImpact () const
  {
    return this->SystemImpact_;
  }

  Assessment::SystemImpact_sequence& Assessment::
  SystemImpact ()
  {
    return this->SystemImpact_;
  }

  void Assessment::
  SystemImpact (const SystemImpact_sequence& s)
  {
    this->SystemImpact_ = s;
  }

  const Assessment::BusinessImpact_sequence& Assessment::
  BusinessImpact () const
  {
    return this->BusinessImpact_;
  }

  Assessment::BusinessImpact_sequence& Assessment::
  BusinessImpact ()
  {
    return this->BusinessImpact_;
  }

  void Assessment::
  BusinessImpact (const BusinessImpact_sequence& s)
  {
    this->BusinessImpact_ = s;
  }

  const Assessment::TimeImpact_sequence& Assessment::
  TimeImpact () const
  {
    return this->TimeImpact_;
  }

  Assessment::TimeImpact_sequence& Assessment::
  TimeImpact ()
  {
    return this->TimeImpact_;
  }

  void Assessment::
  TimeImpact (const TimeImpact_sequence& s)
  {
    this->TimeImpact_ = s;
  }

  const Assessment::MonetaryImpact_sequence& Assessment::
  MonetaryImpact () const
  {
    return this->MonetaryImpact_;
  }

  Assessment::MonetaryImpact_sequence& Assessment::
  MonetaryImpact ()
  {
    return this->MonetaryImpact_;
  }

  void Assessment::
  MonetaryImpact (const MonetaryImpact_sequence& s)
  {
    this->MonetaryImpact_ = s;
  }

  const Assessment::IntendedImpact_sequence& Assessment::
  IntendedImpact () const
  {
    return this->IntendedImpact_;
  }

  Assessment::IntendedImpact_sequence& Assessment::
  IntendedImpact ()
  {
    return this->IntendedImpact_;
  }

  void Assessment::
  IntendedImpact (const IntendedImpact_sequence& s)
  {
    this->IntendedImpact_ = s;
  }

  const Assessment::Counter_sequence& Assessment::
  Counter () const
  {
    return this->Counter_;
  }

  Assessment::Counter_sequence& Assessment::
  Counter ()
  {
    return this->Counter_;
  }

  void Assessment::
  Counter (const Counter_sequence& s)
  {
    this->Counter_ = s;
  }

  const Assessment::MitigatingFactor_sequence& Assessment::
  MitigatingFactor () const
  {
    return this->MitigatingFactor_;
  }

  Assessment::MitigatingFactor_sequence& Assessment::
  MitigatingFactor ()
  {
    return this->MitigatingFactor_;
  }

  void Assessment::
  MitigatingFactor (const MitigatingFactor_sequence& s)
  {
    this->MitigatingFactor_ = s;
  }

  const Assessment::Confidence_optional& Assessment::
  Confidence () const
  {
    return this->Confidence_;
  }

  Assessment::Confidence_optional& Assessment::
  Confidence ()
  {
    return this->Confidence_;
  }

  void Assessment::
  Confidence (const Confidence_type& x)
  {
    this->Confidence_.set (x);
  }

  void Assessment::
  Confidence (const Confidence_optional& x)
  {
    this->Confidence_ = x;
  }

  void Assessment::
  Confidence (::std::auto_ptr< Confidence_type > x)
  {
    this->Confidence_.set (x);
  }

  const Assessment::AdditionalData_sequence& Assessment::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Assessment::AdditionalData_sequence& Assessment::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Assessment::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Assessment::occurrence_optional& Assessment::
  occurrence () const
  {
    return this->occurrence_;
  }

  Assessment::occurrence_optional& Assessment::
  occurrence ()
  {
    return this->occurrence_;
  }

  void Assessment::
  occurrence (const occurrence_type& x)
  {
    this->occurrence_.set (x);
  }

  void Assessment::
  occurrence (const occurrence_optional& x)
  {
    this->occurrence_ = x;
  }

  void Assessment::
  occurrence (::std::auto_ptr< occurrence_type > x)
  {
    this->occurrence_.set (x);
  }

  const Assessment::restriction_optional& Assessment::
  restriction () const
  {
    return this->restriction_;
  }

  Assessment::restriction_optional& Assessment::
  restriction ()
  {
    return this->restriction_;
  }

  void Assessment::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Assessment::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Assessment::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Assessment::ext_restriction_optional& Assessment::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Assessment::ext_restriction_optional& Assessment::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Assessment::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Assessment::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Assessment::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }

  const Assessment::observable_id_optional& Assessment::
  observable_id () const
  {
    return this->observable_id_;
  }

  Assessment::observable_id_optional& Assessment::
  observable_id ()
  {
    return this->observable_id_;
  }

  void Assessment::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void Assessment::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void Assessment::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // SystemImpact
  // 

  const SystemImpact::severity_optional& SystemImpact::
  severity () const
  {
    return this->severity_;
  }

  SystemImpact::severity_optional& SystemImpact::
  severity ()
  {
    return this->severity_;
  }

  void SystemImpact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void SystemImpact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void SystemImpact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const SystemImpact::completion_optional& SystemImpact::
  completion () const
  {
    return this->completion_;
  }

  SystemImpact::completion_optional& SystemImpact::
  completion ()
  {
    return this->completion_;
  }

  void SystemImpact::
  completion (const completion_type& x)
  {
    this->completion_.set (x);
  }

  void SystemImpact::
  completion (const completion_optional& x)
  {
    this->completion_ = x;
  }

  void SystemImpact::
  completion (::std::auto_ptr< completion_type > x)
  {
    this->completion_.set (x);
  }

  const SystemImpact::type_optional& SystemImpact::
  type () const
  {
    return this->type_;
  }

  SystemImpact::type_optional& SystemImpact::
  type ()
  {
    return this->type_;
  }

  void SystemImpact::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void SystemImpact::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void SystemImpact::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const SystemImpact::ext_type_optional& SystemImpact::
  ext_type () const
  {
    return this->ext_type_;
  }

  SystemImpact::ext_type_optional& SystemImpact::
  ext_type ()
  {
    return this->ext_type_;
  }

  void SystemImpact::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void SystemImpact::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void SystemImpact::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }


  // TimeImpact
  // 

  const TimeImpact::severity_optional& TimeImpact::
  severity () const
  {
    return this->severity_;
  }

  TimeImpact::severity_optional& TimeImpact::
  severity ()
  {
    return this->severity_;
  }

  void TimeImpact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void TimeImpact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void TimeImpact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const TimeImpact::metric_type& TimeImpact::
  metric () const
  {
    return this->metric_.get ();
  }

  TimeImpact::metric_type& TimeImpact::
  metric ()
  {
    return this->metric_.get ();
  }

  void TimeImpact::
  metric (const metric_type& x)
  {
    this->metric_.set (x);
  }

  void TimeImpact::
  metric (::std::auto_ptr< metric_type > x)
  {
    this->metric_.set (x);
  }

  const TimeImpact::duration_optional& TimeImpact::
  duration () const
  {
    return this->duration_;
  }

  TimeImpact::duration_optional& TimeImpact::
  duration ()
  {
    return this->duration_;
  }

  void TimeImpact::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void TimeImpact::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void TimeImpact::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }


  // MonetaryImpact
  // 

  const MonetaryImpact::severity_optional& MonetaryImpact::
  severity () const
  {
    return this->severity_;
  }

  MonetaryImpact::severity_optional& MonetaryImpact::
  severity ()
  {
    return this->severity_;
  }

  void MonetaryImpact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void MonetaryImpact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void MonetaryImpact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const MonetaryImpact::currency_optional& MonetaryImpact::
  currency () const
  {
    return this->currency_;
  }

  MonetaryImpact::currency_optional& MonetaryImpact::
  currency ()
  {
    return this->currency_;
  }

  void MonetaryImpact::
  currency (const currency_type& x)
  {
    this->currency_.set (x);
  }

  void MonetaryImpact::
  currency (const currency_optional& x)
  {
    this->currency_ = x;
  }

  void MonetaryImpact::
  currency (::std::auto_ptr< currency_type > x)
  {
    this->currency_.set (x);
  }


  // Confidence
  // 

  const Confidence::rating_type& Confidence::
  rating () const
  {
    return this->rating_.get ();
  }

  Confidence::rating_type& Confidence::
  rating ()
  {
    return this->rating_.get ();
  }

  void Confidence::
  rating (const rating_type& x)
  {
    this->rating_.set (x);
  }

  void Confidence::
  rating (::std::auto_ptr< rating_type > x)
  {
    this->rating_.set (x);
  }


  // EventData
  // 

  const EventData::Description_sequence& EventData::
  Description () const
  {
    return this->Description_;
  }

  EventData::Description_sequence& EventData::
  Description ()
  {
    return this->Description_;
  }

  void EventData::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const EventData::DetectTime_optional& EventData::
  DetectTime () const
  {
    return this->DetectTime_;
  }

  EventData::DetectTime_optional& EventData::
  DetectTime ()
  {
    return this->DetectTime_;
  }

  void EventData::
  DetectTime (const DetectTime_type& x)
  {
    this->DetectTime_.set (x);
  }

  void EventData::
  DetectTime (const DetectTime_optional& x)
  {
    this->DetectTime_ = x;
  }

  void EventData::
  DetectTime (::std::auto_ptr< DetectTime_type > x)
  {
    this->DetectTime_.set (x);
  }

  const EventData::StartTime_optional& EventData::
  StartTime () const
  {
    return this->StartTime_;
  }

  EventData::StartTime_optional& EventData::
  StartTime ()
  {
    return this->StartTime_;
  }

  void EventData::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void EventData::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void EventData::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const EventData::EndTime_optional& EventData::
  EndTime () const
  {
    return this->EndTime_;
  }

  EventData::EndTime_optional& EventData::
  EndTime ()
  {
    return this->EndTime_;
  }

  void EventData::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void EventData::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void EventData::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const EventData::RecoveryTime_optional& EventData::
  RecoveryTime () const
  {
    return this->RecoveryTime_;
  }

  EventData::RecoveryTime_optional& EventData::
  RecoveryTime ()
  {
    return this->RecoveryTime_;
  }

  void EventData::
  RecoveryTime (const RecoveryTime_type& x)
  {
    this->RecoveryTime_.set (x);
  }

  void EventData::
  RecoveryTime (const RecoveryTime_optional& x)
  {
    this->RecoveryTime_ = x;
  }

  void EventData::
  RecoveryTime (::std::auto_ptr< RecoveryTime_type > x)
  {
    this->RecoveryTime_.set (x);
  }

  const EventData::ReportTime_optional& EventData::
  ReportTime () const
  {
    return this->ReportTime_;
  }

  EventData::ReportTime_optional& EventData::
  ReportTime ()
  {
    return this->ReportTime_;
  }

  void EventData::
  ReportTime (const ReportTime_type& x)
  {
    this->ReportTime_.set (x);
  }

  void EventData::
  ReportTime (const ReportTime_optional& x)
  {
    this->ReportTime_ = x;
  }

  void EventData::
  ReportTime (::std::auto_ptr< ReportTime_type > x)
  {
    this->ReportTime_.set (x);
  }

  const EventData::Contact_sequence& EventData::
  Contact () const
  {
    return this->Contact_;
  }

  EventData::Contact_sequence& EventData::
  Contact ()
  {
    return this->Contact_;
  }

  void EventData::
  Contact (const Contact_sequence& s)
  {
    this->Contact_ = s;
  }

  const EventData::Discovery_sequence& EventData::
  Discovery () const
  {
    return this->Discovery_;
  }

  EventData::Discovery_sequence& EventData::
  Discovery ()
  {
    return this->Discovery_;
  }

  void EventData::
  Discovery (const Discovery_sequence& s)
  {
    this->Discovery_ = s;
  }

  const EventData::Assessment_optional& EventData::
  Assessment () const
  {
    return this->Assessment_;
  }

  EventData::Assessment_optional& EventData::
  Assessment ()
  {
    return this->Assessment_;
  }

  void EventData::
  Assessment (const Assessment_type& x)
  {
    this->Assessment_.set (x);
  }

  void EventData::
  Assessment (const Assessment_optional& x)
  {
    this->Assessment_ = x;
  }

  void EventData::
  Assessment (::std::auto_ptr< Assessment_type > x)
  {
    this->Assessment_.set (x);
  }

  const EventData::Method_sequence& EventData::
  Method () const
  {
    return this->Method_;
  }

  EventData::Method_sequence& EventData::
  Method ()
  {
    return this->Method_;
  }

  void EventData::
  Method (const Method_sequence& s)
  {
    this->Method_ = s;
  }

  const EventData::Flow_sequence& EventData::
  Flow () const
  {
    return this->Flow_;
  }

  EventData::Flow_sequence& EventData::
  Flow ()
  {
    return this->Flow_;
  }

  void EventData::
  Flow (const Flow_sequence& s)
  {
    this->Flow_ = s;
  }

  const EventData::Expectation_sequence& EventData::
  Expectation () const
  {
    return this->Expectation_;
  }

  EventData::Expectation_sequence& EventData::
  Expectation ()
  {
    return this->Expectation_;
  }

  void EventData::
  Expectation (const Expectation_sequence& s)
  {
    this->Expectation_ = s;
  }

  const EventData::Record_optional& EventData::
  Record () const
  {
    return this->Record_;
  }

  EventData::Record_optional& EventData::
  Record ()
  {
    return this->Record_;
  }

  void EventData::
  Record (const Record_type& x)
  {
    this->Record_.set (x);
  }

  void EventData::
  Record (const Record_optional& x)
  {
    this->Record_ = x;
  }

  void EventData::
  Record (::std::auto_ptr< Record_type > x)
  {
    this->Record_.set (x);
  }

  const EventData::EventData1_sequence& EventData::
  EventData1 () const
  {
    return this->EventData1_;
  }

  EventData::EventData1_sequence& EventData::
  EventData1 ()
  {
    return this->EventData1_;
  }

  void EventData::
  EventData1 (const EventData1_sequence& s)
  {
    this->EventData1_ = s;
  }

  const EventData::AdditionalData_sequence& EventData::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  EventData::AdditionalData_sequence& EventData::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void EventData::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const EventData::restriction_type& EventData::
  restriction () const
  {
    return this->restriction_.get ();
  }

  EventData::restriction_type& EventData::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void EventData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void EventData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const EventData::restriction_type& EventData::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }

  const EventData::ext_restriction_optional& EventData::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  EventData::ext_restriction_optional& EventData::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void EventData::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void EventData::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void EventData::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }

  const EventData::observable_id_optional& EventData::
  observable_id () const
  {
    return this->observable_id_;
  }

  EventData::observable_id_optional& EventData::
  observable_id ()
  {
    return this->observable_id_;
  }

  void EventData::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void EventData::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void EventData::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // Flow
  // 

  const Flow::System_sequence& Flow::
  System () const
  {
    return this->System_;
  }

  Flow::System_sequence& Flow::
  System ()
  {
    return this->System_;
  }

  void Flow::
  System (const System_sequence& s)
  {
    this->System_ = s;
  }


  // System
  // 

  const System::Node_sequence& System::
  Node () const
  {
    return this->Node_;
  }

  System::Node_sequence& System::
  Node ()
  {
    return this->Node_;
  }

  void System::
  Node (const Node_sequence& s)
  {
    this->Node_ = s;
  }

  const System::NodeRole_sequence& System::
  NodeRole () const
  {
    return this->NodeRole_;
  }

  System::NodeRole_sequence& System::
  NodeRole ()
  {
    return this->NodeRole_;
  }

  void System::
  NodeRole (const NodeRole_sequence& s)
  {
    this->NodeRole_ = s;
  }

  const System::Service_sequence& System::
  Service () const
  {
    return this->Service_;
  }

  System::Service_sequence& System::
  Service ()
  {
    return this->Service_;
  }

  void System::
  Service (const Service_sequence& s)
  {
    this->Service_ = s;
  }

  const System::OperatingSystem_sequence& System::
  OperatingSystem () const
  {
    return this->OperatingSystem_;
  }

  System::OperatingSystem_sequence& System::
  OperatingSystem ()
  {
    return this->OperatingSystem_;
  }

  void System::
  OperatingSystem (const OperatingSystem_sequence& s)
  {
    this->OperatingSystem_ = s;
  }

  const System::Counter_sequence& System::
  Counter () const
  {
    return this->Counter_;
  }

  System::Counter_sequence& System::
  Counter ()
  {
    return this->Counter_;
  }

  void System::
  Counter (const Counter_sequence& s)
  {
    this->Counter_ = s;
  }

  const System::AssetID_sequence& System::
  AssetID () const
  {
    return this->AssetID_;
  }

  System::AssetID_sequence& System::
  AssetID ()
  {
    return this->AssetID_;
  }

  void System::
  AssetID (const AssetID_sequence& s)
  {
    this->AssetID_ = s;
  }

  const System::Description_sequence& System::
  Description () const
  {
    return this->Description_;
  }

  System::Description_sequence& System::
  Description ()
  {
    return this->Description_;
  }

  void System::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const System::AdditionalData_sequence& System::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  System::AdditionalData_sequence& System::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void System::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const System::restriction_optional& System::
  restriction () const
  {
    return this->restriction_;
  }

  System::restriction_optional& System::
  restriction ()
  {
    return this->restriction_;
  }

  void System::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void System::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void System::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const System::ext_restriction_optional& System::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  System::ext_restriction_optional& System::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void System::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void System::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void System::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }

  const System::category_optional& System::
  category () const
  {
    return this->category_;
  }

  System::category_optional& System::
  category ()
  {
    return this->category_;
  }

  void System::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void System::
  category (const category_optional& x)
  {
    this->category_ = x;
  }

  void System::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const System::ext_category_optional& System::
  ext_category () const
  {
    return this->ext_category_;
  }

  System::ext_category_optional& System::
  ext_category ()
  {
    return this->ext_category_;
  }

  void System::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void System::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void System::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }

  const System::interface_optional& System::
  interface () const
  {
    return this->interface_;
  }

  System::interface_optional& System::
  interface ()
  {
    return this->interface_;
  }

  void System::
  interface (const interface_type& x)
  {
    this->interface_.set (x);
  }

  void System::
  interface (const interface_optional& x)
  {
    this->interface_ = x;
  }

  void System::
  interface (::std::auto_ptr< interface_type > x)
  {
    this->interface_.set (x);
  }

  const System::spoofed_type& System::
  spoofed () const
  {
    return this->spoofed_.get ();
  }

  System::spoofed_type& System::
  spoofed ()
  {
    return this->spoofed_.get ();
  }

  void System::
  spoofed (const spoofed_type& x)
  {
    this->spoofed_.set (x);
  }

  void System::
  spoofed (::std::auto_ptr< spoofed_type > x)
  {
    this->spoofed_.set (x);
  }

  const System::spoofed_type& System::
  spoofed_default_value ()
  {
    return spoofed_default_value_;
  }

  const System::virtual_type& System::
  virtual_ () const
  {
    return this->virtual__.get ();
  }

  System::virtual_type& System::
  virtual_ ()
  {
    return this->virtual__.get ();
  }

  void System::
  virtual_ (const virtual_type& x)
  {
    this->virtual__.set (x);
  }

  void System::
  virtual_ (::std::auto_ptr< virtual_type > x)
  {
    this->virtual__.set (x);
  }

  const System::virtual_type& System::
  virtual_default_value ()
  {
    return virtual__default_value_;
  }

  const System::ownership_optional& System::
  ownership () const
  {
    return this->ownership_;
  }

  System::ownership_optional& System::
  ownership ()
  {
    return this->ownership_;
  }

  void System::
  ownership (const ownership_type& x)
  {
    this->ownership_.set (x);
  }

  void System::
  ownership (const ownership_optional& x)
  {
    this->ownership_ = x;
  }

  void System::
  ownership (::std::auto_ptr< ownership_type > x)
  {
    this->ownership_.set (x);
  }

  const System::ext_ownership_optional& System::
  ext_ownership () const
  {
    return this->ext_ownership_;
  }

  System::ext_ownership_optional& System::
  ext_ownership ()
  {
    return this->ext_ownership_;
  }

  void System::
  ext_ownership (const ext_ownership_type& x)
  {
    this->ext_ownership_.set (x);
  }

  void System::
  ext_ownership (const ext_ownership_optional& x)
  {
    this->ext_ownership_ = x;
  }

  void System::
  ext_ownership (::std::auto_ptr< ext_ownership_type > x)
  {
    this->ext_ownership_.set (x);
  }


  // Node
  // 

  const Node::DomainData_sequence& Node::
  DomainData () const
  {
    return this->DomainData_;
  }

  Node::DomainData_sequence& Node::
  DomainData ()
  {
    return this->DomainData_;
  }

  void Node::
  DomainData (const DomainData_sequence& s)
  {
    this->DomainData_ = s;
  }

  const Node::Address_sequence& Node::
  Address () const
  {
    return this->Address_;
  }

  Node::Address_sequence& Node::
  Address ()
  {
    return this->Address_;
  }

  void Node::
  Address (const Address_sequence& s)
  {
    this->Address_ = s;
  }

  const Node::PostalAddress_optional& Node::
  PostalAddress () const
  {
    return this->PostalAddress_;
  }

  Node::PostalAddress_optional& Node::
  PostalAddress ()
  {
    return this->PostalAddress_;
  }

  void Node::
  PostalAddress (const PostalAddress_type& x)
  {
    this->PostalAddress_.set (x);
  }

  void Node::
  PostalAddress (const PostalAddress_optional& x)
  {
    this->PostalAddress_ = x;
  }

  void Node::
  PostalAddress (::std::auto_ptr< PostalAddress_type > x)
  {
    this->PostalAddress_.set (x);
  }

  const Node::Location_sequence& Node::
  Location () const
  {
    return this->Location_;
  }

  Node::Location_sequence& Node::
  Location ()
  {
    return this->Location_;
  }

  void Node::
  Location (const Location_sequence& s)
  {
    this->Location_ = s;
  }

  const Node::NodeRole_sequence& Node::
  NodeRole () const
  {
    return this->NodeRole_;
  }

  Node::NodeRole_sequence& Node::
  NodeRole ()
  {
    return this->NodeRole_;
  }

  void Node::
  NodeRole (const NodeRole_sequence& s)
  {
    this->NodeRole_ = s;
  }

  const Node::Counter_sequence& Node::
  Counter () const
  {
    return this->Counter_;
  }

  Node::Counter_sequence& Node::
  Counter ()
  {
    return this->Counter_;
  }

  void Node::
  Counter (const Counter_sequence& s)
  {
    this->Counter_ = s;
  }


  // Address
  // 

  const Address::category_type& Address::
  category () const
  {
    return this->category_.get ();
  }

  Address::category_type& Address::
  category ()
  {
    return this->category_.get ();
  }

  void Address::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void Address::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const Address::category_type& Address::
  category_default_value ()
  {
    return category_default_value_;
  }

  const Address::ext_category_optional& Address::
  ext_category () const
  {
    return this->ext_category_;
  }

  Address::ext_category_optional& Address::
  ext_category ()
  {
    return this->ext_category_;
  }

  void Address::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void Address::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void Address::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }

  const Address::vlan_name_optional& Address::
  vlan_name () const
  {
    return this->vlan_name_;
  }

  Address::vlan_name_optional& Address::
  vlan_name ()
  {
    return this->vlan_name_;
  }

  void Address::
  vlan_name (const vlan_name_type& x)
  {
    this->vlan_name_.set (x);
  }

  void Address::
  vlan_name (const vlan_name_optional& x)
  {
    this->vlan_name_ = x;
  }

  void Address::
  vlan_name (::std::auto_ptr< vlan_name_type > x)
  {
    this->vlan_name_.set (x);
  }

  const Address::vlan_num_optional& Address::
  vlan_num () const
  {
    return this->vlan_num_;
  }

  Address::vlan_num_optional& Address::
  vlan_num ()
  {
    return this->vlan_num_;
  }

  void Address::
  vlan_num (const vlan_num_type& x)
  {
    this->vlan_num_.set (x);
  }

  void Address::
  vlan_num (const vlan_num_optional& x)
  {
    this->vlan_num_ = x;
  }

  const Address::observable_id_optional& Address::
  observable_id () const
  {
    return this->observable_id_;
  }

  Address::observable_id_optional& Address::
  observable_id ()
  {
    return this->observable_id_;
  }

  void Address::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void Address::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void Address::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // NodeRole
  // 

  const NodeRole::category_type& NodeRole::
  category () const
  {
    return this->category_.get ();
  }

  NodeRole::category_type& NodeRole::
  category ()
  {
    return this->category_.get ();
  }

  void NodeRole::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void NodeRole::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const NodeRole::ext_category_optional& NodeRole::
  ext_category () const
  {
    return this->ext_category_;
  }

  NodeRole::ext_category_optional& NodeRole::
  ext_category ()
  {
    return this->ext_category_;
  }

  void NodeRole::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void NodeRole::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void NodeRole::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }


  // Service
  // 

  const Service::ServiceName_optional& Service::
  ServiceName () const
  {
    return this->ServiceName_;
  }

  Service::ServiceName_optional& Service::
  ServiceName ()
  {
    return this->ServiceName_;
  }

  void Service::
  ServiceName (const ServiceName_type& x)
  {
    this->ServiceName_.set (x);
  }

  void Service::
  ServiceName (const ServiceName_optional& x)
  {
    this->ServiceName_ = x;
  }

  void Service::
  ServiceName (::std::auto_ptr< ServiceName_type > x)
  {
    this->ServiceName_.set (x);
  }

  const Service::Port_optional& Service::
  Port () const
  {
    return this->Port_;
  }

  Service::Port_optional& Service::
  Port ()
  {
    return this->Port_;
  }

  void Service::
  Port (const Port_type& x)
  {
    this->Port_.set (x);
  }

  void Service::
  Port (const Port_optional& x)
  {
    this->Port_ = x;
  }

  const Service::Portlist_optional& Service::
  Portlist () const
  {
    return this->Portlist_;
  }

  Service::Portlist_optional& Service::
  Portlist ()
  {
    return this->Portlist_;
  }

  void Service::
  Portlist (const Portlist_type& x)
  {
    this->Portlist_.set (x);
  }

  void Service::
  Portlist (const Portlist_optional& x)
  {
    this->Portlist_ = x;
  }

  void Service::
  Portlist (::std::auto_ptr< Portlist_type > x)
  {
    this->Portlist_.set (x);
  }

  const Service::ProtoType_optional& Service::
  ProtoType () const
  {
    return this->ProtoType_;
  }

  Service::ProtoType_optional& Service::
  ProtoType ()
  {
    return this->ProtoType_;
  }

  void Service::
  ProtoType (const ProtoType_type& x)
  {
    this->ProtoType_.set (x);
  }

  void Service::
  ProtoType (const ProtoType_optional& x)
  {
    this->ProtoType_ = x;
  }

  const Service::ProtoCode_optional& Service::
  ProtoCode () const
  {
    return this->ProtoCode_;
  }

  Service::ProtoCode_optional& Service::
  ProtoCode ()
  {
    return this->ProtoCode_;
  }

  void Service::
  ProtoCode (const ProtoCode_type& x)
  {
    this->ProtoCode_.set (x);
  }

  void Service::
  ProtoCode (const ProtoCode_optional& x)
  {
    this->ProtoCode_ = x;
  }

  const Service::ProtoField_optional& Service::
  ProtoField () const
  {
    return this->ProtoField_;
  }

  Service::ProtoField_optional& Service::
  ProtoField ()
  {
    return this->ProtoField_;
  }

  void Service::
  ProtoField (const ProtoField_type& x)
  {
    this->ProtoField_.set (x);
  }

  void Service::
  ProtoField (const ProtoField_optional& x)
  {
    this->ProtoField_ = x;
  }

  const Service::ApplicationHeader_sequence& Service::
  ApplicationHeader () const
  {
    return this->ApplicationHeader_;
  }

  Service::ApplicationHeader_sequence& Service::
  ApplicationHeader ()
  {
    return this->ApplicationHeader_;
  }

  void Service::
  ApplicationHeader (const ApplicationHeader_sequence& s)
  {
    this->ApplicationHeader_ = s;
  }

  const Service::EmailData_optional& Service::
  EmailData () const
  {
    return this->EmailData_;
  }

  Service::EmailData_optional& Service::
  EmailData ()
  {
    return this->EmailData_;
  }

  void Service::
  EmailData (const EmailData_type& x)
  {
    this->EmailData_.set (x);
  }

  void Service::
  EmailData (const EmailData_optional& x)
  {
    this->EmailData_ = x;
  }

  void Service::
  EmailData (::std::auto_ptr< EmailData_type > x)
  {
    this->EmailData_.set (x);
  }

  const Service::Application_optional& Service::
  Application () const
  {
    return this->Application_;
  }

  Service::Application_optional& Service::
  Application ()
  {
    return this->Application_;
  }

  void Service::
  Application (const Application_type& x)
  {
    this->Application_.set (x);
  }

  void Service::
  Application (const Application_optional& x)
  {
    this->Application_ = x;
  }

  void Service::
  Application (::std::auto_ptr< Application_type > x)
  {
    this->Application_.set (x);
  }

  const Service::ip_protocol_type& Service::
  ip_protocol () const
  {
    return this->ip_protocol_.get ();
  }

  Service::ip_protocol_type& Service::
  ip_protocol ()
  {
    return this->ip_protocol_.get ();
  }

  void Service::
  ip_protocol (const ip_protocol_type& x)
  {
    this->ip_protocol_.set (x);
  }

  const Service::observable_id_optional& Service::
  observable_id () const
  {
    return this->observable_id_;
  }

  Service::observable_id_optional& Service::
  observable_id ()
  {
    return this->observable_id_;
  }

  void Service::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void Service::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void Service::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // ServiceName
  // 

  const ServiceName::IANAService_type& ServiceName::
  IANAService () const
  {
    return this->IANAService_.get ();
  }

  ServiceName::IANAService_type& ServiceName::
  IANAService ()
  {
    return this->IANAService_.get ();
  }

  void ServiceName::
  IANAService (const IANAService_type& x)
  {
    this->IANAService_.set (x);
  }

  void ServiceName::
  IANAService (::std::auto_ptr< IANAService_type > x)
  {
    this->IANAService_.set (x);
  }

  const ServiceName::URL_sequence& ServiceName::
  URL () const
  {
    return this->URL_;
  }

  ServiceName::URL_sequence& ServiceName::
  URL ()
  {
    return this->URL_;
  }

  void ServiceName::
  URL (const URL_sequence& s)
  {
    this->URL_ = s;
  }

  const ServiceName::Description_sequence& ServiceName::
  Description () const
  {
    return this->Description_;
  }

  ServiceName::Description_sequence& ServiceName::
  Description ()
  {
    return this->Description_;
  }

  void ServiceName::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }


  // Counter
  // 

  const Counter::type_type& Counter::
  type () const
  {
    return this->type_.get ();
  }

  Counter::type_type& Counter::
  type ()
  {
    return this->type_.get ();
  }

  void Counter::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Counter::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const Counter::unit_type& Counter::
  unit () const
  {
    return this->unit_.get ();
  }

  Counter::unit_type& Counter::
  unit ()
  {
    return this->unit_.get ();
  }

  void Counter::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void Counter::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const Counter::ext_type_optional& Counter::
  ext_type () const
  {
    return this->ext_type_;
  }

  Counter::ext_type_optional& Counter::
  ext_type ()
  {
    return this->ext_type_;
  }

  void Counter::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void Counter::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void Counter::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const Counter::meaning_optional& Counter::
  meaning () const
  {
    return this->meaning_;
  }

  Counter::meaning_optional& Counter::
  meaning ()
  {
    return this->meaning_;
  }

  void Counter::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void Counter::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void Counter::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }

  const Counter::duration_optional& Counter::
  duration () const
  {
    return this->duration_;
  }

  Counter::duration_optional& Counter::
  duration ()
  {
    return this->duration_;
  }

  void Counter::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void Counter::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void Counter::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }

  const Counter::ext_duration_optional& Counter::
  ext_duration () const
  {
    return this->ext_duration_;
  }

  Counter::ext_duration_optional& Counter::
  ext_duration ()
  {
    return this->ext_duration_;
  }

  void Counter::
  ext_duration (const ext_duration_type& x)
  {
    this->ext_duration_.set (x);
  }

  void Counter::
  ext_duration (const ext_duration_optional& x)
  {
    this->ext_duration_ = x;
  }

  void Counter::
  ext_duration (::std::auto_ptr< ext_duration_type > x)
  {
    this->ext_duration_.set (x);
  }


  // EmailData
  // 

  const EmailData::EmailFrom_optional& EmailData::
  EmailFrom () const
  {
    return this->EmailFrom_;
  }

  EmailData::EmailFrom_optional& EmailData::
  EmailFrom ()
  {
    return this->EmailFrom_;
  }

  void EmailData::
  EmailFrom (const EmailFrom_type& x)
  {
    this->EmailFrom_.set (x);
  }

  void EmailData::
  EmailFrom (const EmailFrom_optional& x)
  {
    this->EmailFrom_ = x;
  }

  void EmailData::
  EmailFrom (::std::auto_ptr< EmailFrom_type > x)
  {
    this->EmailFrom_.set (x);
  }

  const EmailData::EmailSubject_optional& EmailData::
  EmailSubject () const
  {
    return this->EmailSubject_;
  }

  EmailData::EmailSubject_optional& EmailData::
  EmailSubject ()
  {
    return this->EmailSubject_;
  }

  void EmailData::
  EmailSubject (const EmailSubject_type& x)
  {
    this->EmailSubject_.set (x);
  }

  void EmailData::
  EmailSubject (const EmailSubject_optional& x)
  {
    this->EmailSubject_ = x;
  }

  void EmailData::
  EmailSubject (::std::auto_ptr< EmailSubject_type > x)
  {
    this->EmailSubject_.set (x);
  }

  const EmailData::EmailX_Mailer_optional& EmailData::
  EmailX_Mailer () const
  {
    return this->EmailX_Mailer_;
  }

  EmailData::EmailX_Mailer_optional& EmailData::
  EmailX_Mailer ()
  {
    return this->EmailX_Mailer_;
  }

  void EmailData::
  EmailX_Mailer (const EmailX_Mailer_type& x)
  {
    this->EmailX_Mailer_.set (x);
  }

  void EmailData::
  EmailX_Mailer (const EmailX_Mailer_optional& x)
  {
    this->EmailX_Mailer_ = x;
  }

  void EmailData::
  EmailX_Mailer (::std::auto_ptr< EmailX_Mailer_type > x)
  {
    this->EmailX_Mailer_.set (x);
  }

  const EmailData::EmailHeaderField_optional& EmailData::
  EmailHeaderField () const
  {
    return this->EmailHeaderField_;
  }

  EmailData::EmailHeaderField_optional& EmailData::
  EmailHeaderField ()
  {
    return this->EmailHeaderField_;
  }

  void EmailData::
  EmailHeaderField (const EmailHeaderField_type& x)
  {
    this->EmailHeaderField_.set (x);
  }

  void EmailData::
  EmailHeaderField (const EmailHeaderField_optional& x)
  {
    this->EmailHeaderField_ = x;
  }

  void EmailData::
  EmailHeaderField (::std::auto_ptr< EmailHeaderField_type > x)
  {
    this->EmailHeaderField_.set (x);
  }

  const EmailData::HashData_optional& EmailData::
  HashData () const
  {
    return this->HashData_;
  }

  EmailData::HashData_optional& EmailData::
  HashData ()
  {
    return this->HashData_;
  }

  void EmailData::
  HashData (const HashData_type& x)
  {
    this->HashData_.set (x);
  }

  void EmailData::
  HashData (const HashData_optional& x)
  {
    this->HashData_ = x;
  }

  void EmailData::
  HashData (::std::auto_ptr< HashData_type > x)
  {
    this->HashData_.set (x);
  }

  const EmailData::SignatureData_optional& EmailData::
  SignatureData () const
  {
    return this->SignatureData_;
  }

  EmailData::SignatureData_optional& EmailData::
  SignatureData ()
  {
    return this->SignatureData_;
  }

  void EmailData::
  SignatureData (const SignatureData_type& x)
  {
    this->SignatureData_.set (x);
  }

  void EmailData::
  SignatureData (const SignatureData_optional& x)
  {
    this->SignatureData_ = x;
  }

  void EmailData::
  SignatureData (::std::auto_ptr< SignatureData_type > x)
  {
    this->SignatureData_.set (x);
  }

  const EmailData::observable_id_optional& EmailData::
  observable_id () const
  {
    return this->observable_id_;
  }

  EmailData::observable_id_optional& EmailData::
  observable_id ()
  {
    return this->observable_id_;
  }

  void EmailData::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void EmailData::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void EmailData::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // DomainData
  // 

  const DomainData::Name_type& DomainData::
  Name () const
  {
    return this->Name_.get ();
  }

  DomainData::Name_type& DomainData::
  Name ()
  {
    return this->Name_.get ();
  }

  void DomainData::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void DomainData::
  Name (::std::auto_ptr< Name_type > x)
  {
    this->Name_.set (x);
  }

  const DomainData::DateDomainWasChecked_optional& DomainData::
  DateDomainWasChecked () const
  {
    return this->DateDomainWasChecked_;
  }

  DomainData::DateDomainWasChecked_optional& DomainData::
  DateDomainWasChecked ()
  {
    return this->DateDomainWasChecked_;
  }

  void DomainData::
  DateDomainWasChecked (const DateDomainWasChecked_type& x)
  {
    this->DateDomainWasChecked_.set (x);
  }

  void DomainData::
  DateDomainWasChecked (const DateDomainWasChecked_optional& x)
  {
    this->DateDomainWasChecked_ = x;
  }

  void DomainData::
  DateDomainWasChecked (::std::auto_ptr< DateDomainWasChecked_type > x)
  {
    this->DateDomainWasChecked_.set (x);
  }

  const DomainData::RegistrationDate_optional& DomainData::
  RegistrationDate () const
  {
    return this->RegistrationDate_;
  }

  DomainData::RegistrationDate_optional& DomainData::
  RegistrationDate ()
  {
    return this->RegistrationDate_;
  }

  void DomainData::
  RegistrationDate (const RegistrationDate_type& x)
  {
    this->RegistrationDate_.set (x);
  }

  void DomainData::
  RegistrationDate (const RegistrationDate_optional& x)
  {
    this->RegistrationDate_ = x;
  }

  void DomainData::
  RegistrationDate (::std::auto_ptr< RegistrationDate_type > x)
  {
    this->RegistrationDate_.set (x);
  }

  const DomainData::ExpirationDate_optional& DomainData::
  ExpirationDate () const
  {
    return this->ExpirationDate_;
  }

  DomainData::ExpirationDate_optional& DomainData::
  ExpirationDate ()
  {
    return this->ExpirationDate_;
  }

  void DomainData::
  ExpirationDate (const ExpirationDate_type& x)
  {
    this->ExpirationDate_.set (x);
  }

  void DomainData::
  ExpirationDate (const ExpirationDate_optional& x)
  {
    this->ExpirationDate_ = x;
  }

  void DomainData::
  ExpirationDate (::std::auto_ptr< ExpirationDate_type > x)
  {
    this->ExpirationDate_.set (x);
  }

  const DomainData::RelatedDNS_sequence& DomainData::
  RelatedDNS () const
  {
    return this->RelatedDNS_;
  }

  DomainData::RelatedDNS_sequence& DomainData::
  RelatedDNS ()
  {
    return this->RelatedDNS_;
  }

  void DomainData::
  RelatedDNS (const RelatedDNS_sequence& s)
  {
    this->RelatedDNS_ = s;
  }

  const DomainData::Nameservers_sequence& DomainData::
  Nameservers () const
  {
    return this->Nameservers_;
  }

  DomainData::Nameservers_sequence& DomainData::
  Nameservers ()
  {
    return this->Nameservers_;
  }

  void DomainData::
  Nameservers (const Nameservers_sequence& s)
  {
    this->Nameservers_ = s;
  }

  const DomainData::DomainContacts_optional& DomainData::
  DomainContacts () const
  {
    return this->DomainContacts_;
  }

  DomainData::DomainContacts_optional& DomainData::
  DomainContacts ()
  {
    return this->DomainContacts_;
  }

  void DomainData::
  DomainContacts (const DomainContacts_type& x)
  {
    this->DomainContacts_.set (x);
  }

  void DomainData::
  DomainContacts (const DomainContacts_optional& x)
  {
    this->DomainContacts_ = x;
  }

  void DomainData::
  DomainContacts (::std::auto_ptr< DomainContacts_type > x)
  {
    this->DomainContacts_.set (x);
  }

  const DomainData::system_status_optional& DomainData::
  system_status () const
  {
    return this->system_status_;
  }

  DomainData::system_status_optional& DomainData::
  system_status ()
  {
    return this->system_status_;
  }

  void DomainData::
  system_status (const system_status_type& x)
  {
    this->system_status_.set (x);
  }

  void DomainData::
  system_status (const system_status_optional& x)
  {
    this->system_status_ = x;
  }

  void DomainData::
  system_status (::std::auto_ptr< system_status_type > x)
  {
    this->system_status_.set (x);
  }

  const DomainData::ext_system_status_optional& DomainData::
  ext_system_status () const
  {
    return this->ext_system_status_;
  }

  DomainData::ext_system_status_optional& DomainData::
  ext_system_status ()
  {
    return this->ext_system_status_;
  }

  void DomainData::
  ext_system_status (const ext_system_status_type& x)
  {
    this->ext_system_status_.set (x);
  }

  void DomainData::
  ext_system_status (const ext_system_status_optional& x)
  {
    this->ext_system_status_ = x;
  }

  void DomainData::
  ext_system_status (::std::auto_ptr< ext_system_status_type > x)
  {
    this->ext_system_status_.set (x);
  }

  const DomainData::domain_status_optional& DomainData::
  domain_status () const
  {
    return this->domain_status_;
  }

  DomainData::domain_status_optional& DomainData::
  domain_status ()
  {
    return this->domain_status_;
  }

  void DomainData::
  domain_status (const domain_status_type& x)
  {
    this->domain_status_.set (x);
  }

  void DomainData::
  domain_status (const domain_status_optional& x)
  {
    this->domain_status_ = x;
  }

  void DomainData::
  domain_status (::std::auto_ptr< domain_status_type > x)
  {
    this->domain_status_.set (x);
  }

  const DomainData::ext_domain_status_optional& DomainData::
  ext_domain_status () const
  {
    return this->ext_domain_status_;
  }

  DomainData::ext_domain_status_optional& DomainData::
  ext_domain_status ()
  {
    return this->ext_domain_status_;
  }

  void DomainData::
  ext_domain_status (const ext_domain_status_type& x)
  {
    this->ext_domain_status_.set (x);
  }

  void DomainData::
  ext_domain_status (const ext_domain_status_optional& x)
  {
    this->ext_domain_status_ = x;
  }

  void DomainData::
  ext_domain_status (::std::auto_ptr< ext_domain_status_type > x)
  {
    this->ext_domain_status_.set (x);
  }

  const DomainData::observable_id_optional& DomainData::
  observable_id () const
  {
    return this->observable_id_;
  }

  DomainData::observable_id_optional& DomainData::
  observable_id ()
  {
    return this->observable_id_;
  }

  void DomainData::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void DomainData::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void DomainData::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // RelatedDNS
  // 

  const RelatedDNS::record_type_optional& RelatedDNS::
  record_type () const
  {
    return this->record_type_;
  }

  RelatedDNS::record_type_optional& RelatedDNS::
  record_type ()
  {
    return this->record_type_;
  }

  void RelatedDNS::
  record_type (const record_type_type& x)
  {
    this->record_type_.set (x);
  }

  void RelatedDNS::
  record_type (const record_type_optional& x)
  {
    this->record_type_ = x;
  }

  void RelatedDNS::
  record_type (::std::auto_ptr< record_type_type > x)
  {
    this->record_type_.set (x);
  }


  // Nameservers
  // 

  const Nameservers::Server_type& Nameservers::
  Server () const
  {
    return this->Server_.get ();
  }

  Nameservers::Server_type& Nameservers::
  Server ()
  {
    return this->Server_.get ();
  }

  void Nameservers::
  Server (const Server_type& x)
  {
    this->Server_.set (x);
  }

  void Nameservers::
  Server (::std::auto_ptr< Server_type > x)
  {
    this->Server_.set (x);
  }

  const Nameservers::Address_sequence& Nameservers::
  Address () const
  {
    return this->Address_;
  }

  Nameservers::Address_sequence& Nameservers::
  Address ()
  {
    return this->Address_;
  }

  void Nameservers::
  Address (const Address_sequence& s)
  {
    this->Address_ = s;
  }


  // DomainContacts
  // 

  const DomainContacts::SameDomainContact_optional& DomainContacts::
  SameDomainContact () const
  {
    return this->SameDomainContact_;
  }

  DomainContacts::SameDomainContact_optional& DomainContacts::
  SameDomainContact ()
  {
    return this->SameDomainContact_;
  }

  void DomainContacts::
  SameDomainContact (const SameDomainContact_type& x)
  {
    this->SameDomainContact_.set (x);
  }

  void DomainContacts::
  SameDomainContact (const SameDomainContact_optional& x)
  {
    this->SameDomainContact_ = x;
  }

  void DomainContacts::
  SameDomainContact (::std::auto_ptr< SameDomainContact_type > x)
  {
    this->SameDomainContact_.set (x);
  }

  const DomainContacts::Contact_sequence& DomainContacts::
  Contact () const
  {
    return this->Contact_;
  }

  DomainContacts::Contact_sequence& DomainContacts::
  Contact ()
  {
    return this->Contact_;
  }

  void DomainContacts::
  Contact (const Contact_sequence& s)
  {
    this->Contact_ = s;
  }


  // Record
  // 

  const Record::RecordData_sequence& Record::
  RecordData () const
  {
    return this->RecordData_;
  }

  Record::RecordData_sequence& Record::
  RecordData ()
  {
    return this->RecordData_;
  }

  void Record::
  RecordData (const RecordData_sequence& s)
  {
    this->RecordData_ = s;
  }

  const Record::restriction_optional& Record::
  restriction () const
  {
    return this->restriction_;
  }

  Record::restriction_optional& Record::
  restriction ()
  {
    return this->restriction_;
  }

  void Record::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Record::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Record::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Record::ext_restriction_optional& Record::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Record::ext_restriction_optional& Record::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Record::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Record::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Record::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // RecordData
  // 

  const RecordData::DateTime_optional& RecordData::
  DateTime () const
  {
    return this->DateTime_;
  }

  RecordData::DateTime_optional& RecordData::
  DateTime ()
  {
    return this->DateTime_;
  }

  void RecordData::
  DateTime (const DateTime_type& x)
  {
    this->DateTime_.set (x);
  }

  void RecordData::
  DateTime (const DateTime_optional& x)
  {
    this->DateTime_ = x;
  }

  void RecordData::
  DateTime (::std::auto_ptr< DateTime_type > x)
  {
    this->DateTime_.set (x);
  }

  const RecordData::Description_sequence& RecordData::
  Description () const
  {
    return this->Description_;
  }

  RecordData::Description_sequence& RecordData::
  Description ()
  {
    return this->Description_;
  }

  void RecordData::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const RecordData::Application_optional& RecordData::
  Application () const
  {
    return this->Application_;
  }

  RecordData::Application_optional& RecordData::
  Application ()
  {
    return this->Application_;
  }

  void RecordData::
  Application (const Application_type& x)
  {
    this->Application_.set (x);
  }

  void RecordData::
  Application (const Application_optional& x)
  {
    this->Application_ = x;
  }

  void RecordData::
  Application (::std::auto_ptr< Application_type > x)
  {
    this->Application_.set (x);
  }

  const RecordData::RecordPattern_sequence& RecordData::
  RecordPattern () const
  {
    return this->RecordPattern_;
  }

  RecordData::RecordPattern_sequence& RecordData::
  RecordPattern ()
  {
    return this->RecordPattern_;
  }

  void RecordData::
  RecordPattern (const RecordPattern_sequence& s)
  {
    this->RecordPattern_ = s;
  }

  const RecordData::RecordItem_sequence& RecordData::
  RecordItem () const
  {
    return this->RecordItem_;
  }

  RecordData::RecordItem_sequence& RecordData::
  RecordItem ()
  {
    return this->RecordItem_;
  }

  void RecordData::
  RecordItem (const RecordItem_sequence& s)
  {
    this->RecordItem_ = s;
  }

  const RecordData::FileData_sequence& RecordData::
  FileData () const
  {
    return this->FileData_;
  }

  RecordData::FileData_sequence& RecordData::
  FileData ()
  {
    return this->FileData_;
  }

  void RecordData::
  FileData (const FileData_sequence& s)
  {
    this->FileData_ = s;
  }

  const RecordData::WindowsRegistryKeysModified_sequence& RecordData::
  WindowsRegistryKeysModified () const
  {
    return this->WindowsRegistryKeysModified_;
  }

  RecordData::WindowsRegistryKeysModified_sequence& RecordData::
  WindowsRegistryKeysModified ()
  {
    return this->WindowsRegistryKeysModified_;
  }

  void RecordData::
  WindowsRegistryKeysModified (const WindowsRegistryKeysModified_sequence& s)
  {
    this->WindowsRegistryKeysModified_ = s;
  }

  const RecordData::CertificateData_sequence& RecordData::
  CertificateData () const
  {
    return this->CertificateData_;
  }

  RecordData::CertificateData_sequence& RecordData::
  CertificateData ()
  {
    return this->CertificateData_;
  }

  void RecordData::
  CertificateData (const CertificateData_sequence& s)
  {
    this->CertificateData_ = s;
  }

  const RecordData::AdditionalData_sequence& RecordData::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  RecordData::AdditionalData_sequence& RecordData::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void RecordData::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const RecordData::restriction_optional& RecordData::
  restriction () const
  {
    return this->restriction_;
  }

  RecordData::restriction_optional& RecordData::
  restriction ()
  {
    return this->restriction_;
  }

  void RecordData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void RecordData::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void RecordData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const RecordData::ext_restriction_optional& RecordData::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  RecordData::ext_restriction_optional& RecordData::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void RecordData::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void RecordData::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void RecordData::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }

  const RecordData::observable_id_optional& RecordData::
  observable_id () const
  {
    return this->observable_id_;
  }

  RecordData::observable_id_optional& RecordData::
  observable_id ()
  {
    return this->observable_id_;
  }

  void RecordData::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void RecordData::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void RecordData::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // RecordPattern
  // 

  const RecordPattern::type_type& RecordPattern::
  type () const
  {
    return this->type_.get ();
  }

  RecordPattern::type_type& RecordPattern::
  type ()
  {
    return this->type_.get ();
  }

  void RecordPattern::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void RecordPattern::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const RecordPattern::ext_type_optional& RecordPattern::
  ext_type () const
  {
    return this->ext_type_;
  }

  RecordPattern::ext_type_optional& RecordPattern::
  ext_type ()
  {
    return this->ext_type_;
  }

  void RecordPattern::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void RecordPattern::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void RecordPattern::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const RecordPattern::offset_optional& RecordPattern::
  offset () const
  {
    return this->offset_;
  }

  RecordPattern::offset_optional& RecordPattern::
  offset ()
  {
    return this->offset_;
  }

  void RecordPattern::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void RecordPattern::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  const RecordPattern::offsetunit_type& RecordPattern::
  offsetunit () const
  {
    return this->offsetunit_.get ();
  }

  RecordPattern::offsetunit_type& RecordPattern::
  offsetunit ()
  {
    return this->offsetunit_.get ();
  }

  void RecordPattern::
  offsetunit (const offsetunit_type& x)
  {
    this->offsetunit_.set (x);
  }

  void RecordPattern::
  offsetunit (::std::auto_ptr< offsetunit_type > x)
  {
    this->offsetunit_.set (x);
  }

  const RecordPattern::offsetunit_type& RecordPattern::
  offsetunit_default_value ()
  {
    return offsetunit_default_value_;
  }

  const RecordPattern::ext_offsetunit_optional& RecordPattern::
  ext_offsetunit () const
  {
    return this->ext_offsetunit_;
  }

  RecordPattern::ext_offsetunit_optional& RecordPattern::
  ext_offsetunit ()
  {
    return this->ext_offsetunit_;
  }

  void RecordPattern::
  ext_offsetunit (const ext_offsetunit_type& x)
  {
    this->ext_offsetunit_.set (x);
  }

  void RecordPattern::
  ext_offsetunit (const ext_offsetunit_optional& x)
  {
    this->ext_offsetunit_ = x;
  }

  void RecordPattern::
  ext_offsetunit (::std::auto_ptr< ext_offsetunit_type > x)
  {
    this->ext_offsetunit_.set (x);
  }

  const RecordPattern::instance_optional& RecordPattern::
  instance () const
  {
    return this->instance_;
  }

  RecordPattern::instance_optional& RecordPattern::
  instance ()
  {
    return this->instance_;
  }

  void RecordPattern::
  instance (const instance_type& x)
  {
    this->instance_.set (x);
  }

  void RecordPattern::
  instance (const instance_optional& x)
  {
    this->instance_ = x;
  }


  // WindowsRegistryKeysModified
  // 

  const WindowsRegistryKeysModified::Key_sequence& WindowsRegistryKeysModified::
  Key () const
  {
    return this->Key_;
  }

  WindowsRegistryKeysModified::Key_sequence& WindowsRegistryKeysModified::
  Key ()
  {
    return this->Key_;
  }

  void WindowsRegistryKeysModified::
  Key (const Key_sequence& s)
  {
    this->Key_ = s;
  }

  const WindowsRegistryKeysModified::observable_id_optional& WindowsRegistryKeysModified::
  observable_id () const
  {
    return this->observable_id_;
  }

  WindowsRegistryKeysModified::observable_id_optional& WindowsRegistryKeysModified::
  observable_id ()
  {
    return this->observable_id_;
  }

  void WindowsRegistryKeysModified::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void WindowsRegistryKeysModified::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void WindowsRegistryKeysModified::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // Key
  // 

  const Key::KeyName_type& Key::
  KeyName () const
  {
    return this->KeyName_.get ();
  }

  Key::KeyName_type& Key::
  KeyName ()
  {
    return this->KeyName_.get ();
  }

  void Key::
  KeyName (const KeyName_type& x)
  {
    this->KeyName_.set (x);
  }

  void Key::
  KeyName (::std::auto_ptr< KeyName_type > x)
  {
    this->KeyName_.set (x);
  }

  const Key::Value_optional& Key::
  Value () const
  {
    return this->Value_;
  }

  Key::Value_optional& Key::
  Value ()
  {
    return this->Value_;
  }

  void Key::
  Value (const Value_type& x)
  {
    this->Value_.set (x);
  }

  void Key::
  Value (const Value_optional& x)
  {
    this->Value_ = x;
  }

  void Key::
  Value (::std::auto_ptr< Value_type > x)
  {
    this->Value_.set (x);
  }

  const Key::registryaction_optional& Key::
  registryaction () const
  {
    return this->registryaction_;
  }

  Key::registryaction_optional& Key::
  registryaction ()
  {
    return this->registryaction_;
  }

  void Key::
  registryaction (const registryaction_type& x)
  {
    this->registryaction_.set (x);
  }

  void Key::
  registryaction (const registryaction_optional& x)
  {
    this->registryaction_ = x;
  }

  void Key::
  registryaction (::std::auto_ptr< registryaction_type > x)
  {
    this->registryaction_.set (x);
  }

  const Key::ext_registryaction_optional& Key::
  ext_registryaction () const
  {
    return this->ext_registryaction_;
  }

  Key::ext_registryaction_optional& Key::
  ext_registryaction ()
  {
    return this->ext_registryaction_;
  }

  void Key::
  ext_registryaction (const ext_registryaction_type& x)
  {
    this->ext_registryaction_.set (x);
  }

  void Key::
  ext_registryaction (const ext_registryaction_optional& x)
  {
    this->ext_registryaction_ = x;
  }

  void Key::
  ext_registryaction (::std::auto_ptr< ext_registryaction_type > x)
  {
    this->ext_registryaction_.set (x);
  }


  // FileData
  // 

  const FileData::File_sequence& FileData::
  File () const
  {
    return this->File_;
  }

  FileData::File_sequence& FileData::
  File ()
  {
    return this->File_;
  }

  void FileData::
  File (const File_sequence& s)
  {
    this->File_ = s;
  }

  const FileData::observable_id_optional& FileData::
  observable_id () const
  {
    return this->observable_id_;
  }

  FileData::observable_id_optional& FileData::
  observable_id ()
  {
    return this->observable_id_;
  }

  void FileData::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void FileData::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void FileData::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }

  const FileData::restriction_optional& FileData::
  restriction () const
  {
    return this->restriction_;
  }

  FileData::restriction_optional& FileData::
  restriction ()
  {
    return this->restriction_;
  }

  void FileData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void FileData::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void FileData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const FileData::ext_restriction_optional& FileData::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  FileData::ext_restriction_optional& FileData::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void FileData::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void FileData::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void FileData::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // File
  // 

  const File::FileName_optional& File::
  FileName () const
  {
    return this->FileName_;
  }

  File::FileName_optional& File::
  FileName ()
  {
    return this->FileName_;
  }

  void File::
  FileName (const FileName_type& x)
  {
    this->FileName_.set (x);
  }

  void File::
  FileName (const FileName_optional& x)
  {
    this->FileName_ = x;
  }

  void File::
  FileName (::std::auto_ptr< FileName_type > x)
  {
    this->FileName_.set (x);
  }

  const File::FileSize_optional& File::
  FileSize () const
  {
    return this->FileSize_;
  }

  File::FileSize_optional& File::
  FileSize ()
  {
    return this->FileSize_;
  }

  void File::
  FileSize (const FileSize_type& x)
  {
    this->FileSize_.set (x);
  }

  void File::
  FileSize (const FileSize_optional& x)
  {
    this->FileSize_ = x;
  }

  const File::FileType_optional& File::
  FileType () const
  {
    return this->FileType_;
  }

  File::FileType_optional& File::
  FileType ()
  {
    return this->FileType_;
  }

  void File::
  FileType (const FileType_type& x)
  {
    this->FileType_.set (x);
  }

  void File::
  FileType (const FileType_optional& x)
  {
    this->FileType_ = x;
  }

  const File::URL_sequence& File::
  URL () const
  {
    return this->URL_;
  }

  File::URL_sequence& File::
  URL ()
  {
    return this->URL_;
  }

  void File::
  URL (const URL_sequence& s)
  {
    this->URL_ = s;
  }

  const File::HashData_optional& File::
  HashData () const
  {
    return this->HashData_;
  }

  File::HashData_optional& File::
  HashData ()
  {
    return this->HashData_;
  }

  void File::
  HashData (const HashData_type& x)
  {
    this->HashData_.set (x);
  }

  void File::
  HashData (const HashData_optional& x)
  {
    this->HashData_ = x;
  }

  void File::
  HashData (::std::auto_ptr< HashData_type > x)
  {
    this->HashData_.set (x);
  }

  const File::Signature_optional& File::
  Signature () const
  {
    return this->Signature_;
  }

  File::Signature_optional& File::
  Signature ()
  {
    return this->Signature_;
  }

  void File::
  Signature (const Signature_type& x)
  {
    this->Signature_.set (x);
  }

  void File::
  Signature (const Signature_optional& x)
  {
    this->Signature_ = x;
  }

  void File::
  Signature (::std::auto_ptr< Signature_type > x)
  {
    this->Signature_.set (x);
  }

  const File::Application_optional& File::
  Application () const
  {
    return this->Application_;
  }

  File::Application_optional& File::
  Application ()
  {
    return this->Application_;
  }

  void File::
  Application (const Application_type& x)
  {
    this->Application_.set (x);
  }

  void File::
  Application (const Application_optional& x)
  {
    this->Application_ = x;
  }

  void File::
  Application (::std::auto_ptr< Application_type > x)
  {
    this->Application_.set (x);
  }

  const File::FileProperties_sequence& File::
  FileProperties () const
  {
    return this->FileProperties_;
  }

  File::FileProperties_sequence& File::
  FileProperties ()
  {
    return this->FileProperties_;
  }

  void File::
  FileProperties (const FileProperties_sequence& s)
  {
    this->FileProperties_ = s;
  }

  const File::observable_id_optional& File::
  observable_id () const
  {
    return this->observable_id_;
  }

  File::observable_id_optional& File::
  observable_id ()
  {
    return this->observable_id_;
  }

  void File::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void File::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void File::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // HashData
  // 

  const HashData::HashTarget_optional& HashData::
  HashTarget () const
  {
    return this->HashTarget_;
  }

  HashData::HashTarget_optional& HashData::
  HashTarget ()
  {
    return this->HashTarget_;
  }

  void HashData::
  HashTarget (const HashTarget_type& x)
  {
    this->HashTarget_.set (x);
  }

  void HashData::
  HashTarget (const HashTarget_optional& x)
  {
    this->HashTarget_ = x;
  }

  void HashData::
  HashTarget (::std::auto_ptr< HashTarget_type > x)
  {
    this->HashTarget_.set (x);
  }

  const HashData::Hash_sequence& HashData::
  Hash () const
  {
    return this->Hash_;
  }

  HashData::Hash_sequence& HashData::
  Hash ()
  {
    return this->Hash_;
  }

  void HashData::
  Hash (const Hash_sequence& s)
  {
    this->Hash_ = s;
  }

  const HashData::FuzzyHash_sequence& HashData::
  FuzzyHash () const
  {
    return this->FuzzyHash_;
  }

  HashData::FuzzyHash_sequence& HashData::
  FuzzyHash ()
  {
    return this->FuzzyHash_;
  }

  void HashData::
  FuzzyHash (const FuzzyHash_sequence& s)
  {
    this->FuzzyHash_ = s;
  }

  const HashData::scope_type& HashData::
  scope () const
  {
    return this->scope_.get ();
  }

  HashData::scope_type& HashData::
  scope ()
  {
    return this->scope_.get ();
  }

  void HashData::
  scope (const scope_type& x)
  {
    this->scope_.set (x);
  }

  void HashData::
  scope (::std::auto_ptr< scope_type > x)
  {
    this->scope_.set (x);
  }

  const HashData::ext_scope_optional& HashData::
  ext_scope () const
  {
    return this->ext_scope_;
  }

  HashData::ext_scope_optional& HashData::
  ext_scope ()
  {
    return this->ext_scope_;
  }

  void HashData::
  ext_scope (const ext_scope_type& x)
  {
    this->ext_scope_.set (x);
  }

  void HashData::
  ext_scope (const ext_scope_optional& x)
  {
    this->ext_scope_ = x;
  }

  void HashData::
  ext_scope (::std::auto_ptr< ext_scope_type > x)
  {
    this->ext_scope_.set (x);
  }


  // Hash
  // 

  const Hash::DigestMethod_type& Hash::
  DigestMethod () const
  {
    return this->DigestMethod_.get ();
  }

  Hash::DigestMethod_type& Hash::
  DigestMethod ()
  {
    return this->DigestMethod_.get ();
  }

  void Hash::
  DigestMethod (const DigestMethod_type& x)
  {
    this->DigestMethod_.set (x);
  }

  void Hash::
  DigestMethod (::std::auto_ptr< DigestMethod_type > x)
  {
    this->DigestMethod_.set (x);
  }

  const Hash::DigestValue_type& Hash::
  DigestValue () const
  {
    return this->DigestValue_.get ();
  }

  Hash::DigestValue_type& Hash::
  DigestValue ()
  {
    return this->DigestValue_.get ();
  }

  void Hash::
  DigestValue (const DigestValue_type& x)
  {
    this->DigestValue_.set (x);
  }

  void Hash::
  DigestValue (::std::auto_ptr< DigestValue_type > x)
  {
    this->DigestValue_.set (x);
  }

  const Hash::CanonicalizationMethod_type& Hash::
  CanonicalizationMethod () const
  {
    return this->CanonicalizationMethod_.get ();
  }

  Hash::CanonicalizationMethod_type& Hash::
  CanonicalizationMethod ()
  {
    return this->CanonicalizationMethod_.get ();
  }

  void Hash::
  CanonicalizationMethod (const CanonicalizationMethod_type& x)
  {
    this->CanonicalizationMethod_.set (x);
  }

  void Hash::
  CanonicalizationMethod (::std::auto_ptr< CanonicalizationMethod_type > x)
  {
    this->CanonicalizationMethod_.set (x);
  }

  const Hash::Application_optional& Hash::
  Application () const
  {
    return this->Application_;
  }

  Hash::Application_optional& Hash::
  Application ()
  {
    return this->Application_;
  }

  void Hash::
  Application (const Application_type& x)
  {
    this->Application_.set (x);
  }

  void Hash::
  Application (const Application_optional& x)
  {
    this->Application_ = x;
  }

  void Hash::
  Application (::std::auto_ptr< Application_type > x)
  {
    this->Application_.set (x);
  }


  // FuzzyHash
  // 

  const FuzzyHash::AdditionalData_type& FuzzyHash::
  AdditionalData () const
  {
    return this->AdditionalData_.get ();
  }

  FuzzyHash::AdditionalData_type& FuzzyHash::
  AdditionalData ()
  {
    return this->AdditionalData_.get ();
  }

  void FuzzyHash::
  AdditionalData (const AdditionalData_type& x)
  {
    this->AdditionalData_.set (x);
  }

  void FuzzyHash::
  AdditionalData (::std::auto_ptr< AdditionalData_type > x)
  {
    this->AdditionalData_.set (x);
  }

  const FuzzyHash::Application_optional& FuzzyHash::
  Application () const
  {
    return this->Application_;
  }

  FuzzyHash::Application_optional& FuzzyHash::
  Application ()
  {
    return this->Application_;
  }

  void FuzzyHash::
  Application (const Application_type& x)
  {
    this->Application_.set (x);
  }

  void FuzzyHash::
  Application (const Application_optional& x)
  {
    this->Application_ = x;
  }

  void FuzzyHash::
  Application (::std::auto_ptr< Application_type > x)
  {
    this->Application_.set (x);
  }


  // SignatureData
  // 

  const SignatureData::Signature_sequence& SignatureData::
  Signature () const
  {
    return this->Signature_;
  }

  SignatureData::Signature_sequence& SignatureData::
  Signature ()
  {
    return this->Signature_;
  }

  void SignatureData::
  Signature (const Signature_sequence& s)
  {
    this->Signature_ = s;
  }


  // CertificateData
  // 

  const CertificateData::Certificate_sequence& CertificateData::
  Certificate () const
  {
    return this->Certificate_;
  }

  CertificateData::Certificate_sequence& CertificateData::
  Certificate ()
  {
    return this->Certificate_;
  }

  void CertificateData::
  Certificate (const Certificate_sequence& s)
  {
    this->Certificate_ = s;
  }

  const CertificateData::observable_id_optional& CertificateData::
  observable_id () const
  {
    return this->observable_id_;
  }

  CertificateData::observable_id_optional& CertificateData::
  observable_id ()
  {
    return this->observable_id_;
  }

  void CertificateData::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void CertificateData::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void CertificateData::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }

  const CertificateData::restriction_optional& CertificateData::
  restriction () const
  {
    return this->restriction_;
  }

  CertificateData::restriction_optional& CertificateData::
  restriction ()
  {
    return this->restriction_;
  }

  void CertificateData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void CertificateData::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void CertificateData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const CertificateData::ext_restriction_optional& CertificateData::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  CertificateData::ext_restriction_optional& CertificateData::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void CertificateData::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void CertificateData::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void CertificateData::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // Certificate
  // 

  const Certificate::X509Data_type& Certificate::
  X509Data () const
  {
    return this->X509Data_.get ();
  }

  Certificate::X509Data_type& Certificate::
  X509Data ()
  {
    return this->X509Data_.get ();
  }

  void Certificate::
  X509Data (const X509Data_type& x)
  {
    this->X509Data_.set (x);
  }

  void Certificate::
  X509Data (::std::auto_ptr< X509Data_type > x)
  {
    this->X509Data_.set (x);
  }

  const Certificate::observable_id_optional& Certificate::
  observable_id () const
  {
    return this->observable_id_;
  }

  Certificate::observable_id_optional& Certificate::
  observable_id ()
  {
    return this->observable_id_;
  }

  void Certificate::
  observable_id (const observable_id_type& x)
  {
    this->observable_id_.set (x);
  }

  void Certificate::
  observable_id (const observable_id_optional& x)
  {
    this->observable_id_ = x;
  }

  void Certificate::
  observable_id (::std::auto_ptr< observable_id_type > x)
  {
    this->observable_id_.set (x);
  }


  // SoftwareReference
  // 

  const SoftwareReference::spec_name_type& SoftwareReference::
  spec_name () const
  {
    return this->spec_name_.get ();
  }

  SoftwareReference::spec_name_type& SoftwareReference::
  spec_name ()
  {
    return this->spec_name_.get ();
  }

  void SoftwareReference::
  spec_name (const spec_name_type& x)
  {
    this->spec_name_.set (x);
  }

  void SoftwareReference::
  spec_name (::std::auto_ptr< spec_name_type > x)
  {
    this->spec_name_.set (x);
  }

  const SoftwareReference::ext_spec_name_optional& SoftwareReference::
  ext_spec_name () const
  {
    return this->ext_spec_name_;
  }

  SoftwareReference::ext_spec_name_optional& SoftwareReference::
  ext_spec_name ()
  {
    return this->ext_spec_name_;
  }

  void SoftwareReference::
  ext_spec_name (const ext_spec_name_type& x)
  {
    this->ext_spec_name_.set (x);
  }

  void SoftwareReference::
  ext_spec_name (const ext_spec_name_optional& x)
  {
    this->ext_spec_name_ = x;
  }

  void SoftwareReference::
  ext_spec_name (::std::auto_ptr< ext_spec_name_type > x)
  {
    this->ext_spec_name_.set (x);
  }

  const SoftwareReference::dtype_optional& SoftwareReference::
  dtype () const
  {
    return this->dtype_;
  }

  SoftwareReference::dtype_optional& SoftwareReference::
  dtype ()
  {
    return this->dtype_;
  }

  void SoftwareReference::
  dtype (const dtype_type& x)
  {
    this->dtype_.set (x);
  }

  void SoftwareReference::
  dtype (const dtype_optional& x)
  {
    this->dtype_ = x;
  }

  void SoftwareReference::
  dtype (::std::auto_ptr< dtype_type > x)
  {
    this->dtype_.set (x);
  }

  const SoftwareReference::ext_dtype_optional& SoftwareReference::
  ext_dtype () const
  {
    return this->ext_dtype_;
  }

  SoftwareReference::ext_dtype_optional& SoftwareReference::
  ext_dtype ()
  {
    return this->ext_dtype_;
  }

  void SoftwareReference::
  ext_dtype (const ext_dtype_type& x)
  {
    this->ext_dtype_.set (x);
  }

  void SoftwareReference::
  ext_dtype (const ext_dtype_optional& x)
  {
    this->ext_dtype_ = x;
  }

  void SoftwareReference::
  ext_dtype (::std::auto_ptr< ext_dtype_type > x)
  {
    this->ext_dtype_.set (x);
  }


  // IndicatorData
  // 

  const IndicatorData::Indicator_sequence& IndicatorData::
  Indicator () const
  {
    return this->Indicator_;
  }

  IndicatorData::Indicator_sequence& IndicatorData::
  Indicator ()
  {
    return this->Indicator_;
  }

  void IndicatorData::
  Indicator (const Indicator_sequence& s)
  {
    this->Indicator_ = s;
  }


  // Indicator
  // 

  const Indicator::IndicatorID_type& Indicator::
  IndicatorID () const
  {
    return this->IndicatorID_.get ();
  }

  Indicator::IndicatorID_type& Indicator::
  IndicatorID ()
  {
    return this->IndicatorID_.get ();
  }

  void Indicator::
  IndicatorID (const IndicatorID_type& x)
  {
    this->IndicatorID_.set (x);
  }

  void Indicator::
  IndicatorID (::std::auto_ptr< IndicatorID_type > x)
  {
    this->IndicatorID_.set (x);
  }

  const Indicator::AlternativeIndicatorID_sequence& Indicator::
  AlternativeIndicatorID () const
  {
    return this->AlternativeIndicatorID_;
  }

  Indicator::AlternativeIndicatorID_sequence& Indicator::
  AlternativeIndicatorID ()
  {
    return this->AlternativeIndicatorID_;
  }

  void Indicator::
  AlternativeIndicatorID (const AlternativeIndicatorID_sequence& s)
  {
    this->AlternativeIndicatorID_ = s;
  }

  const Indicator::Description_sequence& Indicator::
  Description () const
  {
    return this->Description_;
  }

  Indicator::Description_sequence& Indicator::
  Description ()
  {
    return this->Description_;
  }

  void Indicator::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Indicator::StartTime_optional& Indicator::
  StartTime () const
  {
    return this->StartTime_;
  }

  Indicator::StartTime_optional& Indicator::
  StartTime ()
  {
    return this->StartTime_;
  }

  void Indicator::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void Indicator::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void Indicator::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const Indicator::EndTime_optional& Indicator::
  EndTime () const
  {
    return this->EndTime_;
  }

  Indicator::EndTime_optional& Indicator::
  EndTime ()
  {
    return this->EndTime_;
  }

  void Indicator::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void Indicator::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void Indicator::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const Indicator::Confidence_optional& Indicator::
  Confidence () const
  {
    return this->Confidence_;
  }

  Indicator::Confidence_optional& Indicator::
  Confidence ()
  {
    return this->Confidence_;
  }

  void Indicator::
  Confidence (const Confidence_type& x)
  {
    this->Confidence_.set (x);
  }

  void Indicator::
  Confidence (const Confidence_optional& x)
  {
    this->Confidence_ = x;
  }

  void Indicator::
  Confidence (::std::auto_ptr< Confidence_type > x)
  {
    this->Confidence_.set (x);
  }

  const Indicator::Contact_sequence& Indicator::
  Contact () const
  {
    return this->Contact_;
  }

  Indicator::Contact_sequence& Indicator::
  Contact ()
  {
    return this->Contact_;
  }

  void Indicator::
  Contact (const Contact_sequence& s)
  {
    this->Contact_ = s;
  }

  const Indicator::Observable_optional& Indicator::
  Observable () const
  {
    return this->Observable_;
  }

  Indicator::Observable_optional& Indicator::
  Observable ()
  {
    return this->Observable_;
  }

  void Indicator::
  Observable (const Observable_type& x)
  {
    this->Observable_.set (x);
  }

  void Indicator::
  Observable (const Observable_optional& x)
  {
    this->Observable_ = x;
  }

  void Indicator::
  Observable (::std::auto_ptr< Observable_type > x)
  {
    this->Observable_.set (x);
  }

  const Indicator::ObservableReference_optional& Indicator::
  ObservableReference () const
  {
    return this->ObservableReference_;
  }

  Indicator::ObservableReference_optional& Indicator::
  ObservableReference ()
  {
    return this->ObservableReference_;
  }

  void Indicator::
  ObservableReference (const ObservableReference_type& x)
  {
    this->ObservableReference_.set (x);
  }

  void Indicator::
  ObservableReference (const ObservableReference_optional& x)
  {
    this->ObservableReference_ = x;
  }

  void Indicator::
  ObservableReference (::std::auto_ptr< ObservableReference_type > x)
  {
    this->ObservableReference_.set (x);
  }

  const Indicator::IndicatorExpression_optional& Indicator::
  IndicatorExpression () const
  {
    return this->IndicatorExpression_;
  }

  Indicator::IndicatorExpression_optional& Indicator::
  IndicatorExpression ()
  {
    return this->IndicatorExpression_;
  }

  void Indicator::
  IndicatorExpression (const IndicatorExpression_type& x)
  {
    this->IndicatorExpression_.set (x);
  }

  void Indicator::
  IndicatorExpression (const IndicatorExpression_optional& x)
  {
    this->IndicatorExpression_ = x;
  }

  void Indicator::
  IndicatorExpression (::std::auto_ptr< IndicatorExpression_type > x)
  {
    this->IndicatorExpression_.set (x);
  }

  const Indicator::IndicatorReference_optional& Indicator::
  IndicatorReference () const
  {
    return this->IndicatorReference_;
  }

  Indicator::IndicatorReference_optional& Indicator::
  IndicatorReference ()
  {
    return this->IndicatorReference_;
  }

  void Indicator::
  IndicatorReference (const IndicatorReference_type& x)
  {
    this->IndicatorReference_.set (x);
  }

  void Indicator::
  IndicatorReference (const IndicatorReference_optional& x)
  {
    this->IndicatorReference_ = x;
  }

  void Indicator::
  IndicatorReference (::std::auto_ptr< IndicatorReference_type > x)
  {
    this->IndicatorReference_.set (x);
  }

  const Indicator::restriction_optional& Indicator::
  restriction () const
  {
    return this->restriction_;
  }

  Indicator::restriction_optional& Indicator::
  restriction ()
  {
    return this->restriction_;
  }

  void Indicator::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Indicator::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Indicator::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Indicator::ext_restriction_optional& Indicator::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Indicator::ext_restriction_optional& Indicator::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Indicator::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Indicator::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Indicator::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // IndicatorID
  // 

  const IndicatorID::name_type& IndicatorID::
  name () const
  {
    return this->name_.get ();
  }

  IndicatorID::name_type& IndicatorID::
  name ()
  {
    return this->name_.get ();
  }

  void IndicatorID::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void IndicatorID::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const IndicatorID::version_type& IndicatorID::
  version () const
  {
    return this->version_.get ();
  }

  IndicatorID::version_type& IndicatorID::
  version ()
  {
    return this->version_.get ();
  }

  void IndicatorID::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void IndicatorID::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }


  // AlternativeIndicatorID
  // 

  const AlternativeIndicatorID::IndicatorID_sequence& AlternativeIndicatorID::
  IndicatorID () const
  {
    return this->IndicatorID_;
  }

  AlternativeIndicatorID::IndicatorID_sequence& AlternativeIndicatorID::
  IndicatorID ()
  {
    return this->IndicatorID_;
  }

  void AlternativeIndicatorID::
  IndicatorID (const IndicatorID_sequence& s)
  {
    this->IndicatorID_ = s;
  }

  const AlternativeIndicatorID::restriction_optional& AlternativeIndicatorID::
  restriction () const
  {
    return this->restriction_;
  }

  AlternativeIndicatorID::restriction_optional& AlternativeIndicatorID::
  restriction ()
  {
    return this->restriction_;
  }

  void AlternativeIndicatorID::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void AlternativeIndicatorID::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void AlternativeIndicatorID::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const AlternativeIndicatorID::ext_restriction_optional& AlternativeIndicatorID::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  AlternativeIndicatorID::ext_restriction_optional& AlternativeIndicatorID::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void AlternativeIndicatorID::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void AlternativeIndicatorID::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void AlternativeIndicatorID::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // Observable
  // 

  const Observable::Address_optional& Observable::
  Address () const
  {
    return this->Address_;
  }

  Observable::Address_optional& Observable::
  Address ()
  {
    return this->Address_;
  }

  void Observable::
  Address (const Address_type& x)
  {
    this->Address_.set (x);
  }

  void Observable::
  Address (const Address_optional& x)
  {
    this->Address_ = x;
  }

  void Observable::
  Address (::std::auto_ptr< Address_type > x)
  {
    this->Address_.set (x);
  }

  const Observable::DomainData_optional& Observable::
  DomainData () const
  {
    return this->DomainData_;
  }

  Observable::DomainData_optional& Observable::
  DomainData ()
  {
    return this->DomainData_;
  }

  void Observable::
  DomainData (const DomainData_type& x)
  {
    this->DomainData_.set (x);
  }

  void Observable::
  DomainData (const DomainData_optional& x)
  {
    this->DomainData_ = x;
  }

  void Observable::
  DomainData (::std::auto_ptr< DomainData_type > x)
  {
    this->DomainData_.set (x);
  }

  const Observable::EmailData_optional& Observable::
  EmailData () const
  {
    return this->EmailData_;
  }

  Observable::EmailData_optional& Observable::
  EmailData ()
  {
    return this->EmailData_;
  }

  void Observable::
  EmailData (const EmailData_type& x)
  {
    this->EmailData_.set (x);
  }

  void Observable::
  EmailData (const EmailData_optional& x)
  {
    this->EmailData_ = x;
  }

  void Observable::
  EmailData (::std::auto_ptr< EmailData_type > x)
  {
    this->EmailData_.set (x);
  }

  const Observable::ApplicationHeader_optional& Observable::
  ApplicationHeader () const
  {
    return this->ApplicationHeader_;
  }

  Observable::ApplicationHeader_optional& Observable::
  ApplicationHeader ()
  {
    return this->ApplicationHeader_;
  }

  void Observable::
  ApplicationHeader (const ApplicationHeader_type& x)
  {
    this->ApplicationHeader_.set (x);
  }

  void Observable::
  ApplicationHeader (const ApplicationHeader_optional& x)
  {
    this->ApplicationHeader_ = x;
  }

  void Observable::
  ApplicationHeader (::std::auto_ptr< ApplicationHeader_type > x)
  {
    this->ApplicationHeader_.set (x);
  }

  const Observable::WindowsRegistryKeysModified_optional& Observable::
  WindowsRegistryKeysModified () const
  {
    return this->WindowsRegistryKeysModified_;
  }

  Observable::WindowsRegistryKeysModified_optional& Observable::
  WindowsRegistryKeysModified ()
  {
    return this->WindowsRegistryKeysModified_;
  }

  void Observable::
  WindowsRegistryKeysModified (const WindowsRegistryKeysModified_type& x)
  {
    this->WindowsRegistryKeysModified_.set (x);
  }

  void Observable::
  WindowsRegistryKeysModified (const WindowsRegistryKeysModified_optional& x)
  {
    this->WindowsRegistryKeysModified_ = x;
  }

  void Observable::
  WindowsRegistryKeysModified (::std::auto_ptr< WindowsRegistryKeysModified_type > x)
  {
    this->WindowsRegistryKeysModified_.set (x);
  }

  const Observable::FileData_optional& Observable::
  FileData () const
  {
    return this->FileData_;
  }

  Observable::FileData_optional& Observable::
  FileData ()
  {
    return this->FileData_;
  }

  void Observable::
  FileData (const FileData_type& x)
  {
    this->FileData_.set (x);
  }

  void Observable::
  FileData (const FileData_optional& x)
  {
    this->FileData_ = x;
  }

  void Observable::
  FileData (::std::auto_ptr< FileData_type > x)
  {
    this->FileData_.set (x);
  }

  const Observable::CertificateData_optional& Observable::
  CertificateData () const
  {
    return this->CertificateData_;
  }

  Observable::CertificateData_optional& Observable::
  CertificateData ()
  {
    return this->CertificateData_;
  }

  void Observable::
  CertificateData (const CertificateData_type& x)
  {
    this->CertificateData_.set (x);
  }

  void Observable::
  CertificateData (const CertificateData_optional& x)
  {
    this->CertificateData_ = x;
  }

  void Observable::
  CertificateData (::std::auto_ptr< CertificateData_type > x)
  {
    this->CertificateData_.set (x);
  }

  const Observable::RegistryHandle_optional& Observable::
  RegistryHandle () const
  {
    return this->RegistryHandle_;
  }

  Observable::RegistryHandle_optional& Observable::
  RegistryHandle ()
  {
    return this->RegistryHandle_;
  }

  void Observable::
  RegistryHandle (const RegistryHandle_type& x)
  {
    this->RegistryHandle_.set (x);
  }

  void Observable::
  RegistryHandle (const RegistryHandle_optional& x)
  {
    this->RegistryHandle_ = x;
  }

  void Observable::
  RegistryHandle (::std::auto_ptr< RegistryHandle_type > x)
  {
    this->RegistryHandle_.set (x);
  }

  const Observable::RecordData_optional& Observable::
  RecordData () const
  {
    return this->RecordData_;
  }

  Observable::RecordData_optional& Observable::
  RecordData ()
  {
    return this->RecordData_;
  }

  void Observable::
  RecordData (const RecordData_type& x)
  {
    this->RecordData_.set (x);
  }

  void Observable::
  RecordData (const RecordData_optional& x)
  {
    this->RecordData_ = x;
  }

  void Observable::
  RecordData (::std::auto_ptr< RecordData_type > x)
  {
    this->RecordData_.set (x);
  }

  const Observable::EventData_optional& Observable::
  EventData () const
  {
    return this->EventData_;
  }

  Observable::EventData_optional& Observable::
  EventData ()
  {
    return this->EventData_;
  }

  void Observable::
  EventData (const EventData_type& x)
  {
    this->EventData_.set (x);
  }

  void Observable::
  EventData (const EventData_optional& x)
  {
    this->EventData_ = x;
  }

  void Observable::
  EventData (::std::auto_ptr< EventData_type > x)
  {
    this->EventData_.set (x);
  }

  const Observable::Incident_optional& Observable::
  Incident () const
  {
    return this->Incident_;
  }

  Observable::Incident_optional& Observable::
  Incident ()
  {
    return this->Incident_;
  }

  void Observable::
  Incident (const Incident_type& x)
  {
    this->Incident_.set (x);
  }

  void Observable::
  Incident (const Incident_optional& x)
  {
    this->Incident_ = x;
  }

  void Observable::
  Incident (::std::auto_ptr< Incident_type > x)
  {
    this->Incident_.set (x);
  }

  const Observable::Expectation_sequence& Observable::
  Expectation () const
  {
    return this->Expectation_;
  }

  Observable::Expectation_sequence& Observable::
  Expectation ()
  {
    return this->Expectation_;
  }

  void Observable::
  Expectation (const Expectation_sequence& s)
  {
    this->Expectation_ = s;
  }

  const Observable::Reference_sequence& Observable::
  Reference () const
  {
    return this->Reference_;
  }

  Observable::Reference_sequence& Observable::
  Reference ()
  {
    return this->Reference_;
  }

  void Observable::
  Reference (const Reference_sequence& s)
  {
    this->Reference_ = s;
  }

  const Observable::Assessment_optional& Observable::
  Assessment () const
  {
    return this->Assessment_;
  }

  Observable::Assessment_optional& Observable::
  Assessment ()
  {
    return this->Assessment_;
  }

  void Observable::
  Assessment (const Assessment_type& x)
  {
    this->Assessment_.set (x);
  }

  void Observable::
  Assessment (const Assessment_optional& x)
  {
    this->Assessment_ = x;
  }

  void Observable::
  Assessment (::std::auto_ptr< Assessment_type > x)
  {
    this->Assessment_.set (x);
  }

  const Observable::HistoryItem_optional& Observable::
  HistoryItem () const
  {
    return this->HistoryItem_;
  }

  Observable::HistoryItem_optional& Observable::
  HistoryItem ()
  {
    return this->HistoryItem_;
  }

  void Observable::
  HistoryItem (const HistoryItem_type& x)
  {
    this->HistoryItem_.set (x);
  }

  void Observable::
  HistoryItem (const HistoryItem_optional& x)
  {
    this->HistoryItem_ = x;
  }

  void Observable::
  HistoryItem (::std::auto_ptr< HistoryItem_type > x)
  {
    this->HistoryItem_.set (x);
  }

  const Observable::BulkObservable_optional& Observable::
  BulkObservable () const
  {
    return this->BulkObservable_;
  }

  Observable::BulkObservable_optional& Observable::
  BulkObservable ()
  {
    return this->BulkObservable_;
  }

  void Observable::
  BulkObservable (const BulkObservable_type& x)
  {
    this->BulkObservable_.set (x);
  }

  void Observable::
  BulkObservable (const BulkObservable_optional& x)
  {
    this->BulkObservable_ = x;
  }

  void Observable::
  BulkObservable (::std::auto_ptr< BulkObservable_type > x)
  {
    this->BulkObservable_.set (x);
  }

  const Observable::AdditionalData_optional& Observable::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Observable::AdditionalData_optional& Observable::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Observable::
  AdditionalData (const AdditionalData_type& x)
  {
    this->AdditionalData_.set (x);
  }

  void Observable::
  AdditionalData (const AdditionalData_optional& x)
  {
    this->AdditionalData_ = x;
  }

  void Observable::
  AdditionalData (::std::auto_ptr< AdditionalData_type > x)
  {
    this->AdditionalData_.set (x);
  }

  const Observable::restriction_optional& Observable::
  restriction () const
  {
    return this->restriction_;
  }

  Observable::restriction_optional& Observable::
  restriction ()
  {
    return this->restriction_;
  }

  void Observable::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Observable::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Observable::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Observable::ext_restriction_optional& Observable::
  ext_restriction () const
  {
    return this->ext_restriction_;
  }

  Observable::ext_restriction_optional& Observable::
  ext_restriction ()
  {
    return this->ext_restriction_;
  }

  void Observable::
  ext_restriction (const ext_restriction_type& x)
  {
    this->ext_restriction_.set (x);
  }

  void Observable::
  ext_restriction (const ext_restriction_optional& x)
  {
    this->ext_restriction_ = x;
  }

  void Observable::
  ext_restriction (::std::auto_ptr< ext_restriction_type > x)
  {
    this->ext_restriction_.set (x);
  }


  // BulkObservable
  // 

  const BulkObservable::BulkObservableFormat_optional& BulkObservable::
  BulkObservableFormat () const
  {
    return this->BulkObservableFormat_;
  }

  BulkObservable::BulkObservableFormat_optional& BulkObservable::
  BulkObservableFormat ()
  {
    return this->BulkObservableFormat_;
  }

  void BulkObservable::
  BulkObservableFormat (const BulkObservableFormat_type& x)
  {
    this->BulkObservableFormat_.set (x);
  }

  void BulkObservable::
  BulkObservableFormat (const BulkObservableFormat_optional& x)
  {
    this->BulkObservableFormat_ = x;
  }

  void BulkObservable::
  BulkObservableFormat (::std::auto_ptr< BulkObservableFormat_type > x)
  {
    this->BulkObservableFormat_.set (x);
  }

  const BulkObservable::BulkObservableList_optional& BulkObservable::
  BulkObservableList () const
  {
    return this->BulkObservableList_;
  }

  BulkObservable::BulkObservableList_optional& BulkObservable::
  BulkObservableList ()
  {
    return this->BulkObservableList_;
  }

  void BulkObservable::
  BulkObservableList (const BulkObservableList_type& x)
  {
    this->BulkObservableList_.set (x);
  }

  void BulkObservable::
  BulkObservableList (const BulkObservableList_optional& x)
  {
    this->BulkObservableList_ = x;
  }

  void BulkObservable::
  BulkObservableList (::std::auto_ptr< BulkObservableList_type > x)
  {
    this->BulkObservableList_.set (x);
  }

  const BulkObservable::type_type& BulkObservable::
  type () const
  {
    return this->type_.get ();
  }

  BulkObservable::type_type& BulkObservable::
  type ()
  {
    return this->type_.get ();
  }

  void BulkObservable::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void BulkObservable::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const BulkObservable::ext_type_optional& BulkObservable::
  ext_type () const
  {
    return this->ext_type_;
  }

  BulkObservable::ext_type_optional& BulkObservable::
  ext_type ()
  {
    return this->ext_type_;
  }

  void BulkObservable::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void BulkObservable::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void BulkObservable::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }


  // BulkObservableFormat
  // 

  const BulkObservableFormat::Hash_optional& BulkObservableFormat::
  Hash () const
  {
    return this->Hash_;
  }

  BulkObservableFormat::Hash_optional& BulkObservableFormat::
  Hash ()
  {
    return this->Hash_;
  }

  void BulkObservableFormat::
  Hash (const Hash_type& x)
  {
    this->Hash_.set (x);
  }

  void BulkObservableFormat::
  Hash (const Hash_optional& x)
  {
    this->Hash_ = x;
  }

  void BulkObservableFormat::
  Hash (::std::auto_ptr< Hash_type > x)
  {
    this->Hash_.set (x);
  }

  const BulkObservableFormat::AdditionalData_sequence& BulkObservableFormat::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  BulkObservableFormat::AdditionalData_sequence& BulkObservableFormat::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void BulkObservableFormat::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }


  // IndicatorExpression
  // 

  const IndicatorExpression::IndicatorExpression1_optional& IndicatorExpression::
  IndicatorExpression1 () const
  {
    return this->IndicatorExpression1_;
  }

  IndicatorExpression::IndicatorExpression1_optional& IndicatorExpression::
  IndicatorExpression1 ()
  {
    return this->IndicatorExpression1_;
  }

  void IndicatorExpression::
  IndicatorExpression1 (const IndicatorExpression1_type& x)
  {
    this->IndicatorExpression1_.set (x);
  }

  void IndicatorExpression::
  IndicatorExpression1 (const IndicatorExpression1_optional& x)
  {
    this->IndicatorExpression1_ = x;
  }

  void IndicatorExpression::
  IndicatorExpression1 (::std::auto_ptr< IndicatorExpression1_type > x)
  {
    this->IndicatorExpression1_.set (x);
  }

  const IndicatorExpression::Observable_optional& IndicatorExpression::
  Observable () const
  {
    return this->Observable_;
  }

  IndicatorExpression::Observable_optional& IndicatorExpression::
  Observable ()
  {
    return this->Observable_;
  }

  void IndicatorExpression::
  Observable (const Observable_type& x)
  {
    this->Observable_.set (x);
  }

  void IndicatorExpression::
  Observable (const Observable_optional& x)
  {
    this->Observable_ = x;
  }

  void IndicatorExpression::
  Observable (::std::auto_ptr< Observable_type > x)
  {
    this->Observable_.set (x);
  }

  const IndicatorExpression::ObservableReference_optional& IndicatorExpression::
  ObservableReference () const
  {
    return this->ObservableReference_;
  }

  IndicatorExpression::ObservableReference_optional& IndicatorExpression::
  ObservableReference ()
  {
    return this->ObservableReference_;
  }

  void IndicatorExpression::
  ObservableReference (const ObservableReference_type& x)
  {
    this->ObservableReference_.set (x);
  }

  void IndicatorExpression::
  ObservableReference (const ObservableReference_optional& x)
  {
    this->ObservableReference_ = x;
  }

  void IndicatorExpression::
  ObservableReference (::std::auto_ptr< ObservableReference_type > x)
  {
    this->ObservableReference_.set (x);
  }

  const IndicatorExpression::IndicatorReference_optional& IndicatorExpression::
  IndicatorReference () const
  {
    return this->IndicatorReference_;
  }

  IndicatorExpression::IndicatorReference_optional& IndicatorExpression::
  IndicatorReference ()
  {
    return this->IndicatorReference_;
  }

  void IndicatorExpression::
  IndicatorReference (const IndicatorReference_type& x)
  {
    this->IndicatorReference_.set (x);
  }

  void IndicatorExpression::
  IndicatorReference (const IndicatorReference_optional& x)
  {
    this->IndicatorReference_ = x;
  }

  void IndicatorExpression::
  IndicatorReference (::std::auto_ptr< IndicatorReference_type > x)
  {
    this->IndicatorReference_.set (x);
  }

  const IndicatorExpression::AlternativeIndicatorID_sequence& IndicatorExpression::
  AlternativeIndicatorID () const
  {
    return this->AlternativeIndicatorID_;
  }

  IndicatorExpression::AlternativeIndicatorID_sequence& IndicatorExpression::
  AlternativeIndicatorID ()
  {
    return this->AlternativeIndicatorID_;
  }

  void IndicatorExpression::
  AlternativeIndicatorID (const AlternativeIndicatorID_sequence& s)
  {
    this->AlternativeIndicatorID_ = s;
  }

  const IndicatorExpression::operator_type& IndicatorExpression::
  operator_ () const
  {
    return this->operator__.get ();
  }

  IndicatorExpression::operator_type& IndicatorExpression::
  operator_ ()
  {
    return this->operator__.get ();
  }

  void IndicatorExpression::
  operator_ (const operator_type& x)
  {
    this->operator__.set (x);
  }

  void IndicatorExpression::
  operator_ (::std::auto_ptr< operator_type > x)
  {
    this->operator__.set (x);
  }


  // ObservableReference
  // 

  const ObservableReference::uid_ref_type& ObservableReference::
  uid_ref () const
  {
    return this->uid_ref_.get ();
  }

  ObservableReference::uid_ref_type& ObservableReference::
  uid_ref ()
  {
    return this->uid_ref_.get ();
  }

  void ObservableReference::
  uid_ref (const uid_ref_type& x)
  {
    this->uid_ref_.set (x);
  }

  void ObservableReference::
  uid_ref (::std::auto_ptr< uid_ref_type > x)
  {
    this->uid_ref_.set (x);
  }


  // IndicatorReference
  // 

  const IndicatorReference::uid_ref_optional& IndicatorReference::
  uid_ref () const
  {
    return this->uid_ref_;
  }

  IndicatorReference::uid_ref_optional& IndicatorReference::
  uid_ref ()
  {
    return this->uid_ref_;
  }

  void IndicatorReference::
  uid_ref (const uid_ref_type& x)
  {
    this->uid_ref_.set (x);
  }

  void IndicatorReference::
  uid_ref (const uid_ref_optional& x)
  {
    this->uid_ref_ = x;
  }

  void IndicatorReference::
  uid_ref (::std::auto_ptr< uid_ref_type > x)
  {
    this->uid_ref_.set (x);
  }

  const IndicatorReference::euid_ref_optional& IndicatorReference::
  euid_ref () const
  {
    return this->euid_ref_;
  }

  IndicatorReference::euid_ref_optional& IndicatorReference::
  euid_ref ()
  {
    return this->euid_ref_;
  }

  void IndicatorReference::
  euid_ref (const euid_ref_type& x)
  {
    this->euid_ref_.set (x);
  }

  void IndicatorReference::
  euid_ref (const euid_ref_optional& x)
  {
    this->euid_ref_ = x;
  }

  void IndicatorReference::
  euid_ref (::std::auto_ptr< euid_ref_type > x)
  {
    this->euid_ref_.set (x);
  }

  const IndicatorReference::version_optional& IndicatorReference::
  version () const
  {
    return this->version_;
  }

  IndicatorReference::version_optional& IndicatorReference::
  version ()
  {
    return this->version_;
  }

  void IndicatorReference::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void IndicatorReference::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void IndicatorReference::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }


  // occurrence
  // 

  occurrence::
  occurrence (value v)
  : ::xml_schema::nmtoken (_xsd_occurrence_literals_[v])
  {
  }

  occurrence::
  occurrence (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  occurrence::
  occurrence (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  occurrence::
  occurrence (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  occurrence::
  occurrence (const occurrence& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  occurrence& occurrence::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_occurrence_literals_[v]);

    return *this;
  }


  // completion
  // 

  completion::
  completion (value v)
  : ::xml_schema::nmtoken (_xsd_completion_literals_[v])
  {
  }

  completion::
  completion (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  completion::
  completion (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  completion::
  completion (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  completion::
  completion (const completion& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  completion& completion::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_completion_literals_[v]);

    return *this;
  }


  // record_type
  // 

  record_type::
  record_type (value v)
  : ::xml_schema::nmtoken (_xsd_record_type_literals_[v])
  {
  }

  record_type::
  record_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  record_type::
  record_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  record_type::
  record_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  record_type::
  record_type (const record_type& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  record_type& record_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_record_type_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace iodef_2_0
{
  // incident_purpose_type
  //

  incident_purpose_type::
  incident_purpose_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_incident_purpose_type_convert ();
  }

  incident_purpose_type::
  incident_purpose_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_incident_purpose_type_convert ();
  }

  incident_purpose_type::
  incident_purpose_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_incident_purpose_type_convert ();
  }

  incident_purpose_type* incident_purpose_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class incident_purpose_type (*this, f, c);
  }

  incident_purpose_type::value incident_purpose_type::
  _xsd_incident_purpose_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_incident_purpose_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_incident_purpose_type_indexes_,
                      _xsd_incident_purpose_type_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_incident_purpose_type_indexes_ + 6 || _xsd_incident_purpose_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const incident_purpose_type::
  _xsd_incident_purpose_type_literals_[6] =
  {
    "traceback",
    "mitigation",
    "reporting",
    "watch",
    "other",
    "ext-value"
  };

  const incident_purpose_type::value incident_purpose_type::
  _xsd_incident_purpose_type_indexes_[6] =
  {
    ::iodef_2_0::incident_purpose_type::ext_value,
    ::iodef_2_0::incident_purpose_type::mitigation,
    ::iodef_2_0::incident_purpose_type::other,
    ::iodef_2_0::incident_purpose_type::reporting,
    ::iodef_2_0::incident_purpose_type::traceback,
    ::iodef_2_0::incident_purpose_type::watch
  };

  // incident_status_type
  //

  incident_status_type::
  incident_status_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_incident_status_type_convert ();
  }

  incident_status_type::
  incident_status_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_incident_status_type_convert ();
  }

  incident_status_type::
  incident_status_type (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_incident_status_type_convert ();
  }

  incident_status_type* incident_status_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class incident_status_type (*this, f, c);
  }

  incident_status_type::value incident_status_type::
  _xsd_incident_status_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_incident_status_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_incident_status_type_indexes_,
                      _xsd_incident_status_type_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_incident_status_type_indexes_ + 6 || _xsd_incident_status_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const incident_status_type::
  _xsd_incident_status_type_literals_[6] =
  {
    "new",
    "in-progress",
    "forwarded",
    "resolved",
    "future",
    "ext-value"
  };

  const incident_status_type::value incident_status_type::
  _xsd_incident_status_type_indexes_[6] =
  {
    ::iodef_2_0::incident_status_type::ext_value,
    ::iodef_2_0::incident_status_type::forwarded,
    ::iodef_2_0::incident_status_type::future,
    ::iodef_2_0::incident_status_type::in_progress,
    ::iodef_2_0::incident_status_type::new_,
    ::iodef_2_0::incident_status_type::resolved
  };

  // IncidentIDType
  //

  const IncidentIDType::restriction_type IncidentIDType::restriction_default_value_ (
    "public");

  IncidentIDType::
  IncidentIDType (const name_type& name)
  : ::xml_schema::string (),
    name_ (name, this),
    instance_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this)
  {
  }

  IncidentIDType::
  IncidentIDType (const char* _xsd_string_base,
                  const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this),
    instance_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this)
  {
  }

  IncidentIDType::
  IncidentIDType (const ::std::string& _xsd_string_base,
                  const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this),
    instance_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this)
  {
  }

  IncidentIDType::
  IncidentIDType (const ::xml_schema::string& _xsd_string_base,
                  const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this),
    instance_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this)
  {
  }

  IncidentIDType::
  IncidentIDType (const IncidentIDType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    name_ (x.name_, f, this),
    instance_ (x.instance_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  IncidentIDType::
  IncidentIDType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    instance_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IncidentIDType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "instance" && n.namespace_ ().empty ())
      {
        this->instance_.set (instance_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }
  }

  IncidentIDType* IncidentIDType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IncidentIDType (*this, f, c);
  }

  IncidentIDType& IncidentIDType::
  operator= (const IncidentIDType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->name_ = x.name_;
      this->instance_ = x.instance_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  IncidentIDType::
  ~IncidentIDType ()
  {
  }

  // contact_role_type
  //

  contact_role_type::
  contact_role_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_contact_role_type_convert ();
  }

  contact_role_type::
  contact_role_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_contact_role_type_convert ();
  }

  contact_role_type::
  contact_role_type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_contact_role_type_convert ();
  }

  contact_role_type* contact_role_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class contact_role_type (*this, f, c);
  }

  contact_role_type::value contact_role_type::
  _xsd_contact_role_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_contact_role_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_contact_role_type_indexes_,
                      _xsd_contact_role_type_indexes_ + 19,
                      *this,
                      c));

    if (i == _xsd_contact_role_type_indexes_ + 19 || _xsd_contact_role_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const contact_role_type::
  _xsd_contact_role_type_literals_[19] =
  {
    "creator",
    "reporter",
    "admin",
    "tech",
    "provider",
    "zone",
    "user",
    "billing",
    "legal",
    "abuse",
    "irt",
    "cc",
    "cc-irt",
    "leo",
    "vendor",
    "vendor-services",
    "victim",
    "victim-notified",
    "ext-value"
  };

  const contact_role_type::value contact_role_type::
  _xsd_contact_role_type_indexes_[19] =
  {
    ::iodef_2_0::contact_role_type::abuse,
    ::iodef_2_0::contact_role_type::admin,
    ::iodef_2_0::contact_role_type::billing,
    ::iodef_2_0::contact_role_type::cc,
    ::iodef_2_0::contact_role_type::cc_irt,
    ::iodef_2_0::contact_role_type::creator,
    ::iodef_2_0::contact_role_type::ext_value,
    ::iodef_2_0::contact_role_type::irt,
    ::iodef_2_0::contact_role_type::legal,
    ::iodef_2_0::contact_role_type::leo,
    ::iodef_2_0::contact_role_type::provider,
    ::iodef_2_0::contact_role_type::reporter,
    ::iodef_2_0::contact_role_type::tech,
    ::iodef_2_0::contact_role_type::user,
    ::iodef_2_0::contact_role_type::vendor,
    ::iodef_2_0::contact_role_type::vendor_services,
    ::iodef_2_0::contact_role_type::victim,
    ::iodef_2_0::contact_role_type::victim_notified,
    ::iodef_2_0::contact_role_type::zone
  };

  // contact_type_type
  //

  contact_type_type::
  contact_type_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_contact_type_type_convert ();
  }

  contact_type_type::
  contact_type_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_contact_type_type_convert ();
  }

  contact_type_type::
  contact_type_type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_contact_type_type_convert ();
  }

  contact_type_type* contact_type_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class contact_type_type (*this, f, c);
  }

  contact_type_type::value contact_type_type::
  _xsd_contact_type_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_contact_type_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_contact_type_type_indexes_,
                      _xsd_contact_type_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_contact_type_type_indexes_ + 3 || _xsd_contact_type_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const contact_type_type::
  _xsd_contact_type_type_literals_[3] =
  {
    "person",
    "organization",
    "ext-value"
  };

  const contact_type_type::value contact_type_type::
  _xsd_contact_type_type_indexes_[3] =
  {
    ::iodef_2_0::contact_type_type::ext_value,
    ::iodef_2_0::contact_type_type::organization,
    ::iodef_2_0::contact_type_type::person
  };

  // registryhandle_registry_type
  //

  registryhandle_registry_type::
  registryhandle_registry_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_registryhandle_registry_type_convert ();
  }

  registryhandle_registry_type::
  registryhandle_registry_type (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_registryhandle_registry_type_convert ();
  }

  registryhandle_registry_type::
  registryhandle_registry_type (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_registryhandle_registry_type_convert ();
  }

  registryhandle_registry_type* registryhandle_registry_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class registryhandle_registry_type (*this, f, c);
  }

  registryhandle_registry_type::value registryhandle_registry_type::
  _xsd_registryhandle_registry_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_registryhandle_registry_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_registryhandle_registry_type_indexes_,
                      _xsd_registryhandle_registry_type_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_registryhandle_registry_type_indexes_ + 8 || _xsd_registryhandle_registry_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const registryhandle_registry_type::
  _xsd_registryhandle_registry_type_literals_[8] =
  {
    "internic",
    "apnic",
    "arin",
    "lacnic",
    "ripe",
    "afrinic",
    "local",
    "ext-value"
  };

  const registryhandle_registry_type::value registryhandle_registry_type::
  _xsd_registryhandle_registry_type_indexes_[8] =
  {
    ::iodef_2_0::registryhandle_registry_type::afrinic,
    ::iodef_2_0::registryhandle_registry_type::apnic,
    ::iodef_2_0::registryhandle_registry_type::arin,
    ::iodef_2_0::registryhandle_registry_type::ext_value,
    ::iodef_2_0::registryhandle_registry_type::internic,
    ::iodef_2_0::registryhandle_registry_type::lacnic,
    ::iodef_2_0::registryhandle_registry_type::local,
    ::iodef_2_0::registryhandle_registry_type::ripe
  };

  // ContactMeansType
  //

  ContactMeansType::
  ContactMeansType ()
  : ::xml_schema::string (),
    meaning_ (this)
  {
  }

  ContactMeansType::
  ContactMeansType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (this)
  {
  }

  ContactMeansType::
  ContactMeansType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (this)
  {
  }

  ContactMeansType::
  ContactMeansType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (this)
  {
  }

  ContactMeansType::
  ContactMeansType (const ContactMeansType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    meaning_ (x.meaning_, f, this)
  {
  }

  ContactMeansType::
  ContactMeansType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    meaning_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ContactMeansType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        this->meaning_.set (meaning_traits::create (i, f, this));
        continue;
      }
    }
  }

  ContactMeansType* ContactMeansType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContactMeansType (*this, f, c);
  }

  ContactMeansType& ContactMeansType::
  operator= (const ContactMeansType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->meaning_ = x.meaning_;
    }

    return *this;
  }

  ContactMeansType::
  ~ContactMeansType ()
  {
  }

  // TimezoneType
  //

  TimezoneType::
  TimezoneType ()
  : ::xml_schema::string ()
  {
  }

  TimezoneType::
  TimezoneType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  TimezoneType::
  TimezoneType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  TimezoneType::
  TimezoneType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  TimezoneType::
  TimezoneType (const TimezoneType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  TimezoneType::
  TimezoneType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  TimezoneType::
  TimezoneType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  TimezoneType::
  TimezoneType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  TimezoneType* TimezoneType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimezoneType (*this, f, c);
  }

  TimezoneType::
  ~TimezoneType ()
  {
  }

  // discovery_source_type
  //

  discovery_source_type::
  discovery_source_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_discovery_source_type_convert ();
  }

  discovery_source_type::
  discovery_source_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_discovery_source_type_convert ();
  }

  discovery_source_type::
  discovery_source_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_discovery_source_type_convert ();
  }

  discovery_source_type* discovery_source_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class discovery_source_type (*this, f, c);
  }

  discovery_source_type::value discovery_source_type::
  _xsd_discovery_source_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_discovery_source_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_discovery_source_type_indexes_,
                      _xsd_discovery_source_type_indexes_ + 20,
                      *this,
                      c));

    if (i == _xsd_discovery_source_type_indexes_ + 20 || _xsd_discovery_source_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const discovery_source_type::
  _xsd_discovery_source_type_literals_[20] =
  {
    "nidps",
    "hips",
    "siem",
    "av",
    "third-party-monitoring",
    "incident",
    "os-log",
    "application-log",
    "device-log",
    "network-flow",
    "passive-dns",
    "investigation",
    "audit",
    "internal-notification",
    "external-notification",
    "leo",
    "partner",
    "actor",
    "unknown",
    "ext-value"
  };

  const discovery_source_type::value discovery_source_type::
  _xsd_discovery_source_type_indexes_[20] =
  {
    ::iodef_2_0::discovery_source_type::actor,
    ::iodef_2_0::discovery_source_type::application_log,
    ::iodef_2_0::discovery_source_type::audit,
    ::iodef_2_0::discovery_source_type::av,
    ::iodef_2_0::discovery_source_type::device_log,
    ::iodef_2_0::discovery_source_type::ext_value,
    ::iodef_2_0::discovery_source_type::external_notification,
    ::iodef_2_0::discovery_source_type::hips,
    ::iodef_2_0::discovery_source_type::incident,
    ::iodef_2_0::discovery_source_type::internal_notification,
    ::iodef_2_0::discovery_source_type::investigation,
    ::iodef_2_0::discovery_source_type::leo,
    ::iodef_2_0::discovery_source_type::network_flow,
    ::iodef_2_0::discovery_source_type::nidps,
    ::iodef_2_0::discovery_source_type::os_log,
    ::iodef_2_0::discovery_source_type::partner,
    ::iodef_2_0::discovery_source_type::passive_dns,
    ::iodef_2_0::discovery_source_type::siem,
    ::iodef_2_0::discovery_source_type::third_party_monitoring,
    ::iodef_2_0::discovery_source_type::unknown
  };

  // systemimpact_type_type
  //

  systemimpact_type_type::
  systemimpact_type_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_systemimpact_type_type_convert ();
  }

  systemimpact_type_type::
  systemimpact_type_type (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_systemimpact_type_type_convert ();
  }

  systemimpact_type_type::
  systemimpact_type_type (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_systemimpact_type_type_convert ();
  }

  systemimpact_type_type* systemimpact_type_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class systemimpact_type_type (*this, f, c);
  }

  systemimpact_type_type::value systemimpact_type_type::
  _xsd_systemimpact_type_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_systemimpact_type_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_systemimpact_type_type_indexes_,
                      _xsd_systemimpact_type_type_indexes_ + 24,
                      *this,
                      c));

    if (i == _xsd_systemimpact_type_type_indexes_ + 24 || _xsd_systemimpact_type_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const systemimpact_type_type::
  _xsd_systemimpact_type_type_literals_[24] =
  {
    "admin",
    "takeover-account",
    "takeover-service",
    "takeover-system",
    "cps-manipulation",
    "cps-damage",
    "availability-data",
    "availibility-account",
    "availibility-service",
    "availibility-system",
    "damaged-system",
    "damaged-data",
    "breach-proprietary",
    "breach-privacy",
    "breach-credential",
    "breach-configuration",
    "integrity-data",
    "integrity-configuration",
    "integrity-hardware",
    "traffic-redirection",
    "monitoring-traffic",
    "monitoring-host",
    "policy",
    "ext-value"
  };

  const systemimpact_type_type::value systemimpact_type_type::
  _xsd_systemimpact_type_type_indexes_[24] =
  {
    ::iodef_2_0::systemimpact_type_type::admin,
    ::iodef_2_0::systemimpact_type_type::availability_data,
    ::iodef_2_0::systemimpact_type_type::availibility_account,
    ::iodef_2_0::systemimpact_type_type::availibility_service,
    ::iodef_2_0::systemimpact_type_type::availibility_system,
    ::iodef_2_0::systemimpact_type_type::breach_configuration,
    ::iodef_2_0::systemimpact_type_type::breach_credential,
    ::iodef_2_0::systemimpact_type_type::breach_privacy,
    ::iodef_2_0::systemimpact_type_type::breach_proprietary,
    ::iodef_2_0::systemimpact_type_type::cps_damage,
    ::iodef_2_0::systemimpact_type_type::cps_manipulation,
    ::iodef_2_0::systemimpact_type_type::damaged_data,
    ::iodef_2_0::systemimpact_type_type::damaged_system,
    ::iodef_2_0::systemimpact_type_type::ext_value,
    ::iodef_2_0::systemimpact_type_type::integrity_configuration,
    ::iodef_2_0::systemimpact_type_type::integrity_data,
    ::iodef_2_0::systemimpact_type_type::integrity_hardware,
    ::iodef_2_0::systemimpact_type_type::monitoring_host,
    ::iodef_2_0::systemimpact_type_type::monitoring_traffic,
    ::iodef_2_0::systemimpact_type_type::policy,
    ::iodef_2_0::systemimpact_type_type::takeover_account,
    ::iodef_2_0::systemimpact_type_type::takeover_service,
    ::iodef_2_0::systemimpact_type_type::takeover_system,
    ::iodef_2_0::systemimpact_type_type::traffic_redirection
  };

  // MLStringType
  //

  MLStringType::
  MLStringType ()
  : ::xml_schema::string (),
    translation_id_ (this),
    lang_ (this)
  {
  }

  MLStringType::
  MLStringType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    translation_id_ (this),
    lang_ (this)
  {
  }

  MLStringType::
  MLStringType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    translation_id_ (this),
    lang_ (this)
  {
  }

  MLStringType::
  MLStringType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    translation_id_ (this),
    lang_ (this)
  {
  }

  MLStringType::
  MLStringType (const MLStringType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    translation_id_ (x.translation_id_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  MLStringType::
  MLStringType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    translation_id_ (this),
    lang_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MLStringType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "translation-id" && n.namespace_ ().empty ())
      {
        this->translation_id_.set (translation_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }
    }
  }

  MLStringType* MLStringType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MLStringType (*this, f, c);
  }

  MLStringType& MLStringType::
  operator= (const MLStringType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->translation_id_ = x.translation_id_;
      this->lang_ = x.lang_;
    }

    return *this;
  }

  MLStringType::
  ~MLStringType ()
  {
  }

  // BusinessImpactType
  //

  BusinessImpactType::
  BusinessImpactType ()
  : ::iodef_2_0::MLStringType (),
    severity_ (this),
    ext_severity_ (this),
    type_ (this),
    ext_type_ (this)
  {
  }

  BusinessImpactType::
  BusinessImpactType (const char* _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    severity_ (this),
    ext_severity_ (this),
    type_ (this),
    ext_type_ (this)
  {
  }

  BusinessImpactType::
  BusinessImpactType (const ::std::string& _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    severity_ (this),
    ext_severity_ (this),
    type_ (this),
    ext_type_ (this)
  {
  }

  BusinessImpactType::
  BusinessImpactType (const ::xml_schema::string& _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    severity_ (this),
    ext_severity_ (this),
    type_ (this),
    ext_type_ (this)
  {
  }

  BusinessImpactType::
  BusinessImpactType (const BusinessImpactType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::iodef_2_0::MLStringType (x, f, c),
    severity_ (x.severity_, f, this),
    ext_severity_ (x.ext_severity_, f, this),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this)
  {
  }

  BusinessImpactType::
  BusinessImpactType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::iodef_2_0::MLStringType (e, f | ::xml_schema::flags::base, c),
    severity_ (this),
    ext_severity_ (this),
    type_ (this),
    ext_type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BusinessImpactType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::iodef_2_0::MLStringType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        this->severity_.set (severity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-severity" && n.namespace_ ().empty ())
      {
        this->ext_severity_.set (ext_severity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        this->ext_type_.set (ext_type_traits::create (i, f, this));
        continue;
      }
    }
  }

  BusinessImpactType* BusinessImpactType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BusinessImpactType (*this, f, c);
  }

  BusinessImpactType& BusinessImpactType::
  operator= (const BusinessImpactType& x)
  {
    if (this != &x)
    {
      static_cast< ::iodef_2_0::MLStringType& > (*this) = x;
      this->severity_ = x.severity_;
      this->ext_severity_ = x.ext_severity_;
      this->type_ = x.type_;
      this->ext_type_ = x.ext_type_;
    }

    return *this;
  }

  BusinessImpactType::
  ~BusinessImpactType ()
  {
  }

  // businessimpact_severity_type
  //

  businessimpact_severity_type::
  businessimpact_severity_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_businessimpact_severity_type_convert ();
  }

  businessimpact_severity_type::
  businessimpact_severity_type (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_businessimpact_severity_type_convert ();
  }

  businessimpact_severity_type::
  businessimpact_severity_type (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_businessimpact_severity_type_convert ();
  }

  businessimpact_severity_type* businessimpact_severity_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class businessimpact_severity_type (*this, f, c);
  }

  businessimpact_severity_type::value businessimpact_severity_type::
  _xsd_businessimpact_severity_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_businessimpact_severity_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_businessimpact_severity_type_indexes_,
                      _xsd_businessimpact_severity_type_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_businessimpact_severity_type_indexes_ + 6 || _xsd_businessimpact_severity_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const businessimpact_severity_type::
  _xsd_businessimpact_severity_type_literals_[6] =
  {
    "none",
    "low",
    "medium",
    "high",
    "unknown",
    "ext-value"
  };

  const businessimpact_severity_type::value businessimpact_severity_type::
  _xsd_businessimpact_severity_type_indexes_[6] =
  {
    ::iodef_2_0::businessimpact_severity_type::ext_value,
    ::iodef_2_0::businessimpact_severity_type::high,
    ::iodef_2_0::businessimpact_severity_type::low,
    ::iodef_2_0::businessimpact_severity_type::medium,
    ::iodef_2_0::businessimpact_severity_type::none,
    ::iodef_2_0::businessimpact_severity_type::unknown
  };

  // businessimpact_type_type
  //

  businessimpact_type_type::
  businessimpact_type_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_businessimpact_type_type_convert ();
  }

  businessimpact_type_type::
  businessimpact_type_type (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_businessimpact_type_type_convert ();
  }

  businessimpact_type_type::
  businessimpact_type_type (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_businessimpact_type_type_convert ();
  }

  businessimpact_type_type* businessimpact_type_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class businessimpact_type_type (*this, f, c);
  }

  businessimpact_type_type::value businessimpact_type_type::
  _xsd_businessimpact_type_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_businessimpact_type_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_businessimpact_type_type_indexes_,
                      _xsd_businessimpact_type_type_indexes_ + 13,
                      *this,
                      c));

    if (i == _xsd_businessimpact_type_type_indexes_ + 13 || _xsd_businessimpact_type_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const businessimpact_type_type::
  _xsd_businessimpact_type_type_literals_[13] =
  {
    "breach-proprietary",
    "breach-privacy",
    "breach-credential",
    "loss-of-integrity",
    "loss-of-service",
    "theft-financial",
    "theft-service",
    "degraded-reputation",
    "asset-damage",
    "asset-manipulation",
    "legal",
    "extortion",
    "ext-value"
  };

  const businessimpact_type_type::value businessimpact_type_type::
  _xsd_businessimpact_type_type_indexes_[13] =
  {
    ::iodef_2_0::businessimpact_type_type::asset_damage,
    ::iodef_2_0::businessimpact_type_type::asset_manipulation,
    ::iodef_2_0::businessimpact_type_type::breach_credential,
    ::iodef_2_0::businessimpact_type_type::breach_privacy,
    ::iodef_2_0::businessimpact_type_type::breach_proprietary,
    ::iodef_2_0::businessimpact_type_type::degraded_reputation,
    ::iodef_2_0::businessimpact_type_type::ext_value,
    ::iodef_2_0::businessimpact_type_type::extortion,
    ::iodef_2_0::businessimpact_type_type::legal,
    ::iodef_2_0::businessimpact_type_type::loss_of_integrity,
    ::iodef_2_0::businessimpact_type_type::loss_of_service,
    ::iodef_2_0::businessimpact_type_type::theft_financial,
    ::iodef_2_0::businessimpact_type_type::theft_service
  };

  // timeimpact_metric_type
  //

  timeimpact_metric_type::
  timeimpact_metric_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_timeimpact_metric_type_convert ();
  }

  timeimpact_metric_type::
  timeimpact_metric_type (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_timeimpact_metric_type_convert ();
  }

  timeimpact_metric_type::
  timeimpact_metric_type (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_timeimpact_metric_type_convert ();
  }

  timeimpact_metric_type* timeimpact_metric_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class timeimpact_metric_type (*this, f, c);
  }

  timeimpact_metric_type::value timeimpact_metric_type::
  _xsd_timeimpact_metric_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_timeimpact_metric_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_timeimpact_metric_type_indexes_,
                      _xsd_timeimpact_metric_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_timeimpact_metric_type_indexes_ + 4 || _xsd_timeimpact_metric_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const timeimpact_metric_type::
  _xsd_timeimpact_metric_type_literals_[4] =
  {
    "labor",
    "elapsed",
    "downtime",
    "ext-value"
  };

  const timeimpact_metric_type::value timeimpact_metric_type::
  _xsd_timeimpact_metric_type_indexes_[4] =
  {
    ::iodef_2_0::timeimpact_metric_type::downtime,
    ::iodef_2_0::timeimpact_metric_type::elapsed,
    ::iodef_2_0::timeimpact_metric_type::ext_value,
    ::iodef_2_0::timeimpact_metric_type::labor
  };

  // confidence_rating_type
  //

  confidence_rating_type::
  confidence_rating_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_confidence_rating_type_convert ();
  }

  confidence_rating_type::
  confidence_rating_type (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_confidence_rating_type_convert ();
  }

  confidence_rating_type::
  confidence_rating_type (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_confidence_rating_type_convert ();
  }

  confidence_rating_type* confidence_rating_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class confidence_rating_type (*this, f, c);
  }

  confidence_rating_type::value confidence_rating_type::
  _xsd_confidence_rating_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_confidence_rating_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_confidence_rating_type_indexes_,
                      _xsd_confidence_rating_type_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_confidence_rating_type_indexes_ + 5 || _xsd_confidence_rating_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const confidence_rating_type::
  _xsd_confidence_rating_type_literals_[5] =
  {
    "low",
    "medium",
    "high",
    "numeric",
    "unknown"
  };

  const confidence_rating_type::value confidence_rating_type::
  _xsd_confidence_rating_type_indexes_[5] =
  {
    ::iodef_2_0::confidence_rating_type::high,
    ::iodef_2_0::confidence_rating_type::low,
    ::iodef_2_0::confidence_rating_type::medium,
    ::iodef_2_0::confidence_rating_type::numeric,
    ::iodef_2_0::confidence_rating_type::unknown
  };

  // system_category_type
  //

  system_category_type::
  system_category_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_system_category_type_convert ();
  }

  system_category_type::
  system_category_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_system_category_type_convert ();
  }

  system_category_type::
  system_category_type (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_system_category_type_convert ();
  }

  system_category_type* system_category_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system_category_type (*this, f, c);
  }

  system_category_type::value system_category_type::
  _xsd_system_category_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_system_category_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_system_category_type_indexes_,
                      _xsd_system_category_type_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_system_category_type_indexes_ + 6 || _xsd_system_category_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const system_category_type::
  _xsd_system_category_type_literals_[6] =
  {
    "source",
    "target",
    "intermediate",
    "sensor",
    "infrastructure",
    "ext-value"
  };

  const system_category_type::value system_category_type::
  _xsd_system_category_type_indexes_[6] =
  {
    ::iodef_2_0::system_category_type::ext_value,
    ::iodef_2_0::system_category_type::infrastructure,
    ::iodef_2_0::system_category_type::intermediate,
    ::iodef_2_0::system_category_type::sensor,
    ::iodef_2_0::system_category_type::source,
    ::iodef_2_0::system_category_type::target
  };

  // system_ownership_type
  //

  system_ownership_type::
  system_ownership_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_system_ownership_type_convert ();
  }

  system_ownership_type::
  system_ownership_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_system_ownership_type_convert ();
  }

  system_ownership_type::
  system_ownership_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_system_ownership_type_convert ();
  }

  system_ownership_type* system_ownership_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system_ownership_type (*this, f, c);
  }

  system_ownership_type::value system_ownership_type::
  _xsd_system_ownership_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_system_ownership_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_system_ownership_type_indexes_,
                      _xsd_system_ownership_type_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_system_ownership_type_indexes_ + 7 || _xsd_system_ownership_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const system_ownership_type::
  _xsd_system_ownership_type_literals_[7] =
  {
    "organization",
    "personal",
    "partner",
    "customer",
    "no-relationship",
    "unknown",
    "ext-value"
  };

  const system_ownership_type::value system_ownership_type::
  _xsd_system_ownership_type_indexes_[7] =
  {
    ::iodef_2_0::system_ownership_type::customer,
    ::iodef_2_0::system_ownership_type::ext_value,
    ::iodef_2_0::system_ownership_type::no_relationship,
    ::iodef_2_0::system_ownership_type::organization,
    ::iodef_2_0::system_ownership_type::partner,
    ::iodef_2_0::system_ownership_type::personal,
    ::iodef_2_0::system_ownership_type::unknown
  };

  // address_category_type
  //

  address_category_type::
  address_category_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_address_category_type_convert ();
  }

  address_category_type::
  address_category_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_address_category_type_convert ();
  }

  address_category_type::
  address_category_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_address_category_type_convert ();
  }

  address_category_type* address_category_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class address_category_type (*this, f, c);
  }

  address_category_type::value address_category_type::
  _xsd_address_category_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_address_category_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_address_category_type_indexes_,
                      _xsd_address_category_type_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_address_category_type_indexes_ + 12 || _xsd_address_category_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const address_category_type::
  _xsd_address_category_type_literals_[12] =
  {
    "asn",
    "atm",
    "e-mail",
    "mac",
    "ipv4-addr",
    "ipv4-net",
    "ipv4-net-mask",
    "ipv6-addr",
    "ipv6-net",
    "ipv6-net-mask",
    "site-uri",
    "ext-value"
  };

  const address_category_type::value address_category_type::
  _xsd_address_category_type_indexes_[12] =
  {
    ::iodef_2_0::address_category_type::asn,
    ::iodef_2_0::address_category_type::atm,
    ::iodef_2_0::address_category_type::e_mail,
    ::iodef_2_0::address_category_type::ext_value,
    ::iodef_2_0::address_category_type::ipv4_addr,
    ::iodef_2_0::address_category_type::ipv4_net,
    ::iodef_2_0::address_category_type::ipv4_net_mask,
    ::iodef_2_0::address_category_type::ipv6_addr,
    ::iodef_2_0::address_category_type::ipv6_net,
    ::iodef_2_0::address_category_type::ipv6_net_mask,
    ::iodef_2_0::address_category_type::mac,
    ::iodef_2_0::address_category_type::site_uri
  };

  // noderole_category_type
  //

  noderole_category_type::
  noderole_category_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_noderole_category_type_convert ();
  }

  noderole_category_type::
  noderole_category_type (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_noderole_category_type_convert ();
  }

  noderole_category_type::
  noderole_category_type (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_noderole_category_type_convert ();
  }

  noderole_category_type* noderole_category_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class noderole_category_type (*this, f, c);
  }

  noderole_category_type::value noderole_category_type::
  _xsd_noderole_category_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_noderole_category_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_noderole_category_type_indexes_,
                      _xsd_noderole_category_type_indexes_ + 54,
                      *this,
                      c));

    if (i == _xsd_noderole_category_type_indexes_ + 54 || _xsd_noderole_category_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const noderole_category_type::
  _xsd_noderole_category_type_literals_[54] =
  {
    "client",
    "client-enterprise",
    "client-partner",
    "client-remote",
    "client-kiosk",
    "client-mobile",
    "server-internal",
    "server-public",
    "www",
    "mail",
    "webmail",
    "messaging",
    "streaming",
    "voice",
    "file",
    "ftp",
    "p2p",
    "name",
    "directory",
    "credential",
    "print",
    "application",
    "database",
    "backup",
    "dhcp",
    "assessment",
    "source-control",
    "config-management",
    "monitoring",
    "infra",
    "infra-firewall",
    "infra-router",
    "infra-switch",
    "camera",
    "proxy",
    "remote-access",
    "log",
    "virtualization",
    "pos",
    "scada",
    "scada-supervisory",
    "sinkhole",
    "honeypot",
    "anonymization",
    "c2-server",
    "malware-distribution",
    "drop-server",
    "hop-point",
    "reflector",
    "phishing-site",
    "spear-phishing-site",
    "recruiting-site",
    "fraudulent-site",
    "ext-value"
  };

  const noderole_category_type::value noderole_category_type::
  _xsd_noderole_category_type_indexes_[54] =
  {
    ::iodef_2_0::noderole_category_type::anonymization,
    ::iodef_2_0::noderole_category_type::application,
    ::iodef_2_0::noderole_category_type::assessment,
    ::iodef_2_0::noderole_category_type::backup,
    ::iodef_2_0::noderole_category_type::c2_server,
    ::iodef_2_0::noderole_category_type::camera,
    ::iodef_2_0::noderole_category_type::client,
    ::iodef_2_0::noderole_category_type::client_enterprise,
    ::iodef_2_0::noderole_category_type::client_kiosk,
    ::iodef_2_0::noderole_category_type::client_mobile,
    ::iodef_2_0::noderole_category_type::client_partner,
    ::iodef_2_0::noderole_category_type::client_remote,
    ::iodef_2_0::noderole_category_type::config_management,
    ::iodef_2_0::noderole_category_type::credential,
    ::iodef_2_0::noderole_category_type::database,
    ::iodef_2_0::noderole_category_type::dhcp,
    ::iodef_2_0::noderole_category_type::directory,
    ::iodef_2_0::noderole_category_type::drop_server,
    ::iodef_2_0::noderole_category_type::ext_value,
    ::iodef_2_0::noderole_category_type::file,
    ::iodef_2_0::noderole_category_type::fraudulent_site,
    ::iodef_2_0::noderole_category_type::ftp,
    ::iodef_2_0::noderole_category_type::honeypot,
    ::iodef_2_0::noderole_category_type::hop_point,
    ::iodef_2_0::noderole_category_type::infra,
    ::iodef_2_0::noderole_category_type::infra_firewall,
    ::iodef_2_0::noderole_category_type::infra_router,
    ::iodef_2_0::noderole_category_type::infra_switch,
    ::iodef_2_0::noderole_category_type::log,
    ::iodef_2_0::noderole_category_type::mail,
    ::iodef_2_0::noderole_category_type::malware_distribution,
    ::iodef_2_0::noderole_category_type::messaging,
    ::iodef_2_0::noderole_category_type::monitoring,
    ::iodef_2_0::noderole_category_type::name,
    ::iodef_2_0::noderole_category_type::p2p,
    ::iodef_2_0::noderole_category_type::phishing_site,
    ::iodef_2_0::noderole_category_type::pos,
    ::iodef_2_0::noderole_category_type::print,
    ::iodef_2_0::noderole_category_type::proxy,
    ::iodef_2_0::noderole_category_type::recruiting_site,
    ::iodef_2_0::noderole_category_type::reflector,
    ::iodef_2_0::noderole_category_type::remote_access,
    ::iodef_2_0::noderole_category_type::scada,
    ::iodef_2_0::noderole_category_type::scada_supervisory,
    ::iodef_2_0::noderole_category_type::server_internal,
    ::iodef_2_0::noderole_category_type::server_public,
    ::iodef_2_0::noderole_category_type::sinkhole,
    ::iodef_2_0::noderole_category_type::source_control,
    ::iodef_2_0::noderole_category_type::spear_phishing_site,
    ::iodef_2_0::noderole_category_type::streaming,
    ::iodef_2_0::noderole_category_type::virtualization,
    ::iodef_2_0::noderole_category_type::voice,
    ::iodef_2_0::noderole_category_type::webmail,
    ::iodef_2_0::noderole_category_type::www
  };

  // counter_type_type
  //

  counter_type_type::
  counter_type_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_counter_type_type_convert ();
  }

  counter_type_type::
  counter_type_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_counter_type_type_convert ();
  }

  counter_type_type::
  counter_type_type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_counter_type_type_convert ();
  }

  counter_type_type* counter_type_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class counter_type_type (*this, f, c);
  }

  counter_type_type::value counter_type_type::
  _xsd_counter_type_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_counter_type_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_counter_type_type_indexes_,
                      _xsd_counter_type_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_counter_type_type_indexes_ + 4 || _xsd_counter_type_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const counter_type_type::
  _xsd_counter_type_type_literals_[4] =
  {
    "counter",
    "rate",
    "average",
    "ext-value"
  };

  const counter_type_type::value counter_type_type::
  _xsd_counter_type_type_indexes_[4] =
  {
    ::iodef_2_0::counter_type_type::average,
    ::iodef_2_0::counter_type_type::counter,
    ::iodef_2_0::counter_type_type::ext_value,
    ::iodef_2_0::counter_type_type::rate
  };

  // counter_unit_type
  //

  counter_unit_type::
  counter_unit_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_counter_unit_type_convert ();
  }

  counter_unit_type::
  counter_unit_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_counter_unit_type_convert ();
  }

  counter_unit_type::
  counter_unit_type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_counter_unit_type_convert ();
  }

  counter_unit_type* counter_unit_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class counter_unit_type (*this, f, c);
  }

  counter_unit_type::value counter_unit_type::
  _xsd_counter_unit_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_counter_unit_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_counter_unit_type_indexes_,
                      _xsd_counter_unit_type_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_counter_unit_type_indexes_ + 12 || _xsd_counter_unit_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const counter_unit_type::
  _xsd_counter_unit_type_literals_[12] =
  {
    "byte",
    "mbit",
    "packet",
    "flow",
    "session",
    "event",
    "alert",
    "message",
    "host",
    "site",
    "organization",
    "ext-value"
  };

  const counter_unit_type::value counter_unit_type::
  _xsd_counter_unit_type_indexes_[12] =
  {
    ::iodef_2_0::counter_unit_type::alert,
    ::iodef_2_0::counter_unit_type::byte,
    ::iodef_2_0::counter_unit_type::event,
    ::iodef_2_0::counter_unit_type::ext_value,
    ::iodef_2_0::counter_unit_type::flow,
    ::iodef_2_0::counter_unit_type::host,
    ::iodef_2_0::counter_unit_type::mbit,
    ::iodef_2_0::counter_unit_type::message,
    ::iodef_2_0::counter_unit_type::organization,
    ::iodef_2_0::counter_unit_type::packet,
    ::iodef_2_0::counter_unit_type::session,
    ::iodef_2_0::counter_unit_type::site
  };

  // domaindata_system_status_type
  //

  domaindata_system_status_type::
  domaindata_system_status_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_domaindata_system_status_type_convert ();
  }

  domaindata_system_status_type::
  domaindata_system_status_type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_domaindata_system_status_type_convert ();
  }

  domaindata_system_status_type::
  domaindata_system_status_type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_domaindata_system_status_type_convert ();
  }

  domaindata_system_status_type* domaindata_system_status_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class domaindata_system_status_type (*this, f, c);
  }

  domaindata_system_status_type::value domaindata_system_status_type::
  _xsd_domaindata_system_status_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_domaindata_system_status_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_domaindata_system_status_type_indexes_,
                      _xsd_domaindata_system_status_type_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_domaindata_system_status_type_indexes_ + 6 || _xsd_domaindata_system_status_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const domaindata_system_status_type::
  _xsd_domaindata_system_status_type_literals_[6] =
  {
    "spoofed",
    "fraudulent",
    "innocent-hacked",
    "innocent-hijacked",
    "unknown",
    "ext-value"
  };

  const domaindata_system_status_type::value domaindata_system_status_type::
  _xsd_domaindata_system_status_type_indexes_[6] =
  {
    ::iodef_2_0::domaindata_system_status_type::ext_value,
    ::iodef_2_0::domaindata_system_status_type::fraudulent,
    ::iodef_2_0::domaindata_system_status_type::innocent_hacked,
    ::iodef_2_0::domaindata_system_status_type::innocent_hijacked,
    ::iodef_2_0::domaindata_system_status_type::spoofed,
    ::iodef_2_0::domaindata_system_status_type::unknown
  };

  // domaindata_domain_status_type
  //

  domaindata_domain_status_type::
  domaindata_domain_status_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_domaindata_domain_status_type_convert ();
  }

  domaindata_domain_status_type::
  domaindata_domain_status_type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_domaindata_domain_status_type_convert ();
  }

  domaindata_domain_status_type::
  domaindata_domain_status_type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_domaindata_domain_status_type_convert ();
  }

  domaindata_domain_status_type* domaindata_domain_status_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class domaindata_domain_status_type (*this, f, c);
  }

  domaindata_domain_status_type::value domaindata_domain_status_type::
  _xsd_domaindata_domain_status_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_domaindata_domain_status_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_domaindata_domain_status_type_indexes_,
                      _xsd_domaindata_domain_status_type_indexes_ + 11,
                      *this,
                      c));

    if (i == _xsd_domaindata_domain_status_type_indexes_ + 11 || _xsd_domaindata_domain_status_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const domaindata_domain_status_type::
  _xsd_domaindata_domain_status_type_literals_[11] =
  {
    "reservedDelegation",
    "assignedAndActive",
    "assignedAndInactive",
    "assignedAndOnHold",
    "revoked",
    "transferPending",
    "registryLock",
    "registrarLock",
    "other",
    "unknown",
    "ext-value"
  };

  const domaindata_domain_status_type::value domaindata_domain_status_type::
  _xsd_domaindata_domain_status_type_indexes_[11] =
  {
    ::iodef_2_0::domaindata_domain_status_type::assignedAndActive,
    ::iodef_2_0::domaindata_domain_status_type::assignedAndInactive,
    ::iodef_2_0::domaindata_domain_status_type::assignedAndOnHold,
    ::iodef_2_0::domaindata_domain_status_type::ext_value,
    ::iodef_2_0::domaindata_domain_status_type::other,
    ::iodef_2_0::domaindata_domain_status_type::registrarLock,
    ::iodef_2_0::domaindata_domain_status_type::registryLock,
    ::iodef_2_0::domaindata_domain_status_type::reservedDelegation,
    ::iodef_2_0::domaindata_domain_status_type::revoked,
    ::iodef_2_0::domaindata_domain_status_type::transferPending,
    ::iodef_2_0::domaindata_domain_status_type::unknown
  };

  // recordpattern_type_type
  //

  recordpattern_type_type::
  recordpattern_type_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_recordpattern_type_type_convert ();
  }

  recordpattern_type_type::
  recordpattern_type_type (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_recordpattern_type_type_convert ();
  }

  recordpattern_type_type::
  recordpattern_type_type (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_recordpattern_type_type_convert ();
  }

  recordpattern_type_type* recordpattern_type_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class recordpattern_type_type (*this, f, c);
  }

  recordpattern_type_type::value recordpattern_type_type::
  _xsd_recordpattern_type_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_recordpattern_type_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_recordpattern_type_type_indexes_,
                      _xsd_recordpattern_type_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_recordpattern_type_type_indexes_ + 4 || _xsd_recordpattern_type_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const recordpattern_type_type::
  _xsd_recordpattern_type_type_literals_[4] =
  {
    "regex",
    "binary",
    "xpath",
    "ext-value"
  };

  const recordpattern_type_type::value recordpattern_type_type::
  _xsd_recordpattern_type_type_indexes_[4] =
  {
    ::iodef_2_0::recordpattern_type_type::binary,
    ::iodef_2_0::recordpattern_type_type::ext_value,
    ::iodef_2_0::recordpattern_type_type::regex,
    ::iodef_2_0::recordpattern_type_type::xpath
  };

  // recordpattern_offsetunit_type
  //

  recordpattern_offsetunit_type::
  recordpattern_offsetunit_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_recordpattern_offsetunit_type_convert ();
  }

  recordpattern_offsetunit_type::
  recordpattern_offsetunit_type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_recordpattern_offsetunit_type_convert ();
  }

  recordpattern_offsetunit_type::
  recordpattern_offsetunit_type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_recordpattern_offsetunit_type_convert ();
  }

  recordpattern_offsetunit_type* recordpattern_offsetunit_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class recordpattern_offsetunit_type (*this, f, c);
  }

  recordpattern_offsetunit_type::value recordpattern_offsetunit_type::
  _xsd_recordpattern_offsetunit_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_recordpattern_offsetunit_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_recordpattern_offsetunit_type_indexes_,
                      _xsd_recordpattern_offsetunit_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_recordpattern_offsetunit_type_indexes_ + 3 || _xsd_recordpattern_offsetunit_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const recordpattern_offsetunit_type::
  _xsd_recordpattern_offsetunit_type_literals_[3] =
  {
    "line",
    "byte",
    "ext-value"
  };

  const recordpattern_offsetunit_type::value recordpattern_offsetunit_type::
  _xsd_recordpattern_offsetunit_type_indexes_[3] =
  {
    ::iodef_2_0::recordpattern_offsetunit_type::byte,
    ::iodef_2_0::recordpattern_offsetunit_type::ext_value,
    ::iodef_2_0::recordpattern_offsetunit_type::line
  };

  // key_registryaction_type
  //

  key_registryaction_type::
  key_registryaction_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_key_registryaction_type_convert ();
  }

  key_registryaction_type::
  key_registryaction_type (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_key_registryaction_type_convert ();
  }

  key_registryaction_type::
  key_registryaction_type (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_key_registryaction_type_convert ();
  }

  key_registryaction_type* key_registryaction_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class key_registryaction_type (*this, f, c);
  }

  key_registryaction_type::value key_registryaction_type::
  _xsd_key_registryaction_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_key_registryaction_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_key_registryaction_type_indexes_,
                      _xsd_key_registryaction_type_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_key_registryaction_type_indexes_ + 7 || _xsd_key_registryaction_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const key_registryaction_type::
  _xsd_key_registryaction_type_literals_[7] =
  {
    "add-key",
    "add-value",
    "delete-key",
    "delete-value",
    "modify-key",
    "modify-value",
    "ext-value"
  };

  const key_registryaction_type::value key_registryaction_type::
  _xsd_key_registryaction_type_indexes_[7] =
  {
    ::iodef_2_0::key_registryaction_type::add_key,
    ::iodef_2_0::key_registryaction_type::add_value,
    ::iodef_2_0::key_registryaction_type::delete_key,
    ::iodef_2_0::key_registryaction_type::delete_value,
    ::iodef_2_0::key_registryaction_type::ext_value,
    ::iodef_2_0::key_registryaction_type::modify_key,
    ::iodef_2_0::key_registryaction_type::modify_value
  };

  // hashdata_scope_type
  //

  hashdata_scope_type::
  hashdata_scope_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_hashdata_scope_type_convert ();
  }

  hashdata_scope_type::
  hashdata_scope_type (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_hashdata_scope_type_convert ();
  }

  hashdata_scope_type::
  hashdata_scope_type (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_hashdata_scope_type_convert ();
  }

  hashdata_scope_type* hashdata_scope_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hashdata_scope_type (*this, f, c);
  }

  hashdata_scope_type::value hashdata_scope_type::
  _xsd_hashdata_scope_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_hashdata_scope_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_hashdata_scope_type_indexes_,
                      _xsd_hashdata_scope_type_indexes_ + 9,
                      *this,
                      c));

    if (i == _xsd_hashdata_scope_type_indexes_ + 9 || _xsd_hashdata_scope_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const hashdata_scope_type::
  _xsd_hashdata_scope_type_literals_[9] =
  {
    "file-contents",
    "file-pe-section",
    "file-pe-iat",
    "file-pe-resource",
    "file-pdf-object",
    "email-hash",
    "email-headers-hash",
    "email-body-hash",
    "ext-value"
  };

  const hashdata_scope_type::value hashdata_scope_type::
  _xsd_hashdata_scope_type_indexes_[9] =
  {
    ::iodef_2_0::hashdata_scope_type::email_body_hash,
    ::iodef_2_0::hashdata_scope_type::email_hash,
    ::iodef_2_0::hashdata_scope_type::email_headers_hash,
    ::iodef_2_0::hashdata_scope_type::ext_value,
    ::iodef_2_0::hashdata_scope_type::file_contents,
    ::iodef_2_0::hashdata_scope_type::file_pdf_object,
    ::iodef_2_0::hashdata_scope_type::file_pe_iat,
    ::iodef_2_0::hashdata_scope_type::file_pe_resource,
    ::iodef_2_0::hashdata_scope_type::file_pe_section
  };

  // SoftwareType
  //

  SoftwareType::
  SoftwareType ()
  : ::xml_schema::type (),
    SoftwareReference_ (this),
    URL_ (this),
    Description_ (this)
  {
  }

  SoftwareType::
  SoftwareType (const SoftwareType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SoftwareReference_ (x.SoftwareReference_, f, this),
    URL_ (x.URL_, f, this),
    Description_ (x.Description_, f, this)
  {
  }

  SoftwareType::
  SoftwareType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SoftwareReference_ (this),
    URL_ (this),
    Description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SoftwareType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SoftwareReference
      //
      if (n.name () == "SoftwareReference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< SoftwareReference_type > r (
          SoftwareReference_traits::create (i, f, this));

        if (!this->SoftwareReference_)
        {
          this->SoftwareReference_.set (r);
          continue;
        }
      }

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        this->URL_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      break;
    }
  }

  SoftwareType* SoftwareType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SoftwareType (*this, f, c);
  }

  SoftwareType& SoftwareType::
  operator= (const SoftwareType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SoftwareReference_ = x.SoftwareReference_;
      this->URL_ = x.URL_;
      this->Description_ = x.Description_;
    }

    return *this;
  }

  SoftwareType::
  ~SoftwareType ()
  {
  }

  // softwarereference_spec_name_type
  //

  softwarereference_spec_name_type::
  softwarereference_spec_name_type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_softwarereference_spec_name_type_convert ();
  }

  softwarereference_spec_name_type::
  softwarereference_spec_name_type (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_softwarereference_spec_name_type_convert ();
  }

  softwarereference_spec_name_type::
  softwarereference_spec_name_type (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_softwarereference_spec_name_type_convert ();
  }

  softwarereference_spec_name_type* softwarereference_spec_name_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class softwarereference_spec_name_type (*this, f, c);
  }

  softwarereference_spec_name_type::value softwarereference_spec_name_type::
  _xsd_softwarereference_spec_name_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_softwarereference_spec_name_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_softwarereference_spec_name_type_indexes_,
                      _xsd_softwarereference_spec_name_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_softwarereference_spec_name_type_indexes_ + 4 || _xsd_softwarereference_spec_name_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const softwarereference_spec_name_type::
  _xsd_softwarereference_spec_name_type_literals_[4] =
  {
    "custom",
    "cpe",
    "swid",
    "ext-value"
  };

  const softwarereference_spec_name_type::value softwarereference_spec_name_type::
  _xsd_softwarereference_spec_name_type_indexes_[4] =
  {
    ::iodef_2_0::softwarereference_spec_name_type::cpe,
    ::iodef_2_0::softwarereference_spec_name_type::custom,
    ::iodef_2_0::softwarereference_spec_name_type::ext_value,
    ::iodef_2_0::softwarereference_spec_name_type::swid
  };

  // softwarereference_dtype_type
  //

  softwarereference_dtype_type::
  softwarereference_dtype_type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_softwarereference_dtype_type_convert ();
  }

  softwarereference_dtype_type::
  softwarereference_dtype_type (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_softwarereference_dtype_type_convert ();
  }

  softwarereference_dtype_type::
  softwarereference_dtype_type (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_softwarereference_dtype_type_convert ();
  }

  softwarereference_dtype_type* softwarereference_dtype_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class softwarereference_dtype_type (*this, f, c);
  }

  softwarereference_dtype_type::value softwarereference_dtype_type::
  _xsd_softwarereference_dtype_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_softwarereference_dtype_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_softwarereference_dtype_type_indexes_,
                      _xsd_softwarereference_dtype_type_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_softwarereference_dtype_type_indexes_ + 6 || _xsd_softwarereference_dtype_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const softwarereference_dtype_type::
  _xsd_softwarereference_dtype_type_literals_[6] =
  {
    "bytes",
    "integer",
    "real",
    "string",
    "xml",
    "ext-value"
  };

  const softwarereference_dtype_type::value softwarereference_dtype_type::
  _xsd_softwarereference_dtype_type_indexes_[6] =
  {
    ::iodef_2_0::softwarereference_dtype_type::bytes,
    ::iodef_2_0::softwarereference_dtype_type::ext_value,
    ::iodef_2_0::softwarereference_dtype_type::integer,
    ::iodef_2_0::softwarereference_dtype_type::real,
    ::iodef_2_0::softwarereference_dtype_type::string,
    ::iodef_2_0::softwarereference_dtype_type::xml
  };

  // observable_type_type
  //

  observable_type_type::
  observable_type_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_observable_type_type_convert ();
  }

  observable_type_type::
  observable_type_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_observable_type_type_convert ();
  }

  observable_type_type::
  observable_type_type (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_observable_type_type_convert ();
  }

  observable_type_type* observable_type_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class observable_type_type (*this, f, c);
  }

  observable_type_type::value observable_type_type::
  _xsd_observable_type_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_observable_type_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_observable_type_type_indexes_,
                      _xsd_observable_type_type_indexes_ + 28,
                      *this,
                      c));

    if (i == _xsd_observable_type_type_indexes_ + 28 || _xsd_observable_type_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const observable_type_type::
  _xsd_observable_type_type_literals_[28] =
  {
    "asn",
    "atm",
    "e-mail",
    "ipv4-addr",
    "ipv4-net",
    "ipv4-net-mask",
    "ipv6-addr",
    "ipv6-net",
    "ipv6-net-mask",
    "mac",
    "site-uri",
    "fqdn",
    "doman-name",
    "domain-to-ipv4",
    "domain-to-ipv6",
    "domain-to-ipv4-timestamp",
    "domain-to-ipv6-timestamp",
    "ipv4-port",
    "ipv6-port",
    "windows-reg-key",
    "file-hash",
    "email-x-mailer",
    "email-subject",
    "http-user-agent",
    "http-request-uri",
    "mutex",
    "file-path",
    "user-name"
  };

  const observable_type_type::value observable_type_type::
  _xsd_observable_type_type_indexes_[28] =
  {
    ::iodef_2_0::observable_type_type::asn,
    ::iodef_2_0::observable_type_type::atm,
    ::iodef_2_0::observable_type_type::domain_to_ipv4,
    ::iodef_2_0::observable_type_type::domain_to_ipv4_timestamp,
    ::iodef_2_0::observable_type_type::domain_to_ipv6,
    ::iodef_2_0::observable_type_type::domain_to_ipv6_timestamp,
    ::iodef_2_0::observable_type_type::doman_name,
    ::iodef_2_0::observable_type_type::e_mail,
    ::iodef_2_0::observable_type_type::email_subject,
    ::iodef_2_0::observable_type_type::email_x_mailer,
    ::iodef_2_0::observable_type_type::file_hash,
    ::iodef_2_0::observable_type_type::file_path,
    ::iodef_2_0::observable_type_type::fqdn,
    ::iodef_2_0::observable_type_type::http_request_uri,
    ::iodef_2_0::observable_type_type::http_user_agent,
    ::iodef_2_0::observable_type_type::ipv4_addr,
    ::iodef_2_0::observable_type_type::ipv4_net,
    ::iodef_2_0::observable_type_type::ipv4_net_mask,
    ::iodef_2_0::observable_type_type::ipv4_port,
    ::iodef_2_0::observable_type_type::ipv6_addr,
    ::iodef_2_0::observable_type_type::ipv6_net,
    ::iodef_2_0::observable_type_type::ipv6_net_mask,
    ::iodef_2_0::observable_type_type::ipv6_port,
    ::iodef_2_0::observable_type_type::mac,
    ::iodef_2_0::observable_type_type::mutex,
    ::iodef_2_0::observable_type_type::site_uri,
    ::iodef_2_0::observable_type_type::user_name,
    ::iodef_2_0::observable_type_type::windows_reg_key
  };

  // indicatorexpression_operator_type
  //

  indicatorexpression_operator_type::
  indicatorexpression_operator_type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_indicatorexpression_operator_type_convert ();
  }

  indicatorexpression_operator_type::
  indicatorexpression_operator_type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_indicatorexpression_operator_type_convert ();
  }

  indicatorexpression_operator_type::
  indicatorexpression_operator_type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_indicatorexpression_operator_type_convert ();
  }

  indicatorexpression_operator_type* indicatorexpression_operator_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class indicatorexpression_operator_type (*this, f, c);
  }

  indicatorexpression_operator_type::value indicatorexpression_operator_type::
  _xsd_indicatorexpression_operator_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_indicatorexpression_operator_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_indicatorexpression_operator_type_indexes_,
                      _xsd_indicatorexpression_operator_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_indicatorexpression_operator_type_indexes_ + 4 || _xsd_indicatorexpression_operator_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const indicatorexpression_operator_type::
  _xsd_indicatorexpression_operator_type_literals_[4] =
  {
    "not",
    "and",
    "or",
    "xor"
  };

  const indicatorexpression_operator_type::value indicatorexpression_operator_type::
  _xsd_indicatorexpression_operator_type_indexes_[4] =
  {
    ::iodef_2_0::indicatorexpression_operator_type::and_,
    ::iodef_2_0::indicatorexpression_operator_type::not_,
    ::iodef_2_0::indicatorexpression_operator_type::or_,
    ::iodef_2_0::indicatorexpression_operator_type::xor_
  };

  // PositiveFloatType
  //

  PositiveFloatType::
  PositiveFloatType (const ::xml_schema::float_& _xsd_float__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base)
  {
  }

  PositiveFloatType::
  PositiveFloatType (const PositiveFloatType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  PositiveFloatType::
  PositiveFloatType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  PositiveFloatType::
  PositiveFloatType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  PositiveFloatType::
  PositiveFloatType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  PositiveFloatType* PositiveFloatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PositiveFloatType (*this, f, c);
  }

  PositiveFloatType::
  ~PositiveFloatType ()
  {
  }

  // PortlistType
  //

  PortlistType::
  PortlistType ()
  : ::xml_schema::string ()
  {
  }

  PortlistType::
  PortlistType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PortlistType::
  PortlistType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PortlistType::
  PortlistType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PortlistType::
  PortlistType (const PortlistType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  PortlistType::
  PortlistType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  PortlistType::
  PortlistType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  PortlistType::
  PortlistType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  PortlistType* PortlistType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PortlistType (*this, f, c);
  }

  PortlistType::
  ~PortlistType ()
  {
  }

  // ExtensionType
  //

  ExtensionType::
  ExtensionType (const dtype_type& dtype)
  : ::xml_schema::type (),
    dtype_ (dtype, this),
    meaning_ (this),
    formatid_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  ExtensionType::
  ExtensionType (const ExtensionType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dtype_ (x.dtype_, f, this),
    meaning_ (x.meaning_, f, this),
    formatid_ (x.formatid_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  ExtensionType::
  ExtensionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dtype_ (this),
    meaning_ (this),
    formatid_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ExtensionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dtype" && n.namespace_ ().empty ())
      {
        this->dtype_.set (dtype_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        this->meaning_.set (meaning_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "formatid" && n.namespace_ ().empty ())
      {
        this->formatid_.set (formatid_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }

    if (!dtype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dtype",
        "");
    }
  }

  ExtensionType* ExtensionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExtensionType (*this, f, c);
  }

  ExtensionType& ExtensionType::
  operator= (const ExtensionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dtype_ = x.dtype_;
      this->meaning_ = x.meaning_;
      this->formatid_ = x.formatid_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  ExtensionType::
  ~ExtensionType ()
  {
  }

  // ApplicationHeaderType
  //

  ApplicationHeaderType::
  ApplicationHeaderType (const field_type& field,
                         const dtype_type& dtype)
  : ::xml_schema::type (),
    proto_ (this),
    proto_name_ (this),
    field_ (field, this),
    dtype_ (dtype, this),
    observable_id_ (this)
  {
  }

  ApplicationHeaderType::
  ApplicationHeaderType (const ApplicationHeaderType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    proto_ (x.proto_, f, this),
    proto_name_ (x.proto_name_, f, this),
    field_ (x.field_, f, this),
    dtype_ (x.dtype_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  ApplicationHeaderType::
  ApplicationHeaderType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    proto_ (this),
    proto_name_ (this),
    field_ (this),
    dtype_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ApplicationHeaderType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "proto" && n.namespace_ ().empty ())
      {
        this->proto_.set (proto_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "proto-name" && n.namespace_ ().empty ())
      {
        this->proto_name_.set (proto_name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "field" && n.namespace_ ().empty ())
      {
        this->field_.set (field_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dtype" && n.namespace_ ().empty ())
      {
        this->dtype_.set (dtype_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!field_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field",
        "");
    }

    if (!dtype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dtype",
        "");
    }
  }

  ApplicationHeaderType* ApplicationHeaderType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ApplicationHeaderType (*this, f, c);
  }

  ApplicationHeaderType& ApplicationHeaderType::
  operator= (const ApplicationHeaderType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->proto_ = x.proto_;
      this->proto_name_ = x.proto_name_;
      this->field_ = x.field_;
      this->dtype_ = x.dtype_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  ApplicationHeaderType::
  ~ApplicationHeaderType ()
  {
  }

  // yes_no_type
  //

  yes_no_type::
  yes_no_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_yes_no_type_convert ();
  }

  yes_no_type::
  yes_no_type (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_yes_no_type_convert ();
  }

  yes_no_type::
  yes_no_type (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_yes_no_type_convert ();
  }

  yes_no_type* yes_no_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class yes_no_type (*this, f, c);
  }

  yes_no_type::value yes_no_type::
  _xsd_yes_no_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yes_no_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_yes_no_type_indexes_,
                      _xsd_yes_no_type_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_yes_no_type_indexes_ + 2 || _xsd_yes_no_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const yes_no_type::
  _xsd_yes_no_type_literals_[2] =
  {
    "yes",
    "no"
  };

  const yes_no_type::value yes_no_type::
  _xsd_yes_no_type_indexes_[2] =
  {
    ::iodef_2_0::yes_no_type::no,
    ::iodef_2_0::yes_no_type::yes
  };

  // yes_no_unknown_type
  //

  yes_no_unknown_type::
  yes_no_unknown_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_yes_no_unknown_type_convert ();
  }

  yes_no_unknown_type::
  yes_no_unknown_type (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_yes_no_unknown_type_convert ();
  }

  yes_no_unknown_type::
  yes_no_unknown_type (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_yes_no_unknown_type_convert ();
  }

  yes_no_unknown_type* yes_no_unknown_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class yes_no_unknown_type (*this, f, c);
  }

  yes_no_unknown_type::value yes_no_unknown_type::
  _xsd_yes_no_unknown_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yes_no_unknown_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_yes_no_unknown_type_indexes_,
                      _xsd_yes_no_unknown_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_yes_no_unknown_type_indexes_ + 3 || _xsd_yes_no_unknown_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const yes_no_unknown_type::
  _xsd_yes_no_unknown_type_literals_[3] =
  {
    "yes",
    "no",
    "unknown"
  };

  const yes_no_unknown_type::value yes_no_unknown_type::
  _xsd_yes_no_unknown_type_indexes_[3] =
  {
    ::iodef_2_0::yes_no_unknown_type::no,
    ::iodef_2_0::yes_no_unknown_type::unknown,
    ::iodef_2_0::yes_no_unknown_type::yes
  };

  // restriction_type
  //

  restriction_type::
  restriction_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_restriction_type_convert ();
  }

  restriction_type::
  restriction_type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_restriction_type_convert ();
  }

  restriction_type::
  restriction_type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_restriction_type_convert ();
  }

  restriction_type* restriction_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class restriction_type (*this, f, c);
  }

  restriction_type::value restriction_type::
  _xsd_restriction_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_restriction_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_restriction_type_indexes_,
                      _xsd_restriction_type_indexes_ + 10,
                      *this,
                      c));

    if (i == _xsd_restriction_type_indexes_ + 10 || _xsd_restriction_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const restriction_type::
  _xsd_restriction_type_literals_[10] =
  {
    "default",
    "public",
    "partner",
    "need-to-know",
    "private",
    "white",
    "green",
    "amber",
    "red",
    "ext-value"
  };

  const restriction_type::value restriction_type::
  _xsd_restriction_type_indexes_[10] =
  {
    ::iodef_2_0::restriction_type::amber,
    ::iodef_2_0::restriction_type::default_,
    ::iodef_2_0::restriction_type::ext_value,
    ::iodef_2_0::restriction_type::green,
    ::iodef_2_0::restriction_type::need_to_know,
    ::iodef_2_0::restriction_type::partner,
    ::iodef_2_0::restriction_type::private_,
    ::iodef_2_0::restriction_type::public_,
    ::iodef_2_0::restriction_type::red,
    ::iodef_2_0::restriction_type::white
  };

  // severity_type
  //

  severity_type::
  severity_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_severity_type_convert ();
  }

  severity_type::
  severity_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_severity_type_convert ();
  }

  severity_type::
  severity_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_severity_type_convert ();
  }

  severity_type* severity_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class severity_type (*this, f, c);
  }

  severity_type::value severity_type::
  _xsd_severity_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_severity_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_severity_type_indexes_,
                      _xsd_severity_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_severity_type_indexes_ + 3 || _xsd_severity_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const severity_type::
  _xsd_severity_type_literals_[3] =
  {
    "low",
    "medium",
    "high"
  };

  const severity_type::value severity_type::
  _xsd_severity_type_indexes_[3] =
  {
    ::iodef_2_0::severity_type::high,
    ::iodef_2_0::severity_type::low,
    ::iodef_2_0::severity_type::medium
  };

  // duration_type
  //

  duration_type::
  duration_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_duration_type_convert ();
  }

  duration_type::
  duration_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_duration_type_convert ();
  }

  duration_type::
  duration_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_duration_type_convert ();
  }

  duration_type* duration_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class duration_type (*this, f, c);
  }

  duration_type::value duration_type::
  _xsd_duration_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_duration_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_duration_type_indexes_,
                      _xsd_duration_type_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_duration_type_indexes_ + 8 || _xsd_duration_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const duration_type::
  _xsd_duration_type_literals_[8] =
  {
    "second",
    "minute",
    "hour",
    "day",
    "month",
    "quarter",
    "year",
    "ext-value"
  };

  const duration_type::value duration_type::
  _xsd_duration_type_indexes_[8] =
  {
    ::iodef_2_0::duration_type::day,
    ::iodef_2_0::duration_type::ext_value,
    ::iodef_2_0::duration_type::hour,
    ::iodef_2_0::duration_type::minute,
    ::iodef_2_0::duration_type::month,
    ::iodef_2_0::duration_type::quarter,
    ::iodef_2_0::duration_type::second,
    ::iodef_2_0::duration_type::year
  };

  // action_type
  //

  action_type::
  action_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_action_type_convert ();
  }

  action_type::
  action_type (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_action_type_convert ();
  }

  action_type::
  action_type (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_action_type_convert ();
  }

  action_type* action_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class action_type (*this, f, c);
  }

  action_type::value action_type::
  _xsd_action_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_action_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_action_type_indexes_,
                      _xsd_action_type_indexes_ + 23,
                      *this,
                      c));

    if (i == _xsd_action_type_indexes_ + 23 || _xsd_action_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const action_type::
  _xsd_action_type_literals_[23] =
  {
    "nothing",
    "contact-source-site",
    "contact-target-site",
    "contact-sender",
    "investigate",
    "block-host",
    "block-network",
    "block-port",
    "rate-limit-host",
    "rate-limit-network",
    "rate-limit-port",
    "redirect-traffic",
    "honeypot",
    "upgrade-software",
    "rebuild-asset",
    "harden-asset",
    "remediate-other",
    "status-triage",
    "status-new-info",
    "watch-and-report",
    "defined-coa",
    "other",
    "ext-value"
  };

  const action_type::value action_type::
  _xsd_action_type_indexes_[23] =
  {
    ::iodef_2_0::action_type::block_host,
    ::iodef_2_0::action_type::block_network,
    ::iodef_2_0::action_type::block_port,
    ::iodef_2_0::action_type::contact_sender,
    ::iodef_2_0::action_type::contact_source_site,
    ::iodef_2_0::action_type::contact_target_site,
    ::iodef_2_0::action_type::defined_coa,
    ::iodef_2_0::action_type::ext_value,
    ::iodef_2_0::action_type::harden_asset,
    ::iodef_2_0::action_type::honeypot,
    ::iodef_2_0::action_type::investigate,
    ::iodef_2_0::action_type::nothing,
    ::iodef_2_0::action_type::other,
    ::iodef_2_0::action_type::rate_limit_host,
    ::iodef_2_0::action_type::rate_limit_network,
    ::iodef_2_0::action_type::rate_limit_port,
    ::iodef_2_0::action_type::rebuild_asset,
    ::iodef_2_0::action_type::redirect_traffic,
    ::iodef_2_0::action_type::remediate_other,
    ::iodef_2_0::action_type::status_new_info,
    ::iodef_2_0::action_type::status_triage,
    ::iodef_2_0::action_type::upgrade_software,
    ::iodef_2_0::action_type::watch_and_report
  };

  // dtype_type
  //

  dtype_type::
  dtype_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_dtype_type_convert ();
  }

  dtype_type::
  dtype_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_dtype_type_convert ();
  }

  dtype_type::
  dtype_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_dtype_type_convert ();
  }

  dtype_type* dtype_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dtype_type (*this, f, c);
  }

  dtype_type::value dtype_type::
  _xsd_dtype_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dtype_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_dtype_type_indexes_,
                      _xsd_dtype_type_indexes_ + 21,
                      *this,
                      c));

    if (i == _xsd_dtype_type_indexes_ + 21 || _xsd_dtype_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const dtype_type::
  _xsd_dtype_type_literals_[21] =
  {
    "boolean",
    "byte",
    "bytes",
    "character",
    "date-time",
    "integer",
    "ntpstamp",
    "portlist",
    "real",
    "string",
    "file",
    "path",
    "frame",
    "packet",
    "ipv4-packet",
    "ipv6-packet",
    "url",
    "csv",
    "winreg",
    "xml",
    "ext-value"
  };

  const dtype_type::value dtype_type::
  _xsd_dtype_type_indexes_[21] =
  {
    ::iodef_2_0::dtype_type::boolean,
    ::iodef_2_0::dtype_type::byte,
    ::iodef_2_0::dtype_type::bytes,
    ::iodef_2_0::dtype_type::character,
    ::iodef_2_0::dtype_type::csv,
    ::iodef_2_0::dtype_type::date_time,
    ::iodef_2_0::dtype_type::ext_value,
    ::iodef_2_0::dtype_type::file,
    ::iodef_2_0::dtype_type::frame,
    ::iodef_2_0::dtype_type::integer,
    ::iodef_2_0::dtype_type::ipv4_packet,
    ::iodef_2_0::dtype_type::ipv6_packet,
    ::iodef_2_0::dtype_type::ntpstamp,
    ::iodef_2_0::dtype_type::packet,
    ::iodef_2_0::dtype_type::path,
    ::iodef_2_0::dtype_type::portlist,
    ::iodef_2_0::dtype_type::real,
    ::iodef_2_0::dtype_type::string,
    ::iodef_2_0::dtype_type::url,
    ::iodef_2_0::dtype_type::winreg,
    ::iodef_2_0::dtype_type::xml
  };

  // proto_dtype_type
  //

  proto_dtype_type::
  proto_dtype_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_proto_dtype_type_convert ();
  }

  proto_dtype_type::
  proto_dtype_type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_proto_dtype_type_convert ();
  }

  proto_dtype_type::
  proto_dtype_type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_proto_dtype_type_convert ();
  }

  proto_dtype_type* proto_dtype_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class proto_dtype_type (*this, f, c);
  }

  proto_dtype_type::value proto_dtype_type::
  _xsd_proto_dtype_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_proto_dtype_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_proto_dtype_type_indexes_,
                      _xsd_proto_dtype_type_indexes_ + 10,
                      *this,
                      c));

    if (i == _xsd_proto_dtype_type_indexes_ + 10 || _xsd_proto_dtype_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const proto_dtype_type::
  _xsd_proto_dtype_type_literals_[10] =
  {
    "boolean",
    "byte",
    "bytes",
    "character",
    "date-time",
    "integer",
    "real",
    "string",
    "xml",
    "ext-value"
  };

  const proto_dtype_type::value proto_dtype_type::
  _xsd_proto_dtype_type_indexes_[10] =
  {
    ::iodef_2_0::proto_dtype_type::boolean,
    ::iodef_2_0::proto_dtype_type::byte,
    ::iodef_2_0::proto_dtype_type::bytes,
    ::iodef_2_0::proto_dtype_type::character,
    ::iodef_2_0::proto_dtype_type::date_time,
    ::iodef_2_0::proto_dtype_type::ext_value,
    ::iodef_2_0::proto_dtype_type::integer,
    ::iodef_2_0::proto_dtype_type::real,
    ::iodef_2_0::proto_dtype_type::string,
    ::iodef_2_0::proto_dtype_type::xml
  };

  // IODEF_Document
  //

  const IODEF_Document::version_type IODEF_Document::version_default_value_ (
    "2.00");

  IODEF_Document::
  IODEF_Document ()
  : ::xml_schema::type (),
    Incident_ (this),
    AdditionalData_ (this),
    version_ (version_default_value (), this),
    lang_ (this),
    format_id_ (this),
    private_enum_name_ (this),
    private_enum_id_ (this)
  {
  }

  IODEF_Document::
  IODEF_Document (const IODEF_Document& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Incident_ (x.Incident_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    version_ (x.version_, f, this),
    lang_ (x.lang_, f, this),
    format_id_ (x.format_id_, f, this),
    private_enum_name_ (x.private_enum_name_, f, this),
    private_enum_id_ (x.private_enum_id_, f, this)
  {
  }

  IODEF_Document::
  IODEF_Document (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Incident_ (this),
    AdditionalData_ (this),
    version_ (this),
    lang_ (this),
    format_id_ (this),
    private_enum_name_ (this),
    private_enum_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IODEF_Document::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Incident
      //
      if (n.name () == "Incident" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Incident_type > r (
          Incident_traits::create (i, f, this));

        this->Incident_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "format-id" && n.namespace_ ().empty ())
      {
        this->format_id_.set (format_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "private-enum-name" && n.namespace_ ().empty ())
      {
        this->private_enum_name_.set (private_enum_name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "private-enum-id" && n.namespace_ ().empty ())
      {
        this->private_enum_id_.set (private_enum_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }
  }

  IODEF_Document* IODEF_Document::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IODEF_Document (*this, f, c);
  }

  IODEF_Document& IODEF_Document::
  operator= (const IODEF_Document& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Incident_ = x.Incident_;
      this->AdditionalData_ = x.AdditionalData_;
      this->version_ = x.version_;
      this->lang_ = x.lang_;
      this->format_id_ = x.format_id_;
      this->private_enum_name_ = x.private_enum_name_;
      this->private_enum_id_ = x.private_enum_id_;
    }

    return *this;
  }

  IODEF_Document::
  ~IODEF_Document ()
  {
  }

  // Incident
  //

  const Incident::restriction_type Incident::restriction_default_value_ (
    "private");

  Incident::
  Incident (const IncidentID_type& IncidentID,
            const ReportTime_type& ReportTime,
            const purpose_type& purpose)
  : ::xml_schema::type (),
    IncidentID_ (IncidentID, this),
    AlternativeID_ (this),
    RelatedActivity_ (this),
    DetectTime_ (this),
    StartTime_ (this),
    EndTime_ (this),
    RecoveryTime_ (this),
    ReportTime_ (ReportTime, this),
    GenerationTime_ (this),
    Description_ (this),
    Discovery_ (this),
    Assessment_ (this),
    Method_ (this),
    Contact_ (this),
    EventData_ (this),
    History_ (this),
    AdditionalData_ (this),
    purpose_ (purpose, this),
    ext_purpose_ (this),
    status_ (this),
    ext_status_ (this),
    lang_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
  }

  Incident::
  Incident (::std::auto_ptr< IncidentID_type > IncidentID,
            const ReportTime_type& ReportTime,
            const purpose_type& purpose)
  : ::xml_schema::type (),
    IncidentID_ (IncidentID, this),
    AlternativeID_ (this),
    RelatedActivity_ (this),
    DetectTime_ (this),
    StartTime_ (this),
    EndTime_ (this),
    RecoveryTime_ (this),
    ReportTime_ (ReportTime, this),
    GenerationTime_ (this),
    Description_ (this),
    Discovery_ (this),
    Assessment_ (this),
    Method_ (this),
    Contact_ (this),
    EventData_ (this),
    History_ (this),
    AdditionalData_ (this),
    purpose_ (purpose, this),
    ext_purpose_ (this),
    status_ (this),
    ext_status_ (this),
    lang_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
  }

  Incident::
  Incident (const Incident& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    AlternativeID_ (x.AlternativeID_, f, this),
    RelatedActivity_ (x.RelatedActivity_, f, this),
    DetectTime_ (x.DetectTime_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    RecoveryTime_ (x.RecoveryTime_, f, this),
    ReportTime_ (x.ReportTime_, f, this),
    GenerationTime_ (x.GenerationTime_, f, this),
    Description_ (x.Description_, f, this),
    Discovery_ (x.Discovery_, f, this),
    Assessment_ (x.Assessment_, f, this),
    Method_ (x.Method_, f, this),
    Contact_ (x.Contact_, f, this),
    EventData_ (x.EventData_, f, this),
    History_ (x.History_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    purpose_ (x.purpose_, f, this),
    ext_purpose_ (x.ext_purpose_, f, this),
    status_ (x.status_, f, this),
    ext_status_ (x.ext_status_, f, this),
    lang_ (x.lang_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  Incident::
  Incident (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (this),
    AlternativeID_ (this),
    RelatedActivity_ (this),
    DetectTime_ (this),
    StartTime_ (this),
    EndTime_ (this),
    RecoveryTime_ (this),
    ReportTime_ (this),
    GenerationTime_ (this),
    Description_ (this),
    Discovery_ (this),
    Assessment_ (this),
    Method_ (this),
    Contact_ (this),
    EventData_ (this),
    History_ (this),
    AdditionalData_ (this),
    purpose_ (this),
    ext_purpose_ (this),
    status_ (this),
    ext_status_ (this),
    lang_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Incident::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        if (!IncidentID_.present ())
        {
          this->IncidentID_.set (r);
          continue;
        }
      }

      // AlternativeID
      //
      if (n.name () == "AlternativeID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AlternativeID_type > r (
          AlternativeID_traits::create (i, f, this));

        if (!this->AlternativeID_)
        {
          this->AlternativeID_.set (r);
          continue;
        }
      }

      // RelatedActivity
      //
      if (n.name () == "RelatedActivity" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RelatedActivity_type > r (
          RelatedActivity_traits::create (i, f, this));

        this->RelatedActivity_.push_back (r);
        continue;
      }

      // DetectTime
      //
      if (n.name () == "DetectTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DetectTime_type > r (
          DetectTime_traits::create (i, f, this));

        if (!this->DetectTime_)
        {
          this->DetectTime_.set (r);
          continue;
        }
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // RecoveryTime
      //
      if (n.name () == "RecoveryTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RecoveryTime_type > r (
          RecoveryTime_traits::create (i, f, this));

        if (!this->RecoveryTime_)
        {
          this->RecoveryTime_.set (r);
          continue;
        }
      }

      // ReportTime
      //
      if (n.name () == "ReportTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ReportTime_type > r (
          ReportTime_traits::create (i, f, this));

        if (!ReportTime_.present ())
        {
          this->ReportTime_.set (r);
          continue;
        }
      }

      // GenerationTime
      //
      if (n.name () == "GenerationTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< GenerationTime_type > r (
          GenerationTime_traits::create (i, f, this));

        if (!this->GenerationTime_)
        {
          this->GenerationTime_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // Discovery
      //
      if (n.name () == "Discovery" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Discovery_type > r (
          Discovery_traits::create (i, f, this));

        this->Discovery_.push_back (r);
        continue;
      }

      // Assessment
      //
      if (n.name () == "Assessment" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Assessment_type > r (
          Assessment_traits::create (i, f, this));

        this->Assessment_.push_back (r);
        continue;
      }

      // Method
      //
      if (n.name () == "Method" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Method_type > r (
          Method_traits::create (i, f, this));

        this->Method_.push_back (r);
        continue;
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        this->Contact_.push_back (r);
        continue;
      }

      // EventData
      //
      if (n.name () == "EventData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EventData_type > r (
          EventData_traits::create (i, f, this));

        this->EventData_.push_back (r);
        continue;
      }

      // History
      //
      if (n.name () == "History" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< History_type > r (
          History_traits::create (i, f, this));

        if (!this->History_)
        {
          this->History_.set (r);
          continue;
        }
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    if (!IncidentID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IncidentID",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }

    if (!ReportTime_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ReportTime",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "purpose" && n.namespace_ ().empty ())
      {
        this->purpose_.set (purpose_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-purpose" && n.namespace_ ().empty ())
      {
        this->ext_purpose_.set (ext_purpose_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "status" && n.namespace_ ().empty ())
      {
        this->status_.set (status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-status" && n.namespace_ ().empty ())
      {
        this->ext_status_.set (ext_status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!purpose_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "purpose",
        "");
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }
  }

  Incident* Incident::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Incident (*this, f, c);
  }

  Incident& Incident::
  operator= (const Incident& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IncidentID_ = x.IncidentID_;
      this->AlternativeID_ = x.AlternativeID_;
      this->RelatedActivity_ = x.RelatedActivity_;
      this->DetectTime_ = x.DetectTime_;
      this->StartTime_ = x.StartTime_;
      this->EndTime_ = x.EndTime_;
      this->RecoveryTime_ = x.RecoveryTime_;
      this->ReportTime_ = x.ReportTime_;
      this->GenerationTime_ = x.GenerationTime_;
      this->Description_ = x.Description_;
      this->Discovery_ = x.Discovery_;
      this->Assessment_ = x.Assessment_;
      this->Method_ = x.Method_;
      this->Contact_ = x.Contact_;
      this->EventData_ = x.EventData_;
      this->History_ = x.History_;
      this->AdditionalData_ = x.AdditionalData_;
      this->purpose_ = x.purpose_;
      this->ext_purpose_ = x.ext_purpose_;
      this->status_ = x.status_;
      this->ext_status_ = x.ext_status_;
      this->lang_ = x.lang_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  Incident::
  ~Incident ()
  {
  }

  // AlternativeID
  //

  AlternativeID::
  AlternativeID ()
  : ::xml_schema::type (),
    IncidentID_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  AlternativeID::
  AlternativeID (const AlternativeID& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  AlternativeID::
  AlternativeID (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlternativeID::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        this->IncidentID_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  AlternativeID* AlternativeID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlternativeID (*this, f, c);
  }

  AlternativeID& AlternativeID::
  operator= (const AlternativeID& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IncidentID_ = x.IncidentID_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  AlternativeID::
  ~AlternativeID ()
  {
  }

  // RelatedActivity
  //

  RelatedActivity::
  RelatedActivity ()
  : ::xml_schema::type (),
    IncidentID_ (this),
    URL_ (this),
    ThreatActor_ (this),
    Campaign_ (this),
    Confidence_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  RelatedActivity::
  RelatedActivity (const RelatedActivity& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    URL_ (x.URL_, f, this),
    ThreatActor_ (x.ThreatActor_, f, this),
    Campaign_ (x.Campaign_, f, this),
    Confidence_ (x.Confidence_, f, this),
    Description_ (x.Description_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  RelatedActivity::
  RelatedActivity (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (this),
    URL_ (this),
    ThreatActor_ (this),
    Campaign_ (this),
    Confidence_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RelatedActivity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        this->IncidentID_.push_back (r);
        continue;
      }

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        this->URL_.push_back (r);
        continue;
      }

      // ThreatActor
      //
      if (n.name () == "ThreatActor" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ThreatActor_type > r (
          ThreatActor_traits::create (i, f, this));

        this->ThreatActor_.push_back (r);
        continue;
      }

      // Campaign
      //
      if (n.name () == "Campaign" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Campaign_type > r (
          Campaign_traits::create (i, f, this));

        this->Campaign_.push_back (r);
        continue;
      }

      // Confidence
      //
      if (n.name () == "Confidence" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Confidence_type > r (
          Confidence_traits::create (i, f, this));

        if (!this->Confidence_)
        {
          this->Confidence_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  RelatedActivity* RelatedActivity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RelatedActivity (*this, f, c);
  }

  RelatedActivity& RelatedActivity::
  operator= (const RelatedActivity& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IncidentID_ = x.IncidentID_;
      this->URL_ = x.URL_;
      this->ThreatActor_ = x.ThreatActor_;
      this->Campaign_ = x.Campaign_;
      this->Confidence_ = x.Confidence_;
      this->Description_ = x.Description_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  RelatedActivity::
  ~RelatedActivity ()
  {
  }

  // ThreatActor
  //

  ThreatActor::
  ThreatActor ()
  : ::xml_schema::type (),
    ThreatActorID_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  ThreatActor::
  ThreatActor (const ThreatActor& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ThreatActorID_ (x.ThreatActorID_, f, this),
    Description_ (x.Description_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  ThreatActor::
  ThreatActor (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ThreatActorID_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ThreatActor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ThreatActorID
      //
      if (n.name () == "ThreatActorID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ThreatActorID_type > r (
          ThreatActorID_traits::create (i, f, this));

        if (!this->ThreatActorID_)
        {
          this->ThreatActorID_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  ThreatActor* ThreatActor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ThreatActor (*this, f, c);
  }

  ThreatActor& ThreatActor::
  operator= (const ThreatActor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ThreatActorID_ = x.ThreatActorID_;
      this->Description_ = x.Description_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  ThreatActor::
  ~ThreatActor ()
  {
  }

  // Campaign
  //

  Campaign::
  Campaign ()
  : ::xml_schema::type (),
    CampaignID_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  Campaign::
  Campaign (const Campaign& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CampaignID_ (x.CampaignID_, f, this),
    Description_ (x.Description_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  Campaign::
  Campaign (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CampaignID_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Campaign::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CampaignID
      //
      if (n.name () == "CampaignID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< CampaignID_type > r (
          CampaignID_traits::create (i, f, this));

        if (!this->CampaignID_)
        {
          this->CampaignID_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  Campaign* Campaign::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Campaign (*this, f, c);
  }

  Campaign& Campaign::
  operator= (const Campaign& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CampaignID_ = x.CampaignID_;
      this->Description_ = x.Description_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  Campaign::
  ~Campaign ()
  {
  }

  // Contact
  //

  Contact::
  Contact (const role_type& role,
           const type_type& type)
  : ::xml_schema::type (),
    ContactName_ (this),
    ContactTitle_ (this),
    Description_ (this),
    RegistryHandle_ (this),
    PostalAddress_ (this),
    Email_ (this),
    Telephone_ (this),
    Fax_ (this),
    Timezone_ (this),
    Contact1_ (this),
    AdditionalData_ (this),
    role_ (role, this),
    ext_role_ (this),
    type_ (type, this),
    ext_type_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  Contact::
  Contact (const Contact& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ContactName_ (x.ContactName_, f, this),
    ContactTitle_ (x.ContactTitle_, f, this),
    Description_ (x.Description_, f, this),
    RegistryHandle_ (x.RegistryHandle_, f, this),
    PostalAddress_ (x.PostalAddress_, f, this),
    Email_ (x.Email_, f, this),
    Telephone_ (x.Telephone_, f, this),
    Fax_ (x.Fax_, f, this),
    Timezone_ (x.Timezone_, f, this),
    Contact1_ (x.Contact1_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    role_ (x.role_, f, this),
    ext_role_ (x.ext_role_, f, this),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  Contact::
  Contact (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ContactName_ (this),
    ContactTitle_ (this),
    Description_ (this),
    RegistryHandle_ (this),
    PostalAddress_ (this),
    Email_ (this),
    Telephone_ (this),
    Fax_ (this),
    Timezone_ (this),
    Contact1_ (this),
    AdditionalData_ (this),
    role_ (this),
    ext_role_ (this),
    type_ (this),
    ext_type_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Contact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContactName
      //
      if (n.name () == "ContactName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ContactName_type > r (
          ContactName_traits::create (i, f, this));

        this->ContactName_.push_back (r);
        continue;
      }

      // ContactTitle
      //
      if (n.name () == "ContactTitle" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ContactTitle_type > r (
          ContactTitle_traits::create (i, f, this));

        this->ContactTitle_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // RegistryHandle
      //
      if (n.name () == "RegistryHandle" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RegistryHandle_type > r (
          RegistryHandle_traits::create (i, f, this));

        this->RegistryHandle_.push_back (r);
        continue;
      }

      // PostalAddress
      //
      if (n.name () == "PostalAddress" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< PostalAddress_type > r (
          PostalAddress_traits::create (i, f, this));

        if (!this->PostalAddress_)
        {
          this->PostalAddress_.set (r);
          continue;
        }
      }

      // Email
      //
      if (n.name () == "Email" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Email_type > r (
          Email_traits::create (i, f, this));

        this->Email_.push_back (r);
        continue;
      }

      // Telephone
      //
      if (n.name () == "Telephone" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Telephone_type > r (
          Telephone_traits::create (i, f, this));

        this->Telephone_.push_back (r);
        continue;
      }

      // Fax
      //
      if (n.name () == "Fax" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Fax_type > r (
          Fax_traits::create (i, f, this));

        if (!this->Fax_)
        {
          this->Fax_.set (r);
          continue;
        }
      }

      // Timezone
      //
      if (n.name () == "Timezone" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Timezone_type > r (
          Timezone_traits::create (i, f, this));

        if (!this->Timezone_)
        {
          this->Timezone_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Contact1_type > r (
          Contact1_traits::create (i, f, this));

        this->Contact1_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "role" && n.namespace_ ().empty ())
      {
        this->role_.set (role_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-role" && n.namespace_ ().empty ())
      {
        this->ext_role_.set (ext_role_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        this->ext_type_.set (ext_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }

    if (!role_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "role",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  Contact* Contact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Contact (*this, f, c);
  }

  Contact& Contact::
  operator= (const Contact& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ContactName_ = x.ContactName_;
      this->ContactTitle_ = x.ContactTitle_;
      this->Description_ = x.Description_;
      this->RegistryHandle_ = x.RegistryHandle_;
      this->PostalAddress_ = x.PostalAddress_;
      this->Email_ = x.Email_;
      this->Telephone_ = x.Telephone_;
      this->Fax_ = x.Fax_;
      this->Timezone_ = x.Timezone_;
      this->Contact1_ = x.Contact1_;
      this->AdditionalData_ = x.AdditionalData_;
      this->role_ = x.role_;
      this->ext_role_ = x.ext_role_;
      this->type_ = x.type_;
      this->ext_type_ = x.ext_type_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  Contact::
  ~Contact ()
  {
  }

  // RegistryHandle
  //

  RegistryHandle::
  RegistryHandle ()
  : ::xml_schema::string (),
    registry_ (this),
    ext_registry_ (this)
  {
  }

  RegistryHandle::
  RegistryHandle (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (this),
    ext_registry_ (this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (this),
    ext_registry_ (this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (this),
    ext_registry_ (this)
  {
  }

  RegistryHandle::
  RegistryHandle (const RegistryHandle& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    registry_ (x.registry_, f, this),
    ext_registry_ (x.ext_registry_, f, this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    registry_ (this),
    ext_registry_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RegistryHandle::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "registry" && n.namespace_ ().empty ())
      {
        this->registry_.set (registry_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-registry" && n.namespace_ ().empty ())
      {
        this->ext_registry_.set (ext_registry_traits::create (i, f, this));
        continue;
      }
    }
  }

  RegistryHandle* RegistryHandle::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RegistryHandle (*this, f, c);
  }

  RegistryHandle& RegistryHandle::
  operator= (const RegistryHandle& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->registry_ = x.registry_;
      this->ext_registry_ = x.ext_registry_;
    }

    return *this;
  }

  RegistryHandle::
  ~RegistryHandle ()
  {
  }

  // PostalAddress
  //

  PostalAddress::
  PostalAddress ()
  : ::iodef_2_0::MLStringType (),
    meaning_ (this)
  {
  }

  PostalAddress::
  PostalAddress (const char* _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    meaning_ (this)
  {
  }

  PostalAddress::
  PostalAddress (const ::std::string& _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    meaning_ (this)
  {
  }

  PostalAddress::
  PostalAddress (const ::xml_schema::string& _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    meaning_ (this)
  {
  }

  PostalAddress::
  PostalAddress (const PostalAddress& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::iodef_2_0::MLStringType (x, f, c),
    meaning_ (x.meaning_, f, this)
  {
  }

  PostalAddress::
  PostalAddress (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::iodef_2_0::MLStringType (e, f | ::xml_schema::flags::base, c),
    meaning_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void PostalAddress::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::iodef_2_0::MLStringType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        this->meaning_.set (meaning_traits::create (i, f, this));
        continue;
      }
    }
  }

  PostalAddress* PostalAddress::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PostalAddress (*this, f, c);
  }

  PostalAddress& PostalAddress::
  operator= (const PostalAddress& x)
  {
    if (this != &x)
    {
      static_cast< ::iodef_2_0::MLStringType& > (*this) = x;
      this->meaning_ = x.meaning_;
    }

    return *this;
  }

  PostalAddress::
  ~PostalAddress ()
  {
  }

  // History
  //

  const History::restriction_type History::restriction_default_value_ (
    "default");

  History::
  History ()
  : ::xml_schema::type (),
    HistoryItem_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this)
  {
  }

  History::
  History (const History& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    HistoryItem_ (x.HistoryItem_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  History::
  History (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    HistoryItem_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void History::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HistoryItem
      //
      if (n.name () == "HistoryItem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< HistoryItem_type > r (
          HistoryItem_traits::create (i, f, this));

        this->HistoryItem_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }
  }

  History* History::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class History (*this, f, c);
  }

  History& History::
  operator= (const History& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->HistoryItem_ = x.HistoryItem_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  History::
  ~History ()
  {
  }

  // HistoryItem
  //

  HistoryItem::
  HistoryItem (const DateTime_type& DateTime,
               const action_type& action)
  : ::xml_schema::type (),
    DateTime_ (DateTime, this),
    IncidentID_ (this),
    Contact_ (this),
    Description_ (this),
    DefinedCOA_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    action_ (action, this),
    ext_action_ (this),
    observable_id_ (this)
  {
  }

  HistoryItem::
  HistoryItem (const HistoryItem& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DateTime_ (x.DateTime_, f, this),
    IncidentID_ (x.IncidentID_, f, this),
    Contact_ (x.Contact_, f, this),
    Description_ (x.Description_, f, this),
    DefinedCOA_ (x.DefinedCOA_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this),
    action_ (x.action_, f, this),
    ext_action_ (x.ext_action_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  HistoryItem::
  HistoryItem (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DateTime_ (this),
    IncidentID_ (this),
    Contact_ (this),
    Description_ (this),
    DefinedCOA_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    action_ (this),
    ext_action_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void HistoryItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DateTime
      //
      if (n.name () == "DateTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DateTime_type > r (
          DateTime_traits::create (i, f, this));

        if (!DateTime_.present ())
        {
          this->DateTime_.set (r);
          continue;
        }
      }

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        if (!this->IncidentID_)
        {
          this->IncidentID_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        if (!this->Contact_)
        {
          this->Contact_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // DefinedCOA
      //
      if (n.name () == "DefinedCOA" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DefinedCOA_type > r (
          DefinedCOA_traits::create (i, f, this));

        this->DefinedCOA_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    if (!DateTime_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DateTime",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "action" && n.namespace_ ().empty ())
      {
        this->action_.set (action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-action" && n.namespace_ ().empty ())
      {
        this->ext_action_.set (ext_action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!action_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "action",
        "");
    }
  }

  HistoryItem* HistoryItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HistoryItem (*this, f, c);
  }

  HistoryItem& HistoryItem::
  operator= (const HistoryItem& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DateTime_ = x.DateTime_;
      this->IncidentID_ = x.IncidentID_;
      this->Contact_ = x.Contact_;
      this->Description_ = x.Description_;
      this->DefinedCOA_ = x.DefinedCOA_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
      this->action_ = x.action_;
      this->ext_action_ = x.ext_action_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  HistoryItem::
  ~HistoryItem ()
  {
  }

  // Expectation
  //

  const Expectation::restriction_type Expectation::restriction_default_value_ (
    "default");

  const Expectation::action_type Expectation::action_default_value_ (
    "other");

  Expectation::
  Expectation ()
  : ::xml_schema::type (),
    Description_ (this),
    DefinedCOA_ (this),
    StartTime_ (this),
    EndTime_ (this),
    Contact_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this),
    severity_ (this),
    action_ (action_default_value (), this),
    ext_action_ (this),
    observable_id_ (this)
  {
  }

  Expectation::
  Expectation (const Expectation& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Description_ (x.Description_, f, this),
    DefinedCOA_ (x.DefinedCOA_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    Contact_ (x.Contact_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this),
    severity_ (x.severity_, f, this),
    action_ (x.action_, f, this),
    ext_action_ (x.ext_action_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  Expectation::
  Expectation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Description_ (this),
    DefinedCOA_ (this),
    StartTime_ (this),
    EndTime_ (this),
    Contact_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    severity_ (this),
    action_ (this),
    ext_action_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Expectation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // DefinedCOA
      //
      if (n.name () == "DefinedCOA" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DefinedCOA_type > r (
          DefinedCOA_traits::create (i, f, this));

        this->DefinedCOA_.push_back (r);
        continue;
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        if (!this->Contact_)
        {
          this->Contact_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        this->severity_.set (severity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "action" && n.namespace_ ().empty ())
      {
        this->action_.set (action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-action" && n.namespace_ ().empty ())
      {
        this->ext_action_.set (ext_action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }

    if (!action_.present ())
    {
      this->action_.set (action_default_value ());
    }
  }

  Expectation* Expectation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Expectation (*this, f, c);
  }

  Expectation& Expectation::
  operator= (const Expectation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Description_ = x.Description_;
      this->DefinedCOA_ = x.DefinedCOA_;
      this->StartTime_ = x.StartTime_;
      this->EndTime_ = x.EndTime_;
      this->Contact_ = x.Contact_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
      this->severity_ = x.severity_;
      this->action_ = x.action_;
      this->ext_action_ = x.ext_action_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  Expectation::
  ~Expectation ()
  {
  }

  // Discovery
  //

  const Discovery::source_type Discovery::source_default_value_ (
    "unknown");

  Discovery::
  Discovery ()
  : ::xml_schema::type (),
    Description_ (this),
    Contact_ (this),
    DetectionPattern_ (this),
    source_ (source_default_value (), this),
    ext_source_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  Discovery::
  Discovery (const Discovery& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Description_ (x.Description_, f, this),
    Contact_ (x.Contact_, f, this),
    DetectionPattern_ (x.DetectionPattern_, f, this),
    source_ (x.source_, f, this),
    ext_source_ (x.ext_source_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  Discovery::
  Discovery (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Description_ (this),
    Contact_ (this),
    DetectionPattern_ (this),
    source_ (this),
    ext_source_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Discovery::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        this->Contact_.push_back (r);
        continue;
      }

      // DetectionPattern
      //
      if (n.name () == "DetectionPattern" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DetectionPattern_type > r (
          DetectionPattern_traits::create (i, f, this));

        this->DetectionPattern_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "source" && n.namespace_ ().empty ())
      {
        this->source_.set (source_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-source" && n.namespace_ ().empty ())
      {
        this->ext_source_.set (ext_source_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }

    if (!source_.present ())
    {
      this->source_.set (source_default_value ());
    }
  }

  Discovery* Discovery::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Discovery (*this, f, c);
  }

  Discovery& Discovery::
  operator= (const Discovery& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Description_ = x.Description_;
      this->Contact_ = x.Contact_;
      this->DetectionPattern_ = x.DetectionPattern_;
      this->source_ = x.source_;
      this->ext_source_ = x.ext_source_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  Discovery::
  ~Discovery ()
  {
  }

  // DetectionPattern
  //

  DetectionPattern::
  DetectionPattern (const Application_type& Application)
  : ::xml_schema::type (),
    Application_ (Application, this),
    Description_ (this),
    DetectionConfiguration_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  DetectionPattern::
  DetectionPattern (::std::auto_ptr< Application_type > Application)
  : ::xml_schema::type (),
    Application_ (Application, this),
    Description_ (this),
    DetectionConfiguration_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  DetectionPattern::
  DetectionPattern (const DetectionPattern& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Application_ (x.Application_, f, this),
    Description_ (x.Description_, f, this),
    DetectionConfiguration_ (x.DetectionConfiguration_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  DetectionPattern::
  DetectionPattern (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Application_ (this),
    Description_ (this),
    DetectionConfiguration_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DetectionPattern::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        if (!Application_.present ())
        {
          this->Application_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // DetectionConfiguration
      //
      if (n.name () == "DetectionConfiguration" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DetectionConfiguration_type > r (
          DetectionConfiguration_traits::create (i, f, this));

        this->DetectionConfiguration_.push_back (r);
        continue;
      }

      break;
    }

    if (!Application_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Application",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  DetectionPattern* DetectionPattern::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DetectionPattern (*this, f, c);
  }

  DetectionPattern& DetectionPattern::
  operator= (const DetectionPattern& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Application_ = x.Application_;
      this->Description_ = x.Description_;
      this->DetectionConfiguration_ = x.DetectionConfiguration_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  DetectionPattern::
  ~DetectionPattern ()
  {
  }

  // Method
  //

  Method::
  Method ()
  : ::xml_schema::type (),
    Reference_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  Method::
  Method (const Method& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Reference_ (x.Reference_, f, this),
    Description_ (x.Description_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  Method::
  Method (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Reference_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Method::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Reference
      //
      if (n.name () == "Reference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Reference_type > r (
          Reference_traits::create (i, f, this));

        this->Reference_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  Method* Method::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Method (*this, f, c);
  }

  Method& Method::
  operator= (const Method& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Reference_ = x.Reference_;
      this->Description_ = x.Description_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  Method::
  ~Method ()
  {
  }

  // Reference
  //

  Reference::
  Reference ()
  : ::xml_schema::type (),
    ReferenceName_ (this),
    URL_ (this),
    Description_ (this),
    observable_id_ (this)
  {
  }

  Reference::
  Reference (const Reference& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ReferenceName_ (x.ReferenceName_, f, this),
    URL_ (x.URL_, f, this),
    Description_ (x.Description_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  Reference::
  Reference (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ReferenceName_ (this),
    URL_ (this),
    Description_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Reference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReferenceName
      //
      if (n.name () == "ReferenceName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-enum-1.0")
      {
        ::std::auto_ptr< ReferenceName_type > r (
          ReferenceName_traits::create (i, f, this));

        if (!this->ReferenceName_)
        {
          this->ReferenceName_.set (r);
          continue;
        }
      }

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        this->URL_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }
  }

  Reference* Reference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Reference (*this, f, c);
  }

  Reference& Reference::
  operator= (const Reference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ReferenceName_ = x.ReferenceName_;
      this->URL_ = x.URL_;
      this->Description_ = x.Description_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  Reference::
  ~Reference ()
  {
  }

  // Assessment
  //

  Assessment::
  Assessment ()
  : ::xml_schema::type (),
    IncidentCategory_ (this),
    SystemImpact_ (this),
    BusinessImpact_ (this),
    TimeImpact_ (this),
    MonetaryImpact_ (this),
    IntendedImpact_ (this),
    Counter_ (this),
    MitigatingFactor_ (this),
    Confidence_ (this),
    AdditionalData_ (this),
    occurrence_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
  }

  Assessment::
  Assessment (const Assessment& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentCategory_ (x.IncidentCategory_, f, this),
    SystemImpact_ (x.SystemImpact_, f, this),
    BusinessImpact_ (x.BusinessImpact_, f, this),
    TimeImpact_ (x.TimeImpact_, f, this),
    MonetaryImpact_ (x.MonetaryImpact_, f, this),
    IntendedImpact_ (x.IntendedImpact_, f, this),
    Counter_ (x.Counter_, f, this),
    MitigatingFactor_ (x.MitigatingFactor_, f, this),
    Confidence_ (x.Confidence_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    occurrence_ (x.occurrence_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  Assessment::
  Assessment (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentCategory_ (this),
    SystemImpact_ (this),
    BusinessImpact_ (this),
    TimeImpact_ (this),
    MonetaryImpact_ (this),
    IntendedImpact_ (this),
    Counter_ (this),
    MitigatingFactor_ (this),
    Confidence_ (this),
    AdditionalData_ (this),
    occurrence_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Assessment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentCategory
      //
      if (n.name () == "IncidentCategory" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IncidentCategory_type > r (
          IncidentCategory_traits::create (i, f, this));

        this->IncidentCategory_.push_back (r);
        continue;
      }

      // SystemImpact
      //
      if (n.name () == "SystemImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< SystemImpact_type > r (
          SystemImpact_traits::create (i, f, this));

        this->SystemImpact_.push_back (r);
        continue;
      }

      // BusinessImpact
      //
      if (n.name () == "BusinessImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< BusinessImpact_type > r (
          BusinessImpact_traits::create (i, f, this));

        this->BusinessImpact_.push_back (r);
        continue;
      }

      // TimeImpact
      //
      if (n.name () == "TimeImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< TimeImpact_type > r (
          TimeImpact_traits::create (i, f, this));

        this->TimeImpact_.push_back (r);
        continue;
      }

      // MonetaryImpact
      //
      if (n.name () == "MonetaryImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< MonetaryImpact_type > r (
          MonetaryImpact_traits::create (i, f, this));

        this->MonetaryImpact_.push_back (r);
        continue;
      }

      // IntendedImpact
      //
      if (n.name () == "IntendedImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IntendedImpact_type > r (
          IntendedImpact_traits::create (i, f, this));

        this->IntendedImpact_.push_back (r);
        continue;
      }

      // Counter
      //
      if (n.name () == "Counter" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Counter_type > r (
          Counter_traits::create (i, f, this));

        this->Counter_.push_back (r);
        continue;
      }

      // MitigatingFactor
      //
      if (n.name () == "MitigatingFactor" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< MitigatingFactor_type > r (
          MitigatingFactor_traits::create (i, f, this));

        this->MitigatingFactor_.push_back (r);
        continue;
      }

      // Confidence
      //
      if (n.name () == "Confidence" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Confidence_type > r (
          Confidence_traits::create (i, f, this));

        if (!this->Confidence_)
        {
          this->Confidence_.set (r);
          continue;
        }
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "occurrence" && n.namespace_ ().empty ())
      {
        this->occurrence_.set (occurrence_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }
  }

  Assessment* Assessment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Assessment (*this, f, c);
  }

  Assessment& Assessment::
  operator= (const Assessment& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IncidentCategory_ = x.IncidentCategory_;
      this->SystemImpact_ = x.SystemImpact_;
      this->BusinessImpact_ = x.BusinessImpact_;
      this->TimeImpact_ = x.TimeImpact_;
      this->MonetaryImpact_ = x.MonetaryImpact_;
      this->IntendedImpact_ = x.IntendedImpact_;
      this->Counter_ = x.Counter_;
      this->MitigatingFactor_ = x.MitigatingFactor_;
      this->Confidence_ = x.Confidence_;
      this->AdditionalData_ = x.AdditionalData_;
      this->occurrence_ = x.occurrence_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  Assessment::
  ~Assessment ()
  {
  }

  // SystemImpact
  //

  SystemImpact::
  SystemImpact ()
  : ::iodef_2_0::MLStringType (),
    severity_ (this),
    completion_ (this),
    type_ (this),
    ext_type_ (this)
  {
  }

  SystemImpact::
  SystemImpact (const char* _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    severity_ (this),
    completion_ (this),
    type_ (this),
    ext_type_ (this)
  {
  }

  SystemImpact::
  SystemImpact (const ::std::string& _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    severity_ (this),
    completion_ (this),
    type_ (this),
    ext_type_ (this)
  {
  }

  SystemImpact::
  SystemImpact (const ::xml_schema::string& _xsd_string_base)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    severity_ (this),
    completion_ (this),
    type_ (this),
    ext_type_ (this)
  {
  }

  SystemImpact::
  SystemImpact (const SystemImpact& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::iodef_2_0::MLStringType (x, f, c),
    severity_ (x.severity_, f, this),
    completion_ (x.completion_, f, this),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this)
  {
  }

  SystemImpact::
  SystemImpact (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::iodef_2_0::MLStringType (e, f | ::xml_schema::flags::base, c),
    severity_ (this),
    completion_ (this),
    type_ (this),
    ext_type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SystemImpact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::iodef_2_0::MLStringType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        this->severity_.set (severity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "completion" && n.namespace_ ().empty ())
      {
        this->completion_.set (completion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        this->ext_type_.set (ext_type_traits::create (i, f, this));
        continue;
      }
    }
  }

  SystemImpact* SystemImpact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SystemImpact (*this, f, c);
  }

  SystemImpact& SystemImpact::
  operator= (const SystemImpact& x)
  {
    if (this != &x)
    {
      static_cast< ::iodef_2_0::MLStringType& > (*this) = x;
      this->severity_ = x.severity_;
      this->completion_ = x.completion_;
      this->type_ = x.type_;
      this->ext_type_ = x.ext_type_;
    }

    return *this;
  }

  SystemImpact::
  ~SystemImpact ()
  {
  }

  // TimeImpact
  //

  TimeImpact::
  TimeImpact (const ::xml_schema::float_& _xsd_float__base,
              const metric_type& metric)
  : ::iodef_2_0::PositiveFloatType (_xsd_float__base),
    severity_ (this),
    metric_ (metric, this),
    duration_ (this)
  {
  }

  TimeImpact::
  TimeImpact (const TimeImpact& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::iodef_2_0::PositiveFloatType (x, f, c),
    severity_ (x.severity_, f, this),
    metric_ (x.metric_, f, this),
    duration_ (x.duration_, f, this)
  {
  }

  TimeImpact::
  TimeImpact (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::iodef_2_0::PositiveFloatType (e, f | ::xml_schema::flags::base, c),
    severity_ (this),
    metric_ (this),
    duration_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void TimeImpact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        this->severity_.set (severity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "metric" && n.namespace_ ().empty ())
      {
        this->metric_.set (metric_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }
    }

    if (!metric_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "metric",
        "");
    }
  }

  TimeImpact* TimeImpact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimeImpact (*this, f, c);
  }

  TimeImpact& TimeImpact::
  operator= (const TimeImpact& x)
  {
    if (this != &x)
    {
      static_cast< ::iodef_2_0::PositiveFloatType& > (*this) = x;
      this->severity_ = x.severity_;
      this->metric_ = x.metric_;
      this->duration_ = x.duration_;
    }

    return *this;
  }

  TimeImpact::
  ~TimeImpact ()
  {
  }

  // MonetaryImpact
  //

  MonetaryImpact::
  MonetaryImpact (const ::xml_schema::float_& _xsd_float__base)
  : ::iodef_2_0::PositiveFloatType (_xsd_float__base),
    severity_ (this),
    currency_ (this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const MonetaryImpact& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::iodef_2_0::PositiveFloatType (x, f, c),
    severity_ (x.severity_, f, this),
    currency_ (x.currency_, f, this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::iodef_2_0::PositiveFloatType (e, f | ::xml_schema::flags::base, c),
    severity_ (this),
    currency_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MonetaryImpact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        this->severity_.set (severity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "currency" && n.namespace_ ().empty ())
      {
        this->currency_.set (currency_traits::create (i, f, this));
        continue;
      }
    }
  }

  MonetaryImpact* MonetaryImpact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MonetaryImpact (*this, f, c);
  }

  MonetaryImpact& MonetaryImpact::
  operator= (const MonetaryImpact& x)
  {
    if (this != &x)
    {
      static_cast< ::iodef_2_0::PositiveFloatType& > (*this) = x;
      this->severity_ = x.severity_;
      this->currency_ = x.currency_;
    }

    return *this;
  }

  MonetaryImpact::
  ~MonetaryImpact ()
  {
  }

  // Confidence
  //

  Confidence::
  Confidence (const rating_type& rating)
  : ::xml_schema::type (),
    rating_ (rating, this)
  {
  }

  Confidence::
  Confidence (const Confidence& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    rating_ (x.rating_, f, this)
  {
  }

  Confidence::
  Confidence (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    rating_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Confidence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "rating" && n.namespace_ ().empty ())
      {
        this->rating_.set (rating_traits::create (i, f, this));
        continue;
      }
    }

    if (!rating_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "rating",
        "");
    }
  }

  Confidence* Confidence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Confidence (*this, f, c);
  }

  Confidence& Confidence::
  operator= (const Confidence& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->rating_ = x.rating_;
    }

    return *this;
  }

  Confidence::
  ~Confidence ()
  {
  }

  // EventData
  //

  const EventData::restriction_type EventData::restriction_default_value_ (
    "default");

  EventData::
  EventData ()
  : ::xml_schema::type (),
    Description_ (this),
    DetectTime_ (this),
    StartTime_ (this),
    EndTime_ (this),
    RecoveryTime_ (this),
    ReportTime_ (this),
    Contact_ (this),
    Discovery_ (this),
    Assessment_ (this),
    Method_ (this),
    Flow_ (this),
    Expectation_ (this),
    Record_ (this),
    EventData1_ (this),
    AdditionalData_ (this),
    restriction_ (restriction_default_value (), this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
  }

  EventData::
  EventData (const EventData& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Description_ (x.Description_, f, this),
    DetectTime_ (x.DetectTime_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    RecoveryTime_ (x.RecoveryTime_, f, this),
    ReportTime_ (x.ReportTime_, f, this),
    Contact_ (x.Contact_, f, this),
    Discovery_ (x.Discovery_, f, this),
    Assessment_ (x.Assessment_, f, this),
    Method_ (x.Method_, f, this),
    Flow_ (x.Flow_, f, this),
    Expectation_ (x.Expectation_, f, this),
    Record_ (x.Record_, f, this),
    EventData1_ (x.EventData1_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  EventData::
  EventData (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Description_ (this),
    DetectTime_ (this),
    StartTime_ (this),
    EndTime_ (this),
    RecoveryTime_ (this),
    ReportTime_ (this),
    Contact_ (this),
    Discovery_ (this),
    Assessment_ (this),
    Method_ (this),
    Flow_ (this),
    Expectation_ (this),
    Record_ (this),
    EventData1_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EventData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // DetectTime
      //
      if (n.name () == "DetectTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DetectTime_type > r (
          DetectTime_traits::create (i, f, this));

        if (!this->DetectTime_)
        {
          this->DetectTime_.set (r);
          continue;
        }
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // RecoveryTime
      //
      if (n.name () == "RecoveryTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RecoveryTime_type > r (
          RecoveryTime_traits::create (i, f, this));

        if (!this->RecoveryTime_)
        {
          this->RecoveryTime_.set (r);
          continue;
        }
      }

      // ReportTime
      //
      if (n.name () == "ReportTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ReportTime_type > r (
          ReportTime_traits::create (i, f, this));

        if (!this->ReportTime_)
        {
          this->ReportTime_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        this->Contact_.push_back (r);
        continue;
      }

      // Discovery
      //
      if (n.name () == "Discovery" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Discovery_type > r (
          Discovery_traits::create (i, f, this));

        this->Discovery_.push_back (r);
        continue;
      }

      // Assessment
      //
      if (n.name () == "Assessment" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Assessment_type > r (
          Assessment_traits::create (i, f, this));

        if (!this->Assessment_)
        {
          this->Assessment_.set (r);
          continue;
        }
      }

      // Method
      //
      if (n.name () == "Method" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Method_type > r (
          Method_traits::create (i, f, this));

        this->Method_.push_back (r);
        continue;
      }

      // Flow
      //
      if (n.name () == "Flow" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Flow_type > r (
          Flow_traits::create (i, f, this));

        this->Flow_.push_back (r);
        continue;
      }

      // Expectation
      //
      if (n.name () == "Expectation" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Expectation_type > r (
          Expectation_traits::create (i, f, this));

        this->Expectation_.push_back (r);
        continue;
      }

      // Record
      //
      if (n.name () == "Record" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Record_type > r (
          Record_traits::create (i, f, this));

        if (!this->Record_)
        {
          this->Record_.set (r);
          continue;
        }
      }

      // EventData
      //
      if (n.name () == "EventData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EventData1_type > r (
          EventData1_traits::create (i, f, this));

        this->EventData1_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }
  }

  EventData* EventData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EventData (*this, f, c);
  }

  EventData& EventData::
  operator= (const EventData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Description_ = x.Description_;
      this->DetectTime_ = x.DetectTime_;
      this->StartTime_ = x.StartTime_;
      this->EndTime_ = x.EndTime_;
      this->RecoveryTime_ = x.RecoveryTime_;
      this->ReportTime_ = x.ReportTime_;
      this->Contact_ = x.Contact_;
      this->Discovery_ = x.Discovery_;
      this->Assessment_ = x.Assessment_;
      this->Method_ = x.Method_;
      this->Flow_ = x.Flow_;
      this->Expectation_ = x.Expectation_;
      this->Record_ = x.Record_;
      this->EventData1_ = x.EventData1_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  EventData::
  ~EventData ()
  {
  }

  // Flow
  //

  Flow::
  Flow ()
  : ::xml_schema::type (),
    System_ (this)
  {
  }

  Flow::
  Flow (const Flow& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    System_ (x.System_, f, this)
  {
  }

  Flow::
  Flow (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    System_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Flow::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // System
      //
      if (n.name () == "System" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< System_type > r (
          System_traits::create (i, f, this));

        this->System_.push_back (r);
        continue;
      }

      break;
    }
  }

  Flow* Flow::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Flow (*this, f, c);
  }

  Flow& Flow::
  operator= (const Flow& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->System_ = x.System_;
    }

    return *this;
  }

  Flow::
  ~Flow ()
  {
  }

  // System
  //

  const System::spoofed_type System::spoofed_default_value_ (
    "unknown");

  const System::virtual_type System::virtual__default_value_ (
    "unknown");

  System::
  System ()
  : ::xml_schema::type (),
    Node_ (this),
    NodeRole_ (this),
    Service_ (this),
    OperatingSystem_ (this),
    Counter_ (this),
    AssetID_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    category_ (this),
    ext_category_ (this),
    interface_ (this),
    spoofed_ (spoofed_default_value (), this),
    virtual__ (virtual_default_value (), this),
    ownership_ (this),
    ext_ownership_ (this)
  {
  }

  System::
  System (const System& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Node_ (x.Node_, f, this),
    NodeRole_ (x.NodeRole_, f, this),
    Service_ (x.Service_, f, this),
    OperatingSystem_ (x.OperatingSystem_, f, this),
    Counter_ (x.Counter_, f, this),
    AssetID_ (x.AssetID_, f, this),
    Description_ (x.Description_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this),
    interface_ (x.interface_, f, this),
    spoofed_ (x.spoofed_, f, this),
    virtual__ (x.virtual__, f, this),
    ownership_ (x.ownership_, f, this),
    ext_ownership_ (x.ext_ownership_, f, this)
  {
  }

  System::
  System (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Node_ (this),
    NodeRole_ (this),
    Service_ (this),
    OperatingSystem_ (this),
    Counter_ (this),
    AssetID_ (this),
    Description_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    category_ (this),
    ext_category_ (this),
    interface_ (this),
    spoofed_ (this),
    virtual__ (this),
    ownership_ (this),
    ext_ownership_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void System::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Node
      //
      if (n.name () == "Node" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Node_type > r (
          Node_traits::create (i, f, this));

        this->Node_.push_back (r);
        continue;
      }

      // NodeRole
      //
      if (n.name () == "NodeRole" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< NodeRole_type > r (
          NodeRole_traits::create (i, f, this));

        this->NodeRole_.push_back (r);
        continue;
      }

      // Service
      //
      if (n.name () == "Service" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Service_type > r (
          Service_traits::create (i, f, this));

        this->Service_.push_back (r);
        continue;
      }

      // OperatingSystem
      //
      if (n.name () == "OperatingSystem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< OperatingSystem_type > r (
          OperatingSystem_traits::create (i, f, this));

        this->OperatingSystem_.push_back (r);
        continue;
      }

      // Counter
      //
      if (n.name () == "Counter" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Counter_type > r (
          Counter_traits::create (i, f, this));

        this->Counter_.push_back (r);
        continue;
      }

      // AssetID
      //
      if (n.name () == "AssetID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AssetID_type > r (
          AssetID_traits::create (i, f, this));

        this->AssetID_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        this->category_.set (category_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        this->ext_category_.set (ext_category_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "interface" && n.namespace_ ().empty ())
      {
        this->interface_.set (interface_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "spoofed" && n.namespace_ ().empty ())
      {
        this->spoofed_.set (spoofed_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "virtual" && n.namespace_ ().empty ())
      {
        this->virtual__.set (virtual_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ownership" && n.namespace_ ().empty ())
      {
        this->ownership_.set (ownership_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-ownership" && n.namespace_ ().empty ())
      {
        this->ext_ownership_.set (ext_ownership_traits::create (i, f, this));
        continue;
      }
    }

    if (!spoofed_.present ())
    {
      this->spoofed_.set (spoofed_default_value ());
    }

    if (!virtual__.present ())
    {
      this->virtual__.set (virtual_default_value ());
    }
  }

  System* System::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class System (*this, f, c);
  }

  System& System::
  operator= (const System& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Node_ = x.Node_;
      this->NodeRole_ = x.NodeRole_;
      this->Service_ = x.Service_;
      this->OperatingSystem_ = x.OperatingSystem_;
      this->Counter_ = x.Counter_;
      this->AssetID_ = x.AssetID_;
      this->Description_ = x.Description_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
      this->category_ = x.category_;
      this->ext_category_ = x.ext_category_;
      this->interface_ = x.interface_;
      this->spoofed_ = x.spoofed_;
      this->virtual__ = x.virtual__;
      this->ownership_ = x.ownership_;
      this->ext_ownership_ = x.ext_ownership_;
    }

    return *this;
  }

  System::
  ~System ()
  {
  }

  // Node
  //

  Node::
  Node ()
  : ::xml_schema::type (),
    DomainData_ (this),
    Address_ (this),
    PostalAddress_ (this),
    Location_ (this),
    NodeRole_ (this),
    Counter_ (this)
  {
  }

  Node::
  Node (const Node& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DomainData_ (x.DomainData_, f, this),
    Address_ (x.Address_, f, this),
    PostalAddress_ (x.PostalAddress_, f, this),
    Location_ (x.Location_, f, this),
    NodeRole_ (x.NodeRole_, f, this),
    Counter_ (x.Counter_, f, this)
  {
  }

  Node::
  Node (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DomainData_ (this),
    Address_ (this),
    PostalAddress_ (this),
    Location_ (this),
    NodeRole_ (this),
    Counter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Node::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DomainData
      //
      if (n.name () == "DomainData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DomainData_type > r (
          DomainData_traits::create (i, f, this));

        this->DomainData_.push_back (r);
        continue;
      }

      // Address
      //
      if (n.name () == "Address" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        this->Address_.push_back (r);
        continue;
      }

      // PostalAddress
      //
      if (n.name () == "PostalAddress" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< PostalAddress_type > r (
          PostalAddress_traits::create (i, f, this));

        if (!this->PostalAddress_)
        {
          this->PostalAddress_.set (r);
          continue;
        }
      }

      // Location
      //
      if (n.name () == "Location" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Location_type > r (
          Location_traits::create (i, f, this));

        this->Location_.push_back (r);
        continue;
      }

      // NodeRole
      //
      if (n.name () == "NodeRole" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< NodeRole_type > r (
          NodeRole_traits::create (i, f, this));

        this->NodeRole_.push_back (r);
        continue;
      }

      // Counter
      //
      if (n.name () == "Counter" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Counter_type > r (
          Counter_traits::create (i, f, this));

        this->Counter_.push_back (r);
        continue;
      }

      break;
    }
  }

  Node* Node::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Node (*this, f, c);
  }

  Node& Node::
  operator= (const Node& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DomainData_ = x.DomainData_;
      this->Address_ = x.Address_;
      this->PostalAddress_ = x.PostalAddress_;
      this->Location_ = x.Location_;
      this->NodeRole_ = x.NodeRole_;
      this->Counter_ = x.Counter_;
    }

    return *this;
  }

  Node::
  ~Node ()
  {
  }

  // Address
  //

  const Address::category_type Address::category_default_value_ (
    "ipv4-addr");

  Address::
  Address ()
  : ::xml_schema::string (),
    category_ (category_default_value (), this),
    ext_category_ (this),
    vlan_name_ (this),
    vlan_num_ (this),
    observable_id_ (this)
  {
  }

  Address::
  Address (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (category_default_value (), this),
    ext_category_ (this),
    vlan_name_ (this),
    vlan_num_ (this),
    observable_id_ (this)
  {
  }

  Address::
  Address (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (category_default_value (), this),
    ext_category_ (this),
    vlan_name_ (this),
    vlan_num_ (this),
    observable_id_ (this)
  {
  }

  Address::
  Address (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (category_default_value (), this),
    ext_category_ (this),
    vlan_name_ (this),
    vlan_num_ (this),
    observable_id_ (this)
  {
  }

  Address::
  Address (const Address& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this),
    vlan_name_ (x.vlan_name_, f, this),
    vlan_num_ (x.vlan_num_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  Address::
  Address (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    category_ (this),
    ext_category_ (this),
    vlan_name_ (this),
    vlan_num_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Address::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        this->category_.set (category_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        this->ext_category_.set (ext_category_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "vlan-name" && n.namespace_ ().empty ())
      {
        this->vlan_name_.set (vlan_name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "vlan-num" && n.namespace_ ().empty ())
      {
        this->vlan_num_.set (vlan_num_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!category_.present ())
    {
      this->category_.set (category_default_value ());
    }
  }

  Address* Address::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Address (*this, f, c);
  }

  Address& Address::
  operator= (const Address& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->category_ = x.category_;
      this->ext_category_ = x.ext_category_;
      this->vlan_name_ = x.vlan_name_;
      this->vlan_num_ = x.vlan_num_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  Address::
  ~Address ()
  {
  }

  // NodeRole
  //

  NodeRole::
  NodeRole (const category_type& category)
  : ::iodef_2_0::MLStringType (),
    category_ (category, this),
    ext_category_ (this)
  {
  }

  NodeRole::
  NodeRole (const char* _xsd_string_base,
            const category_type& category)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    category_ (category, this),
    ext_category_ (this)
  {
  }

  NodeRole::
  NodeRole (const ::std::string& _xsd_string_base,
            const category_type& category)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    category_ (category, this),
    ext_category_ (this)
  {
  }

  NodeRole::
  NodeRole (const ::xml_schema::string& _xsd_string_base,
            const category_type& category)
  : ::iodef_2_0::MLStringType (_xsd_string_base),
    category_ (category, this),
    ext_category_ (this)
  {
  }

  NodeRole::
  NodeRole (const NodeRole& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::iodef_2_0::MLStringType (x, f, c),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this)
  {
  }

  NodeRole::
  NodeRole (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::iodef_2_0::MLStringType (e, f | ::xml_schema::flags::base, c),
    category_ (this),
    ext_category_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NodeRole::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::iodef_2_0::MLStringType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        this->category_.set (category_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        this->ext_category_.set (ext_category_traits::create (i, f, this));
        continue;
      }
    }

    if (!category_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "category",
        "");
    }
  }

  NodeRole* NodeRole::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NodeRole (*this, f, c);
  }

  NodeRole& NodeRole::
  operator= (const NodeRole& x)
  {
    if (this != &x)
    {
      static_cast< ::iodef_2_0::MLStringType& > (*this) = x;
      this->category_ = x.category_;
      this->ext_category_ = x.ext_category_;
    }

    return *this;
  }

  NodeRole::
  ~NodeRole ()
  {
  }

  // Service
  //

  Service::
  Service (const ip_protocol_type& ip_protocol)
  : ::xml_schema::type (),
    ServiceName_ (this),
    Port_ (this),
    Portlist_ (this),
    ProtoType_ (this),
    ProtoCode_ (this),
    ProtoField_ (this),
    ApplicationHeader_ (this),
    EmailData_ (this),
    Application_ (this),
    ip_protocol_ (ip_protocol, this),
    observable_id_ (this)
  {
  }

  Service::
  Service (const Service& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ServiceName_ (x.ServiceName_, f, this),
    Port_ (x.Port_, f, this),
    Portlist_ (x.Portlist_, f, this),
    ProtoType_ (x.ProtoType_, f, this),
    ProtoCode_ (x.ProtoCode_, f, this),
    ProtoField_ (x.ProtoField_, f, this),
    ApplicationHeader_ (x.ApplicationHeader_, f, this),
    EmailData_ (x.EmailData_, f, this),
    Application_ (x.Application_, f, this),
    ip_protocol_ (x.ip_protocol_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  Service::
  Service (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ServiceName_ (this),
    Port_ (this),
    Portlist_ (this),
    ProtoType_ (this),
    ProtoCode_ (this),
    ProtoField_ (this),
    ApplicationHeader_ (this),
    EmailData_ (this),
    Application_ (this),
    ip_protocol_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Service::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ServiceName
      //
      if (n.name () == "ServiceName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ServiceName_type > r (
          ServiceName_traits::create (i, f, this));

        if (!this->ServiceName_)
        {
          this->ServiceName_.set (r);
          continue;
        }
      }

      // Port
      //
      if (n.name () == "Port" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        if (!this->Port_)
        {
          this->Port_.set (Port_traits::create (i, f, this));
          continue;
        }
      }

      // Portlist
      //
      if (n.name () == "Portlist" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Portlist_type > r (
          Portlist_traits::create (i, f, this));

        if (!this->Portlist_)
        {
          this->Portlist_.set (r);
          continue;
        }
      }

      // ProtoType
      //
      if (n.name () == "ProtoType" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        if (!this->ProtoType_)
        {
          this->ProtoType_.set (ProtoType_traits::create (i, f, this));
          continue;
        }
      }

      // ProtoCode
      //
      if (n.name () == "ProtoCode" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        if (!this->ProtoCode_)
        {
          this->ProtoCode_.set (ProtoCode_traits::create (i, f, this));
          continue;
        }
      }

      // ProtoField
      //
      if (n.name () == "ProtoField" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        if (!this->ProtoField_)
        {
          this->ProtoField_.set (ProtoField_traits::create (i, f, this));
          continue;
        }
      }

      // ApplicationHeader
      //
      if (n.name () == "ApplicationHeader" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ApplicationHeader_type > r (
          ApplicationHeader_traits::create (i, f, this));

        this->ApplicationHeader_.push_back (r);
        continue;
      }

      // EmailData
      //
      if (n.name () == "EmailData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EmailData_type > r (
          EmailData_traits::create (i, f, this));

        if (!this->EmailData_)
        {
          this->EmailData_.set (r);
          continue;
        }
      }

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        if (!this->Application_)
        {
          this->Application_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ip-protocol" && n.namespace_ ().empty ())
      {
        this->ip_protocol_.set (ip_protocol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }

    if (!ip_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ip-protocol",
        "");
    }
  }

  Service* Service::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Service (*this, f, c);
  }

  Service& Service::
  operator= (const Service& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ServiceName_ = x.ServiceName_;
      this->Port_ = x.Port_;
      this->Portlist_ = x.Portlist_;
      this->ProtoType_ = x.ProtoType_;
      this->ProtoCode_ = x.ProtoCode_;
      this->ProtoField_ = x.ProtoField_;
      this->ApplicationHeader_ = x.ApplicationHeader_;
      this->EmailData_ = x.EmailData_;
      this->Application_ = x.Application_;
      this->ip_protocol_ = x.ip_protocol_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  Service::
  ~Service ()
  {
  }

  // ServiceName
  //

  ServiceName::
  ServiceName (const IANAService_type& IANAService)
  : ::xml_schema::type (),
    IANAService_ (IANAService, this),
    URL_ (this),
    Description_ (this)
  {
  }

  ServiceName::
  ServiceName (const ServiceName& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IANAService_ (x.IANAService_, f, this),
    URL_ (x.URL_, f, this),
    Description_ (x.Description_, f, this)
  {
  }

  ServiceName::
  ServiceName (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IANAService_ (this),
    URL_ (this),
    Description_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ServiceName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IANAService
      //
      if (n.name () == "IANAService" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IANAService_type > r (
          IANAService_traits::create (i, f, this));

        if (!IANAService_.present ())
        {
          this->IANAService_.set (r);
          continue;
        }
      }

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        this->URL_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      break;
    }

    if (!IANAService_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IANAService",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }
  }

  ServiceName* ServiceName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ServiceName (*this, f, c);
  }

  ServiceName& ServiceName::
  operator= (const ServiceName& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IANAService_ = x.IANAService_;
      this->URL_ = x.URL_;
      this->Description_ = x.Description_;
    }

    return *this;
  }

  ServiceName::
  ~ServiceName ()
  {
  }

  // Counter
  //

  Counter::
  Counter (const ::xml_schema::double_& _xsd_double__base,
           const type_type& type,
           const unit_type& unit)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
    type_ (type, this),
    unit_ (unit, this),
    ext_type_ (this),
    meaning_ (this),
    duration_ (this),
    ext_duration_ (this)
  {
  }

  Counter::
  Counter (const Counter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    type_ (x.type_, f, this),
    unit_ (x.unit_, f, this),
    ext_type_ (x.ext_type_, f, this),
    meaning_ (x.meaning_, f, this),
    duration_ (x.duration_, f, this),
    ext_duration_ (x.ext_duration_, f, this)
  {
  }

  Counter::
  Counter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    unit_ (this),
    ext_type_ (this),
    meaning_ (this),
    duration_ (this),
    ext_duration_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Counter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        this->unit_.set (unit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        this->ext_type_.set (ext_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        this->meaning_.set (meaning_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-duration" && n.namespace_ ().empty ())
      {
        this->ext_duration_.set (ext_duration_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "unit",
        "");
    }
  }

  Counter* Counter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Counter (*this, f, c);
  }

  Counter& Counter::
  operator= (const Counter& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (*this) = x;
      this->type_ = x.type_;
      this->unit_ = x.unit_;
      this->ext_type_ = x.ext_type_;
      this->meaning_ = x.meaning_;
      this->duration_ = x.duration_;
      this->ext_duration_ = x.ext_duration_;
    }

    return *this;
  }

  Counter::
  ~Counter ()
  {
  }

  // EmailData
  //

  EmailData::
  EmailData ()
  : ::xml_schema::type (),
    EmailFrom_ (this),
    EmailSubject_ (this),
    EmailX_Mailer_ (this),
    EmailHeaderField_ (this),
    HashData_ (this),
    SignatureData_ (this),
    observable_id_ (this)
  {
  }

  EmailData::
  EmailData (const EmailData& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    EmailFrom_ (x.EmailFrom_, f, this),
    EmailSubject_ (x.EmailSubject_, f, this),
    EmailX_Mailer_ (x.EmailX_Mailer_, f, this),
    EmailHeaderField_ (x.EmailHeaderField_, f, this),
    HashData_ (x.HashData_, f, this),
    SignatureData_ (x.SignatureData_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  EmailData::
  EmailData (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    EmailFrom_ (this),
    EmailSubject_ (this),
    EmailX_Mailer_ (this),
    EmailHeaderField_ (this),
    HashData_ (this),
    SignatureData_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EmailData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EmailFrom
      //
      if (n.name () == "EmailFrom" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EmailFrom_type > r (
          EmailFrom_traits::create (i, f, this));

        if (!this->EmailFrom_)
        {
          this->EmailFrom_.set (r);
          continue;
        }
      }

      // EmailSubject
      //
      if (n.name () == "EmailSubject" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EmailSubject_type > r (
          EmailSubject_traits::create (i, f, this));

        if (!this->EmailSubject_)
        {
          this->EmailSubject_.set (r);
          continue;
        }
      }

      // EmailX-Mailer
      //
      if (n.name () == "EmailX-Mailer" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EmailX_Mailer_type > r (
          EmailX_Mailer_traits::create (i, f, this));

        if (!this->EmailX_Mailer_)
        {
          this->EmailX_Mailer_.set (r);
          continue;
        }
      }

      // EmailHeaderField
      //
      if (n.name () == "EmailHeaderField" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EmailHeaderField_type > r (
          EmailHeaderField_traits::create (i, f, this));

        if (!this->EmailHeaderField_)
        {
          this->EmailHeaderField_.set (r);
          continue;
        }
      }

      // HashData
      //
      if (n.name () == "HashData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< HashData_type > r (
          HashData_traits::create (i, f, this));

        if (!this->HashData_)
        {
          this->HashData_.set (r);
          continue;
        }
      }

      // SignatureData
      //
      if (n.name () == "SignatureData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< SignatureData_type > r (
          SignatureData_traits::create (i, f, this));

        if (!this->SignatureData_)
        {
          this->SignatureData_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }
  }

  EmailData* EmailData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EmailData (*this, f, c);
  }

  EmailData& EmailData::
  operator= (const EmailData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->EmailFrom_ = x.EmailFrom_;
      this->EmailSubject_ = x.EmailSubject_;
      this->EmailX_Mailer_ = x.EmailX_Mailer_;
      this->EmailHeaderField_ = x.EmailHeaderField_;
      this->HashData_ = x.HashData_;
      this->SignatureData_ = x.SignatureData_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  EmailData::
  ~EmailData ()
  {
  }

  // DomainData
  //

  DomainData::
  DomainData (const Name_type& Name)
  : ::xml_schema::type (),
    Name_ (Name, this),
    DateDomainWasChecked_ (this),
    RegistrationDate_ (this),
    ExpirationDate_ (this),
    RelatedDNS_ (this),
    Nameservers_ (this),
    DomainContacts_ (this),
    system_status_ (this),
    ext_system_status_ (this),
    domain_status_ (this),
    ext_domain_status_ (this),
    observable_id_ (this)
  {
  }

  DomainData::
  DomainData (const DomainData& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this),
    DateDomainWasChecked_ (x.DateDomainWasChecked_, f, this),
    RegistrationDate_ (x.RegistrationDate_, f, this),
    ExpirationDate_ (x.ExpirationDate_, f, this),
    RelatedDNS_ (x.RelatedDNS_, f, this),
    Nameservers_ (x.Nameservers_, f, this),
    DomainContacts_ (x.DomainContacts_, f, this),
    system_status_ (x.system_status_, f, this),
    ext_system_status_ (x.ext_system_status_, f, this),
    domain_status_ (x.domain_status_, f, this),
    ext_domain_status_ (x.ext_domain_status_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  DomainData::
  DomainData (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (this),
    DateDomainWasChecked_ (this),
    RegistrationDate_ (this),
    ExpirationDate_ (this),
    RelatedDNS_ (this),
    Nameservers_ (this),
    DomainContacts_ (this),
    system_status_ (this),
    ext_system_status_ (this),
    domain_status_ (this),
    ext_domain_status_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DomainData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Name
      //
      if (n.name () == "Name" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Name_type > r (
          Name_traits::create (i, f, this));

        if (!Name_.present ())
        {
          this->Name_.set (r);
          continue;
        }
      }

      // DateDomainWasChecked
      //
      if (n.name () == "DateDomainWasChecked" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DateDomainWasChecked_type > r (
          DateDomainWasChecked_traits::create (i, f, this));

        if (!this->DateDomainWasChecked_)
        {
          this->DateDomainWasChecked_.set (r);
          continue;
        }
      }

      // RegistrationDate
      //
      if (n.name () == "RegistrationDate" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RegistrationDate_type > r (
          RegistrationDate_traits::create (i, f, this));

        if (!this->RegistrationDate_)
        {
          this->RegistrationDate_.set (r);
          continue;
        }
      }

      // ExpirationDate
      //
      if (n.name () == "ExpirationDate" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ExpirationDate_type > r (
          ExpirationDate_traits::create (i, f, this));

        if (!this->ExpirationDate_)
        {
          this->ExpirationDate_.set (r);
          continue;
        }
      }

      // RelatedDNS
      //
      if (n.name () == "RelatedDNS" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RelatedDNS_type > r (
          RelatedDNS_traits::create (i, f, this));

        this->RelatedDNS_.push_back (r);
        continue;
      }

      // Nameservers
      //
      if (n.name () == "Nameservers" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Nameservers_type > r (
          Nameservers_traits::create (i, f, this));

        this->Nameservers_.push_back (r);
        continue;
      }

      // DomainContacts
      //
      if (n.name () == "DomainContacts" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DomainContacts_type > r (
          DomainContacts_traits::create (i, f, this));

        if (!this->DomainContacts_)
        {
          this->DomainContacts_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Name",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "system-status" && n.namespace_ ().empty ())
      {
        this->system_status_.set (system_status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-system-status" && n.namespace_ ().empty ())
      {
        this->ext_system_status_.set (ext_system_status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "domain-status" && n.namespace_ ().empty ())
      {
        this->domain_status_.set (domain_status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-domain-status" && n.namespace_ ().empty ())
      {
        this->ext_domain_status_.set (ext_domain_status_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }
  }

  DomainData* DomainData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DomainData (*this, f, c);
  }

  DomainData& DomainData::
  operator= (const DomainData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Name_ = x.Name_;
      this->DateDomainWasChecked_ = x.DateDomainWasChecked_;
      this->RegistrationDate_ = x.RegistrationDate_;
      this->ExpirationDate_ = x.ExpirationDate_;
      this->RelatedDNS_ = x.RelatedDNS_;
      this->Nameservers_ = x.Nameservers_;
      this->DomainContacts_ = x.DomainContacts_;
      this->system_status_ = x.system_status_;
      this->ext_system_status_ = x.ext_system_status_;
      this->domain_status_ = x.domain_status_;
      this->ext_domain_status_ = x.ext_domain_status_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  DomainData::
  ~DomainData ()
  {
  }

  // RelatedDNS
  //

  RelatedDNS::
  RelatedDNS ()
  : ::xml_schema::string (),
    record_type_ (this)
  {
  }

  RelatedDNS::
  RelatedDNS (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    record_type_ (this)
  {
  }

  RelatedDNS::
  RelatedDNS (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    record_type_ (this)
  {
  }

  RelatedDNS::
  RelatedDNS (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    record_type_ (this)
  {
  }

  RelatedDNS::
  RelatedDNS (const RelatedDNS& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    record_type_ (x.record_type_, f, this)
  {
  }

  RelatedDNS::
  RelatedDNS (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    record_type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RelatedDNS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "record-type" && n.namespace_ ().empty ())
      {
        this->record_type_.set (record_type_traits::create (i, f, this));
        continue;
      }
    }
  }

  RelatedDNS* RelatedDNS::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RelatedDNS (*this, f, c);
  }

  RelatedDNS& RelatedDNS::
  operator= (const RelatedDNS& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->record_type_ = x.record_type_;
    }

    return *this;
  }

  RelatedDNS::
  ~RelatedDNS ()
  {
  }

  // Nameservers
  //

  Nameservers::
  Nameservers (const Server_type& Server)
  : ::xml_schema::type (),
    Server_ (Server, this),
    Address_ (this)
  {
  }

  Nameservers::
  Nameservers (const Nameservers& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Server_ (x.Server_, f, this),
    Address_ (x.Address_, f, this)
  {
  }

  Nameservers::
  Nameservers (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Server_ (this),
    Address_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Nameservers::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Server
      //
      if (n.name () == "Server" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Server_type > r (
          Server_traits::create (i, f, this));

        if (!Server_.present ())
        {
          this->Server_.set (r);
          continue;
        }
      }

      // Address
      //
      if (n.name () == "Address" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        this->Address_.push_back (r);
        continue;
      }

      break;
    }

    if (!Server_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Server",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }
  }

  Nameservers* Nameservers::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Nameservers (*this, f, c);
  }

  Nameservers& Nameservers::
  operator= (const Nameservers& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Server_ = x.Server_;
      this->Address_ = x.Address_;
    }

    return *this;
  }

  Nameservers::
  ~Nameservers ()
  {
  }

  // DomainContacts
  //

  DomainContacts::
  DomainContacts ()
  : ::xml_schema::type (),
    SameDomainContact_ (this),
    Contact_ (this)
  {
  }

  DomainContacts::
  DomainContacts (const DomainContacts& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SameDomainContact_ (x.SameDomainContact_, f, this),
    Contact_ (x.Contact_, f, this)
  {
  }

  DomainContacts::
  DomainContacts (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SameDomainContact_ (this),
    Contact_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DomainContacts::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SameDomainContact
      //
      if (n.name () == "SameDomainContact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< SameDomainContact_type > r (
          SameDomainContact_traits::create (i, f, this));

        if (!this->SameDomainContact_)
        {
          this->SameDomainContact_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        this->Contact_.push_back (r);
        continue;
      }

      break;
    }
  }

  DomainContacts* DomainContacts::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DomainContacts (*this, f, c);
  }

  DomainContacts& DomainContacts::
  operator= (const DomainContacts& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SameDomainContact_ = x.SameDomainContact_;
      this->Contact_ = x.Contact_;
    }

    return *this;
  }

  DomainContacts::
  ~DomainContacts ()
  {
  }

  // Record
  //

  Record::
  Record ()
  : ::xml_schema::type (),
    RecordData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  Record::
  Record (const Record& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    RecordData_ (x.RecordData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  Record::
  Record (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    RecordData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Record::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RecordData
      //
      if (n.name () == "RecordData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RecordData_type > r (
          RecordData_traits::create (i, f, this));

        this->RecordData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  Record* Record::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Record (*this, f, c);
  }

  Record& Record::
  operator= (const Record& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->RecordData_ = x.RecordData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  Record::
  ~Record ()
  {
  }

  // RecordData
  //

  RecordData::
  RecordData ()
  : ::xml_schema::type (),
    DateTime_ (this),
    Description_ (this),
    Application_ (this),
    RecordPattern_ (this),
    RecordItem_ (this),
    FileData_ (this),
    WindowsRegistryKeysModified_ (this),
    CertificateData_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
  }

  RecordData::
  RecordData (const RecordData& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DateTime_ (x.DateTime_, f, this),
    Description_ (x.Description_, f, this),
    Application_ (x.Application_, f, this),
    RecordPattern_ (x.RecordPattern_, f, this),
    RecordItem_ (x.RecordItem_, f, this),
    FileData_ (x.FileData_, f, this),
    WindowsRegistryKeysModified_ (x.WindowsRegistryKeysModified_, f, this),
    CertificateData_ (x.CertificateData_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  RecordData::
  RecordData (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DateTime_ (this),
    Description_ (this),
    Application_ (this),
    RecordPattern_ (this),
    RecordItem_ (this),
    FileData_ (this),
    WindowsRegistryKeysModified_ (this),
    CertificateData_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RecordData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DateTime
      //
      if (n.name () == "DateTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DateTime_type > r (
          DateTime_traits::create (i, f, this));

        if (!this->DateTime_)
        {
          this->DateTime_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        if (!this->Application_)
        {
          this->Application_.set (r);
          continue;
        }
      }

      // RecordPattern
      //
      if (n.name () == "RecordPattern" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RecordPattern_type > r (
          RecordPattern_traits::create (i, f, this));

        this->RecordPattern_.push_back (r);
        continue;
      }

      // RecordItem
      //
      if (n.name () == "RecordItem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RecordItem_type > r (
          RecordItem_traits::create (i, f, this));

        this->RecordItem_.push_back (r);
        continue;
      }

      // FileData
      //
      if (n.name () == "FileData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< FileData_type > r (
          FileData_traits::create (i, f, this));

        this->FileData_.push_back (r);
        continue;
      }

      // WindowsRegistryKeysModified
      //
      if (n.name () == "WindowsRegistryKeysModified" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< WindowsRegistryKeysModified_type > r (
          WindowsRegistryKeysModified_traits::create (i, f, this));

        this->WindowsRegistryKeysModified_.push_back (r);
        continue;
      }

      // CertificateData
      //
      if (n.name () == "CertificateData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< CertificateData_type > r (
          CertificateData_traits::create (i, f, this));

        this->CertificateData_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }
  }

  RecordData* RecordData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordData (*this, f, c);
  }

  RecordData& RecordData::
  operator= (const RecordData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DateTime_ = x.DateTime_;
      this->Description_ = x.Description_;
      this->Application_ = x.Application_;
      this->RecordPattern_ = x.RecordPattern_;
      this->RecordItem_ = x.RecordItem_;
      this->FileData_ = x.FileData_;
      this->WindowsRegistryKeysModified_ = x.WindowsRegistryKeysModified_;
      this->CertificateData_ = x.CertificateData_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  RecordData::
  ~RecordData ()
  {
  }

  // RecordPattern
  //

  const RecordPattern::offsetunit_type RecordPattern::offsetunit_default_value_ (
    "line");

  RecordPattern::
  RecordPattern (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, this),
    ext_type_ (this),
    offset_ (this),
    offsetunit_ (offsetunit_default_value (), this),
    ext_offsetunit_ (this),
    instance_ (this)
  {
  }

  RecordPattern::
  RecordPattern (const char* _xsd_string_base,
                 const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    ext_type_ (this),
    offset_ (this),
    offsetunit_ (offsetunit_default_value (), this),
    ext_offsetunit_ (this),
    instance_ (this)
  {
  }

  RecordPattern::
  RecordPattern (const ::std::string& _xsd_string_base,
                 const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    ext_type_ (this),
    offset_ (this),
    offsetunit_ (offsetunit_default_value (), this),
    ext_offsetunit_ (this),
    instance_ (this)
  {
  }

  RecordPattern::
  RecordPattern (const ::xml_schema::string& _xsd_string_base,
                 const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    ext_type_ (this),
    offset_ (this),
    offsetunit_ (offsetunit_default_value (), this),
    ext_offsetunit_ (this),
    instance_ (this)
  {
  }

  RecordPattern::
  RecordPattern (const RecordPattern& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    offset_ (x.offset_, f, this),
    offsetunit_ (x.offsetunit_, f, this),
    ext_offsetunit_ (x.ext_offsetunit_, f, this),
    instance_ (x.instance_, f, this)
  {
  }

  RecordPattern::
  RecordPattern (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    ext_type_ (this),
    offset_ (this),
    offsetunit_ (this),
    ext_offsetunit_ (this),
    instance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RecordPattern::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        this->ext_type_.set (ext_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        this->offset_.set (offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "offsetunit" && n.namespace_ ().empty ())
      {
        this->offsetunit_.set (offsetunit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-offsetunit" && n.namespace_ ().empty ())
      {
        this->ext_offsetunit_.set (ext_offsetunit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "instance" && n.namespace_ ().empty ())
      {
        this->instance_.set (instance_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!offsetunit_.present ())
    {
      this->offsetunit_.set (offsetunit_default_value ());
    }
  }

  RecordPattern* RecordPattern::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordPattern (*this, f, c);
  }

  RecordPattern& RecordPattern::
  operator= (const RecordPattern& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
      this->ext_type_ = x.ext_type_;
      this->offset_ = x.offset_;
      this->offsetunit_ = x.offsetunit_;
      this->ext_offsetunit_ = x.ext_offsetunit_;
      this->instance_ = x.instance_;
    }

    return *this;
  }

  RecordPattern::
  ~RecordPattern ()
  {
  }

  // WindowsRegistryKeysModified
  //

  WindowsRegistryKeysModified::
  WindowsRegistryKeysModified ()
  : ::xml_schema::type (),
    Key_ (this),
    observable_id_ (this)
  {
  }

  WindowsRegistryKeysModified::
  WindowsRegistryKeysModified (const WindowsRegistryKeysModified& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Key_ (x.Key_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  WindowsRegistryKeysModified::
  WindowsRegistryKeysModified (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Key_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void WindowsRegistryKeysModified::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Key
      //
      if (n.name () == "Key" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Key_type > r (
          Key_traits::create (i, f, this));

        this->Key_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }
  }

  WindowsRegistryKeysModified* WindowsRegistryKeysModified::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class WindowsRegistryKeysModified (*this, f, c);
  }

  WindowsRegistryKeysModified& WindowsRegistryKeysModified::
  operator= (const WindowsRegistryKeysModified& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Key_ = x.Key_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  WindowsRegistryKeysModified::
  ~WindowsRegistryKeysModified ()
  {
  }

  // Key
  //

  Key::
  Key (const KeyName_type& KeyName)
  : ::xml_schema::type (),
    KeyName_ (KeyName, this),
    Value_ (this),
    registryaction_ (this),
    ext_registryaction_ (this)
  {
  }

  Key::
  Key (const Key& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    KeyName_ (x.KeyName_, f, this),
    Value_ (x.Value_, f, this),
    registryaction_ (x.registryaction_, f, this),
    ext_registryaction_ (x.ext_registryaction_, f, this)
  {
  }

  Key::
  Key (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    KeyName_ (this),
    Value_ (this),
    registryaction_ (this),
    ext_registryaction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Key::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // KeyName
      //
      if (n.name () == "KeyName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< KeyName_type > r (
          KeyName_traits::create (i, f, this));

        if (!KeyName_.present ())
        {
          this->KeyName_.set (r);
          continue;
        }
      }

      // Value
      //
      if (n.name () == "Value" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Value_type > r (
          Value_traits::create (i, f, this));

        if (!this->Value_)
        {
          this->Value_.set (r);
          continue;
        }
      }

      break;
    }

    if (!KeyName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "KeyName",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "registryaction" && n.namespace_ ().empty ())
      {
        this->registryaction_.set (registryaction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-registryaction" && n.namespace_ ().empty ())
      {
        this->ext_registryaction_.set (ext_registryaction_traits::create (i, f, this));
        continue;
      }
    }
  }

  Key* Key::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Key (*this, f, c);
  }

  Key& Key::
  operator= (const Key& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->KeyName_ = x.KeyName_;
      this->Value_ = x.Value_;
      this->registryaction_ = x.registryaction_;
      this->ext_registryaction_ = x.ext_registryaction_;
    }

    return *this;
  }

  Key::
  ~Key ()
  {
  }

  // FileData
  //

  FileData::
  FileData ()
  : ::xml_schema::type (),
    File_ (this),
    observable_id_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  FileData::
  FileData (const FileData& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    File_ (x.File_, f, this),
    observable_id_ (x.observable_id_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  FileData::
  FileData (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    File_ (this),
    observable_id_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FileData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // File
      //
      if (n.name () == "File" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< File_type > r (
          File_traits::create (i, f, this));

        this->File_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  FileData* FileData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FileData (*this, f, c);
  }

  FileData& FileData::
  operator= (const FileData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->File_ = x.File_;
      this->observable_id_ = x.observable_id_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  FileData::
  ~FileData ()
  {
  }

  // File
  //

  File::
  File ()
  : ::xml_schema::type (),
    FileName_ (this),
    FileSize_ (this),
    FileType_ (this),
    URL_ (this),
    HashData_ (this),
    Signature_ (this),
    Application_ (this),
    FileProperties_ (this),
    observable_id_ (this)
  {
  }

  File::
  File (const File& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FileName_ (x.FileName_, f, this),
    FileSize_ (x.FileSize_, f, this),
    FileType_ (x.FileType_, f, this),
    URL_ (x.URL_, f, this),
    HashData_ (x.HashData_, f, this),
    Signature_ (x.Signature_, f, this),
    Application_ (x.Application_, f, this),
    FileProperties_ (x.FileProperties_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  File::
  File (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FileName_ (this),
    FileSize_ (this),
    FileType_ (this),
    URL_ (this),
    HashData_ (this),
    Signature_ (this),
    Application_ (this),
    FileProperties_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void File::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FileName
      //
      if (n.name () == "FileName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< FileName_type > r (
          FileName_traits::create (i, f, this));

        if (!this->FileName_)
        {
          this->FileName_.set (r);
          continue;
        }
      }

      // FileSize
      //
      if (n.name () == "FileSize" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        if (!this->FileSize_)
        {
          this->FileSize_.set (FileSize_traits::create (i, f, this));
          continue;
        }
      }

      // FileType
      //
      if (n.name () == "FileType" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        if (!this->FileType_)
        {
          this->FileType_.set (FileType_traits::create (i, f, this));
          continue;
        }
      }

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        this->URL_.push_back (r);
        continue;
      }

      // HashData
      //
      if (n.name () == "HashData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< HashData_type > r (
          HashData_traits::create (i, f, this));

        if (!this->HashData_)
        {
          this->HashData_.set (r);
          continue;
        }
      }

      // Signature
      //
      if (n.name () == "Signature" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< Signature_type > r (
          Signature_traits::create (i, f, this));

        if (!this->Signature_)
        {
          this->Signature_.set (r);
          continue;
        }
      }

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        if (!this->Application_)
        {
          this->Application_.set (r);
          continue;
        }
      }

      // FileProperties
      //
      if (n.name () == "FileProperties" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< FileProperties_type > r (
          FileProperties_traits::create (i, f, this));

        this->FileProperties_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }
  }

  File* File::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class File (*this, f, c);
  }

  File& File::
  operator= (const File& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FileName_ = x.FileName_;
      this->FileSize_ = x.FileSize_;
      this->FileType_ = x.FileType_;
      this->URL_ = x.URL_;
      this->HashData_ = x.HashData_;
      this->Signature_ = x.Signature_;
      this->Application_ = x.Application_;
      this->FileProperties_ = x.FileProperties_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  File::
  ~File ()
  {
  }

  // HashData
  //

  HashData::
  HashData (const scope_type& scope)
  : ::xml_schema::type (),
    HashTarget_ (this),
    Hash_ (this),
    FuzzyHash_ (this),
    scope_ (scope, this),
    ext_scope_ (this)
  {
  }

  HashData::
  HashData (const HashData& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    HashTarget_ (x.HashTarget_, f, this),
    Hash_ (x.Hash_, f, this),
    FuzzyHash_ (x.FuzzyHash_, f, this),
    scope_ (x.scope_, f, this),
    ext_scope_ (x.ext_scope_, f, this)
  {
  }

  HashData::
  HashData (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    HashTarget_ (this),
    Hash_ (this),
    FuzzyHash_ (this),
    scope_ (this),
    ext_scope_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void HashData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HashTarget
      //
      if (n.name () == "HashTarget" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< HashTarget_type > r (
          HashTarget_traits::create (i, f, this));

        if (!this->HashTarget_)
        {
          this->HashTarget_.set (r);
          continue;
        }
      }

      // Hash
      //
      if (n.name () == "Hash" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Hash_type > r (
          Hash_traits::create (i, f, this));

        this->Hash_.push_back (r);
        continue;
      }

      // FuzzyHash
      //
      if (n.name () == "FuzzyHash" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< FuzzyHash_type > r (
          FuzzyHash_traits::create (i, f, this));

        this->FuzzyHash_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (scope_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-scope" && n.namespace_ ().empty ())
      {
        this->ext_scope_.set (ext_scope_traits::create (i, f, this));
        continue;
      }
    }

    if (!scope_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "scope",
        "");
    }
  }

  HashData* HashData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HashData (*this, f, c);
  }

  HashData& HashData::
  operator= (const HashData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->HashTarget_ = x.HashTarget_;
      this->Hash_ = x.Hash_;
      this->FuzzyHash_ = x.FuzzyHash_;
      this->scope_ = x.scope_;
      this->ext_scope_ = x.ext_scope_;
    }

    return *this;
  }

  HashData::
  ~HashData ()
  {
  }

  // Hash
  //

  Hash::
  Hash (const DigestMethod_type& DigestMethod,
        const DigestValue_type& DigestValue,
        const CanonicalizationMethod_type& CanonicalizationMethod)
  : ::xml_schema::type (),
    DigestMethod_ (DigestMethod, this),
    DigestValue_ (DigestValue, this),
    CanonicalizationMethod_ (CanonicalizationMethod, this),
    Application_ (this)
  {
  }

  Hash::
  Hash (::std::auto_ptr< DigestMethod_type > DigestMethod,
        const DigestValue_type& DigestValue,
        ::std::auto_ptr< CanonicalizationMethod_type > CanonicalizationMethod)
  : ::xml_schema::type (),
    DigestMethod_ (DigestMethod, this),
    DigestValue_ (DigestValue, this),
    CanonicalizationMethod_ (CanonicalizationMethod, this),
    Application_ (this)
  {
  }

  Hash::
  Hash (const Hash& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DigestMethod_ (x.DigestMethod_, f, this),
    DigestValue_ (x.DigestValue_, f, this),
    CanonicalizationMethod_ (x.CanonicalizationMethod_, f, this),
    Application_ (x.Application_, f, this)
  {
  }

  Hash::
  Hash (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DigestMethod_ (this),
    DigestValue_ (this),
    CanonicalizationMethod_ (this),
    Application_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Hash::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DigestMethod
      //
      if (n.name () == "DigestMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< DigestMethod_type > r (
          DigestMethod_traits::create (i, f, this));

        if (!DigestMethod_.present ())
        {
          this->DigestMethod_.set (r);
          continue;
        }
      }

      // DigestValue
      //
      if (n.name () == "DigestValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< DigestValue_type > r (
          DigestValue_traits::create (i, f, this));

        if (!DigestValue_.present ())
        {
          this->DigestValue_.set (r);
          continue;
        }
      }

      // CanonicalizationMethod
      //
      if (n.name () == "CanonicalizationMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< CanonicalizationMethod_type > r (
          CanonicalizationMethod_traits::create (i, f, this));

        if (!CanonicalizationMethod_.present ())
        {
          this->CanonicalizationMethod_.set (r);
          continue;
        }
      }

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        if (!this->Application_)
        {
          this->Application_.set (r);
          continue;
        }
      }

      break;
    }

    if (!DigestMethod_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DigestMethod",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    if (!DigestValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DigestValue",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    if (!CanonicalizationMethod_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CanonicalizationMethod",
        "http://www.w3.org/2000/09/xmldsig#");
    }
  }

  Hash* Hash::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Hash (*this, f, c);
  }

  Hash& Hash::
  operator= (const Hash& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DigestMethod_ = x.DigestMethod_;
      this->DigestValue_ = x.DigestValue_;
      this->CanonicalizationMethod_ = x.CanonicalizationMethod_;
      this->Application_ = x.Application_;
    }

    return *this;
  }

  Hash::
  ~Hash ()
  {
  }

  // FuzzyHash
  //

  FuzzyHash::
  FuzzyHash (const AdditionalData_type& AdditionalData)
  : ::xml_schema::type (),
    AdditionalData_ (AdditionalData, this),
    Application_ (this)
  {
  }

  FuzzyHash::
  FuzzyHash (::std::auto_ptr< AdditionalData_type > AdditionalData)
  : ::xml_schema::type (),
    AdditionalData_ (AdditionalData, this),
    Application_ (this)
  {
  }

  FuzzyHash::
  FuzzyHash (const FuzzyHash& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AdditionalData_ (x.AdditionalData_, f, this),
    Application_ (x.Application_, f, this)
  {
  }

  FuzzyHash::
  FuzzyHash (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AdditionalData_ (this),
    Application_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FuzzyHash::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        if (!AdditionalData_.present ())
        {
          this->AdditionalData_.set (r);
          continue;
        }
      }

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        if (!this->Application_)
        {
          this->Application_.set (r);
          continue;
        }
      }

      break;
    }

    if (!AdditionalData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AdditionalData",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }
  }

  FuzzyHash* FuzzyHash::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FuzzyHash (*this, f, c);
  }

  FuzzyHash& FuzzyHash::
  operator= (const FuzzyHash& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AdditionalData_ = x.AdditionalData_;
      this->Application_ = x.Application_;
    }

    return *this;
  }

  FuzzyHash::
  ~FuzzyHash ()
  {
  }

  // SignatureData
  //

  SignatureData::
  SignatureData ()
  : ::xml_schema::type (),
    Signature_ (this)
  {
  }

  SignatureData::
  SignatureData (const SignatureData& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Signature_ (x.Signature_, f, this)
  {
  }

  SignatureData::
  SignatureData (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Signature_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SignatureData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Signature
      //
      if (n.name () == "Signature" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< Signature_type > r (
          Signature_traits::create (i, f, this));

        this->Signature_.push_back (r);
        continue;
      }

      break;
    }
  }

  SignatureData* SignatureData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SignatureData (*this, f, c);
  }

  SignatureData& SignatureData::
  operator= (const SignatureData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Signature_ = x.Signature_;
    }

    return *this;
  }

  SignatureData::
  ~SignatureData ()
  {
  }

  // CertificateData
  //

  CertificateData::
  CertificateData ()
  : ::xml_schema::type (),
    Certificate_ (this),
    observable_id_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  CertificateData::
  CertificateData (const CertificateData& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Certificate_ (x.Certificate_, f, this),
    observable_id_ (x.observable_id_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  CertificateData::
  CertificateData (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Certificate_ (this),
    observable_id_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CertificateData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Certificate
      //
      if (n.name () == "Certificate" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Certificate_type > r (
          Certificate_traits::create (i, f, this));

        this->Certificate_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  CertificateData* CertificateData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CertificateData (*this, f, c);
  }

  CertificateData& CertificateData::
  operator= (const CertificateData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Certificate_ = x.Certificate_;
      this->observable_id_ = x.observable_id_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  CertificateData::
  ~CertificateData ()
  {
  }

  // Certificate
  //

  Certificate::
  Certificate (const X509Data_type& X509Data)
  : ::xml_schema::type (),
    X509Data_ (X509Data, this),
    observable_id_ (this)
  {
  }

  Certificate::
  Certificate (::std::auto_ptr< X509Data_type > X509Data)
  : ::xml_schema::type (),
    X509Data_ (X509Data, this),
    observable_id_ (this)
  {
  }

  Certificate::
  Certificate (const Certificate& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    X509Data_ (x.X509Data_, f, this),
    observable_id_ (x.observable_id_, f, this)
  {
  }

  Certificate::
  Certificate (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    X509Data_ (this),
    observable_id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Certificate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // X509Data
      //
      if (n.name () == "X509Data" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< X509Data_type > r (
          X509Data_traits::create (i, f, this));

        if (!X509Data_.present ())
        {
          this->X509Data_.set (r);
          continue;
        }
      }

      break;
    }

    if (!X509Data_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "X509Data",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "observable-id" && n.namespace_ ().empty ())
      {
        this->observable_id_.set (observable_id_traits::create (i, f, this));
        continue;
      }
    }
  }

  Certificate* Certificate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Certificate (*this, f, c);
  }

  Certificate& Certificate::
  operator= (const Certificate& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->X509Data_ = x.X509Data_;
      this->observable_id_ = x.observable_id_;
    }

    return *this;
  }

  Certificate::
  ~Certificate ()
  {
  }

  // SoftwareReference
  //

  SoftwareReference::
  SoftwareReference (const spec_name_type& spec_name)
  : ::xml_schema::type (),
    spec_name_ (spec_name, this),
    ext_spec_name_ (this),
    dtype_ (this),
    ext_dtype_ (this)
  {
  }

  SoftwareReference::
  SoftwareReference (const SoftwareReference& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    spec_name_ (x.spec_name_, f, this),
    ext_spec_name_ (x.ext_spec_name_, f, this),
    dtype_ (x.dtype_, f, this),
    ext_dtype_ (x.ext_dtype_, f, this)
  {
  }

  SoftwareReference::
  SoftwareReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    spec_name_ (this),
    ext_spec_name_ (this),
    dtype_ (this),
    ext_dtype_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SoftwareReference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "spec-name" && n.namespace_ ().empty ())
      {
        this->spec_name_.set (spec_name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-spec-name" && n.namespace_ ().empty ())
      {
        this->ext_spec_name_.set (ext_spec_name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dtype" && n.namespace_ ().empty ())
      {
        this->dtype_.set (dtype_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-dtype" && n.namespace_ ().empty ())
      {
        this->ext_dtype_.set (ext_dtype_traits::create (i, f, this));
        continue;
      }
    }

    if (!spec_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spec-name",
        "");
    }
  }

  SoftwareReference* SoftwareReference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SoftwareReference (*this, f, c);
  }

  SoftwareReference& SoftwareReference::
  operator= (const SoftwareReference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->spec_name_ = x.spec_name_;
      this->ext_spec_name_ = x.ext_spec_name_;
      this->dtype_ = x.dtype_;
      this->ext_dtype_ = x.ext_dtype_;
    }

    return *this;
  }

  SoftwareReference::
  ~SoftwareReference ()
  {
  }

  // IndicatorData
  //

  IndicatorData::
  IndicatorData ()
  : ::xml_schema::type (),
    Indicator_ (this)
  {
  }

  IndicatorData::
  IndicatorData (const IndicatorData& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Indicator_ (x.Indicator_, f, this)
  {
  }

  IndicatorData::
  IndicatorData (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Indicator_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void IndicatorData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Indicator
      //
      if (n.name () == "Indicator" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Indicator_type > r (
          Indicator_traits::create (i, f, this));

        this->Indicator_.push_back (r);
        continue;
      }

      break;
    }
  }

  IndicatorData* IndicatorData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IndicatorData (*this, f, c);
  }

  IndicatorData& IndicatorData::
  operator= (const IndicatorData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Indicator_ = x.Indicator_;
    }

    return *this;
  }

  IndicatorData::
  ~IndicatorData ()
  {
  }

  // Indicator
  //

  Indicator::
  Indicator (const IndicatorID_type& IndicatorID)
  : ::xml_schema::type (),
    IndicatorID_ (IndicatorID, this),
    AlternativeIndicatorID_ (this),
    Description_ (this),
    StartTime_ (this),
    EndTime_ (this),
    Confidence_ (this),
    Contact_ (this),
    Observable_ (this),
    ObservableReference_ (this),
    IndicatorExpression_ (this),
    IndicatorReference_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  Indicator::
  Indicator (::std::auto_ptr< IndicatorID_type > IndicatorID)
  : ::xml_schema::type (),
    IndicatorID_ (IndicatorID, this),
    AlternativeIndicatorID_ (this),
    Description_ (this),
    StartTime_ (this),
    EndTime_ (this),
    Confidence_ (this),
    Contact_ (this),
    Observable_ (this),
    ObservableReference_ (this),
    IndicatorExpression_ (this),
    IndicatorReference_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  Indicator::
  Indicator (const Indicator& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IndicatorID_ (x.IndicatorID_, f, this),
    AlternativeIndicatorID_ (x.AlternativeIndicatorID_, f, this),
    Description_ (x.Description_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    Confidence_ (x.Confidence_, f, this),
    Contact_ (x.Contact_, f, this),
    Observable_ (x.Observable_, f, this),
    ObservableReference_ (x.ObservableReference_, f, this),
    IndicatorExpression_ (x.IndicatorExpression_, f, this),
    IndicatorReference_ (x.IndicatorReference_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  Indicator::
  Indicator (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IndicatorID_ (this),
    AlternativeIndicatorID_ (this),
    Description_ (this),
    StartTime_ (this),
    EndTime_ (this),
    Confidence_ (this),
    Contact_ (this),
    Observable_ (this),
    ObservableReference_ (this),
    IndicatorExpression_ (this),
    IndicatorReference_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Indicator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IndicatorID
      //
      if (n.name () == "IndicatorID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IndicatorID_type > r (
          IndicatorID_traits::create (i, f, this));

        if (!IndicatorID_.present ())
        {
          this->IndicatorID_.set (r);
          continue;
        }
      }

      // AlternativeIndicatorID
      //
      if (n.name () == "AlternativeIndicatorID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AlternativeIndicatorID_type > r (
          AlternativeIndicatorID_traits::create (i, f, this));

        this->AlternativeIndicatorID_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // Confidence
      //
      if (n.name () == "Confidence" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Confidence_type > r (
          Confidence_traits::create (i, f, this));

        if (!this->Confidence_)
        {
          this->Confidence_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        this->Contact_.push_back (r);
        continue;
      }

      // Observable
      //
      if (n.name () == "Observable" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Observable_type > r (
          Observable_traits::create (i, f, this));

        if (!this->Observable_)
        {
          this->Observable_.set (r);
          continue;
        }
      }

      // ObservableReference
      //
      if (n.name () == "ObservableReference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ObservableReference_type > r (
          ObservableReference_traits::create (i, f, this));

        if (!this->ObservableReference_)
        {
          this->ObservableReference_.set (r);
          continue;
        }
      }

      // IndicatorExpression
      //
      if (n.name () == "IndicatorExpression" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IndicatorExpression_type > r (
          IndicatorExpression_traits::create (i, f, this));

        if (!this->IndicatorExpression_)
        {
          this->IndicatorExpression_.set (r);
          continue;
        }
      }

      // IndicatorReference
      //
      if (n.name () == "IndicatorReference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IndicatorReference_type > r (
          IndicatorReference_traits::create (i, f, this));

        if (!this->IndicatorReference_)
        {
          this->IndicatorReference_.set (r);
          continue;
        }
      }

      break;
    }

    if (!IndicatorID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IndicatorID",
        "urn:ietf:params:xml:ns:iodef-2.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  Indicator* Indicator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Indicator (*this, f, c);
  }

  Indicator& Indicator::
  operator= (const Indicator& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IndicatorID_ = x.IndicatorID_;
      this->AlternativeIndicatorID_ = x.AlternativeIndicatorID_;
      this->Description_ = x.Description_;
      this->StartTime_ = x.StartTime_;
      this->EndTime_ = x.EndTime_;
      this->Confidence_ = x.Confidence_;
      this->Contact_ = x.Contact_;
      this->Observable_ = x.Observable_;
      this->ObservableReference_ = x.ObservableReference_;
      this->IndicatorExpression_ = x.IndicatorExpression_;
      this->IndicatorReference_ = x.IndicatorReference_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  Indicator::
  ~Indicator ()
  {
  }

  // IndicatorID
  //

  IndicatorID::
  IndicatorID (const ::xml_schema::id& _xsd_id_base,
               const name_type& name,
               const version_type& version)
  : ::xml_schema::id (_xsd_id_base),
    name_ (name, this),
    version_ (version, this)
  {
  }

  IndicatorID::
  IndicatorID (const IndicatorID& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::id (x, f, c),
    name_ (x.name_, f, this),
    version_ (x.version_, f, this)
  {
  }

  IndicatorID::
  IndicatorID (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::id (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    version_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IndicatorID::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }
  }

  IndicatorID* IndicatorID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IndicatorID (*this, f, c);
  }

  IndicatorID& IndicatorID::
  operator= (const IndicatorID& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::id& > (*this) = x;
      this->name_ = x.name_;
      this->version_ = x.version_;
    }

    return *this;
  }

  IndicatorID::
  ~IndicatorID ()
  {
  }

  // AlternativeIndicatorID
  //

  AlternativeIndicatorID::
  AlternativeIndicatorID ()
  : ::xml_schema::type (),
    IndicatorID_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  AlternativeIndicatorID::
  AlternativeIndicatorID (const AlternativeIndicatorID& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IndicatorID_ (x.IndicatorID_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  AlternativeIndicatorID::
  AlternativeIndicatorID (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IndicatorID_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlternativeIndicatorID::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IndicatorID
      //
      if (n.name () == "IndicatorID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IndicatorID_type > r (
          IndicatorID_traits::create (i, f, this));

        this->IndicatorID_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  AlternativeIndicatorID* AlternativeIndicatorID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlternativeIndicatorID (*this, f, c);
  }

  AlternativeIndicatorID& AlternativeIndicatorID::
  operator= (const AlternativeIndicatorID& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IndicatorID_ = x.IndicatorID_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  AlternativeIndicatorID::
  ~AlternativeIndicatorID ()
  {
  }

  // Observable
  //

  Observable::
  Observable ()
  : ::xml_schema::type (),
    Address_ (this),
    DomainData_ (this),
    EmailData_ (this),
    ApplicationHeader_ (this),
    WindowsRegistryKeysModified_ (this),
    FileData_ (this),
    CertificateData_ (this),
    RegistryHandle_ (this),
    RecordData_ (this),
    EventData_ (this),
    Incident_ (this),
    Expectation_ (this),
    Reference_ (this),
    Assessment_ (this),
    HistoryItem_ (this),
    BulkObservable_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
  }

  Observable::
  Observable (const Observable& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Address_ (x.Address_, f, this),
    DomainData_ (x.DomainData_, f, this),
    EmailData_ (x.EmailData_, f, this),
    ApplicationHeader_ (x.ApplicationHeader_, f, this),
    WindowsRegistryKeysModified_ (x.WindowsRegistryKeysModified_, f, this),
    FileData_ (x.FileData_, f, this),
    CertificateData_ (x.CertificateData_, f, this),
    RegistryHandle_ (x.RegistryHandle_, f, this),
    RecordData_ (x.RecordData_, f, this),
    EventData_ (x.EventData_, f, this),
    Incident_ (x.Incident_, f, this),
    Expectation_ (x.Expectation_, f, this),
    Reference_ (x.Reference_, f, this),
    Assessment_ (x.Assessment_, f, this),
    HistoryItem_ (x.HistoryItem_, f, this),
    BulkObservable_ (x.BulkObservable_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    ext_restriction_ (x.ext_restriction_, f, this)
  {
  }

  Observable::
  Observable (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Address_ (this),
    DomainData_ (this),
    EmailData_ (this),
    ApplicationHeader_ (this),
    WindowsRegistryKeysModified_ (this),
    FileData_ (this),
    CertificateData_ (this),
    RegistryHandle_ (this),
    RecordData_ (this),
    EventData_ (this),
    Incident_ (this),
    Expectation_ (this),
    Reference_ (this),
    Assessment_ (this),
    HistoryItem_ (this),
    BulkObservable_ (this),
    AdditionalData_ (this),
    restriction_ (this),
    ext_restriction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Observable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Address
      //
      if (n.name () == "Address" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        if (!this->Address_)
        {
          this->Address_.set (r);
          continue;
        }
      }

      // DomainData
      //
      if (n.name () == "DomainData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< DomainData_type > r (
          DomainData_traits::create (i, f, this));

        if (!this->DomainData_)
        {
          this->DomainData_.set (r);
          continue;
        }
      }

      // EmailData
      //
      if (n.name () == "EmailData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EmailData_type > r (
          EmailData_traits::create (i, f, this));

        if (!this->EmailData_)
        {
          this->EmailData_.set (r);
          continue;
        }
      }

      // ApplicationHeader
      //
      if (n.name () == "ApplicationHeader" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ApplicationHeader_type > r (
          ApplicationHeader_traits::create (i, f, this));

        if (!this->ApplicationHeader_)
        {
          this->ApplicationHeader_.set (r);
          continue;
        }
      }

      // WindowsRegistryKeysModified
      //
      if (n.name () == "WindowsRegistryKeysModified" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< WindowsRegistryKeysModified_type > r (
          WindowsRegistryKeysModified_traits::create (i, f, this));

        if (!this->WindowsRegistryKeysModified_)
        {
          this->WindowsRegistryKeysModified_.set (r);
          continue;
        }
      }

      // FileData
      //
      if (n.name () == "FileData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< FileData_type > r (
          FileData_traits::create (i, f, this));

        if (!this->FileData_)
        {
          this->FileData_.set (r);
          continue;
        }
      }

      // CertificateData
      //
      if (n.name () == "CertificateData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< CertificateData_type > r (
          CertificateData_traits::create (i, f, this));

        if (!this->CertificateData_)
        {
          this->CertificateData_.set (r);
          continue;
        }
      }

      // RegistryHandle
      //
      if (n.name () == "RegistryHandle" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RegistryHandle_type > r (
          RegistryHandle_traits::create (i, f, this));

        if (!this->RegistryHandle_)
        {
          this->RegistryHandle_.set (r);
          continue;
        }
      }

      // RecordData
      //
      if (n.name () == "RecordData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< RecordData_type > r (
          RecordData_traits::create (i, f, this));

        if (!this->RecordData_)
        {
          this->RecordData_.set (r);
          continue;
        }
      }

      // EventData
      //
      if (n.name () == "EventData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< EventData_type > r (
          EventData_traits::create (i, f, this));

        if (!this->EventData_)
        {
          this->EventData_.set (r);
          continue;
        }
      }

      // Incident
      //
      if (n.name () == "Incident" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Incident_type > r (
          Incident_traits::create (i, f, this));

        if (!this->Incident_)
        {
          this->Incident_.set (r);
          continue;
        }
      }

      // Expectation
      //
      if (n.name () == "Expectation" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Expectation_type > r (
          Expectation_traits::create (i, f, this));

        this->Expectation_.push_back (r);
        continue;
      }

      // Reference
      //
      if (n.name () == "Reference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Reference_type > r (
          Reference_traits::create (i, f, this));

        this->Reference_.push_back (r);
        continue;
      }

      // Assessment
      //
      if (n.name () == "Assessment" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Assessment_type > r (
          Assessment_traits::create (i, f, this));

        if (!this->Assessment_)
        {
          this->Assessment_.set (r);
          continue;
        }
      }

      // HistoryItem
      //
      if (n.name () == "HistoryItem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< HistoryItem_type > r (
          HistoryItem_traits::create (i, f, this));

        if (!this->HistoryItem_)
        {
          this->HistoryItem_.set (r);
          continue;
        }
      }

      // BulkObservable
      //
      if (n.name () == "BulkObservable" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< BulkObservable_type > r (
          BulkObservable_traits::create (i, f, this));

        if (!this->BulkObservable_)
        {
          this->BulkObservable_.set (r);
          continue;
        }
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        if (!this->AdditionalData_)
        {
          this->AdditionalData_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        this->restriction_.set (restriction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-restriction" && n.namespace_ ().empty ())
      {
        this->ext_restriction_.set (ext_restriction_traits::create (i, f, this));
        continue;
      }
    }
  }

  Observable* Observable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Observable (*this, f, c);
  }

  Observable& Observable::
  operator= (const Observable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Address_ = x.Address_;
      this->DomainData_ = x.DomainData_;
      this->EmailData_ = x.EmailData_;
      this->ApplicationHeader_ = x.ApplicationHeader_;
      this->WindowsRegistryKeysModified_ = x.WindowsRegistryKeysModified_;
      this->FileData_ = x.FileData_;
      this->CertificateData_ = x.CertificateData_;
      this->RegistryHandle_ = x.RegistryHandle_;
      this->RecordData_ = x.RecordData_;
      this->EventData_ = x.EventData_;
      this->Incident_ = x.Incident_;
      this->Expectation_ = x.Expectation_;
      this->Reference_ = x.Reference_;
      this->Assessment_ = x.Assessment_;
      this->HistoryItem_ = x.HistoryItem_;
      this->BulkObservable_ = x.BulkObservable_;
      this->AdditionalData_ = x.AdditionalData_;
      this->restriction_ = x.restriction_;
      this->ext_restriction_ = x.ext_restriction_;
    }

    return *this;
  }

  Observable::
  ~Observable ()
  {
  }

  // BulkObservable
  //

  BulkObservable::
  BulkObservable (const type_type& type)
  : ::xml_schema::type (),
    BulkObservableFormat_ (this),
    BulkObservableList_ (this),
    type_ (type, this),
    ext_type_ (this)
  {
  }

  BulkObservable::
  BulkObservable (const BulkObservable& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    BulkObservableFormat_ (x.BulkObservableFormat_, f, this),
    BulkObservableList_ (x.BulkObservableList_, f, this),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this)
  {
  }

  BulkObservable::
  BulkObservable (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    BulkObservableFormat_ (this),
    BulkObservableList_ (this),
    type_ (this),
    ext_type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BulkObservable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // BulkObservableFormat
      //
      if (n.name () == "BulkObservableFormat" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< BulkObservableFormat_type > r (
          BulkObservableFormat_traits::create (i, f, this));

        if (!this->BulkObservableFormat_)
        {
          this->BulkObservableFormat_.set (r);
          continue;
        }
      }

      // BulkObservableList
      //
      if (n.name () == "BulkObservableList" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< BulkObservableList_type > r (
          BulkObservableList_traits::create (i, f, this));

        if (!this->BulkObservableList_)
        {
          this->BulkObservableList_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        this->ext_type_.set (ext_type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  BulkObservable* BulkObservable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BulkObservable (*this, f, c);
  }

  BulkObservable& BulkObservable::
  operator= (const BulkObservable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->BulkObservableFormat_ = x.BulkObservableFormat_;
      this->BulkObservableList_ = x.BulkObservableList_;
      this->type_ = x.type_;
      this->ext_type_ = x.ext_type_;
    }

    return *this;
  }

  BulkObservable::
  ~BulkObservable ()
  {
  }

  // BulkObservableFormat
  //

  BulkObservableFormat::
  BulkObservableFormat ()
  : ::xml_schema::type (),
    Hash_ (this),
    AdditionalData_ (this)
  {
  }

  BulkObservableFormat::
  BulkObservableFormat (const BulkObservableFormat& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Hash_ (x.Hash_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this)
  {
  }

  BulkObservableFormat::
  BulkObservableFormat (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Hash_ (this),
    AdditionalData_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void BulkObservableFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Hash
      //
      if (n.name () == "Hash" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Hash_type > r (
          Hash_traits::create (i, f, this));

        if (!this->Hash_)
        {
          this->Hash_.set (r);
          continue;
        }
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }
  }

  BulkObservableFormat* BulkObservableFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BulkObservableFormat (*this, f, c);
  }

  BulkObservableFormat& BulkObservableFormat::
  operator= (const BulkObservableFormat& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Hash_ = x.Hash_;
      this->AdditionalData_ = x.AdditionalData_;
    }

    return *this;
  }

  BulkObservableFormat::
  ~BulkObservableFormat ()
  {
  }

  // IndicatorExpression
  //

  IndicatorExpression::
  IndicatorExpression (const operator_type& operator_)
  : ::xml_schema::type (),
    IndicatorExpression1_ (this),
    Observable_ (this),
    ObservableReference_ (this),
    IndicatorReference_ (this),
    AlternativeIndicatorID_ (this),
    operator__ (operator_, this)
  {
  }

  IndicatorExpression::
  IndicatorExpression (const IndicatorExpression& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IndicatorExpression1_ (x.IndicatorExpression1_, f, this),
    Observable_ (x.Observable_, f, this),
    ObservableReference_ (x.ObservableReference_, f, this),
    IndicatorReference_ (x.IndicatorReference_, f, this),
    AlternativeIndicatorID_ (x.AlternativeIndicatorID_, f, this),
    operator__ (x.operator__, f, this)
  {
  }

  IndicatorExpression::
  IndicatorExpression (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IndicatorExpression1_ (this),
    Observable_ (this),
    ObservableReference_ (this),
    IndicatorReference_ (this),
    AlternativeIndicatorID_ (this),
    operator__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IndicatorExpression::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IndicatorExpression
      //
      if (n.name () == "IndicatorExpression" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IndicatorExpression1_type > r (
          IndicatorExpression1_traits::create (i, f, this));

        if (!this->IndicatorExpression1_)
        {
          this->IndicatorExpression1_.set (r);
          continue;
        }
      }

      // Observable
      //
      if (n.name () == "Observable" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< Observable_type > r (
          Observable_traits::create (i, f, this));

        if (!this->Observable_)
        {
          this->Observable_.set (r);
          continue;
        }
      }

      // ObservableReference
      //
      if (n.name () == "ObservableReference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< ObservableReference_type > r (
          ObservableReference_traits::create (i, f, this));

        if (!this->ObservableReference_)
        {
          this->ObservableReference_.set (r);
          continue;
        }
      }

      // IndicatorReference
      //
      if (n.name () == "IndicatorReference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< IndicatorReference_type > r (
          IndicatorReference_traits::create (i, f, this));

        if (!this->IndicatorReference_)
        {
          this->IndicatorReference_.set (r);
          continue;
        }
      }

      // AlternativeIndicatorID
      //
      if (n.name () == "AlternativeIndicatorID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
      {
        ::std::auto_ptr< AlternativeIndicatorID_type > r (
          AlternativeIndicatorID_traits::create (i, f, this));

        this->AlternativeIndicatorID_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (operator_traits::create (i, f, this));
        continue;
      }
    }

    if (!operator__.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "operator",
        "");
    }
  }

  IndicatorExpression* IndicatorExpression::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IndicatorExpression (*this, f, c);
  }

  IndicatorExpression& IndicatorExpression::
  operator= (const IndicatorExpression& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->IndicatorExpression1_ = x.IndicatorExpression1_;
      this->Observable_ = x.Observable_;
      this->ObservableReference_ = x.ObservableReference_;
      this->IndicatorReference_ = x.IndicatorReference_;
      this->AlternativeIndicatorID_ = x.AlternativeIndicatorID_;
      this->operator__ = x.operator__;
    }

    return *this;
  }

  IndicatorExpression::
  ~IndicatorExpression ()
  {
  }

  // ObservableReference
  //

  ObservableReference::
  ObservableReference (const uid_ref_type& uid_ref)
  : ::xml_schema::type (),
    uid_ref_ (uid_ref, this)
  {
  }

  ObservableReference::
  ObservableReference (const ObservableReference& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    uid_ref_ (x.uid_ref_, f, this)
  {
  }

  ObservableReference::
  ObservableReference (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    uid_ref_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ObservableReference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "uid-ref" && n.namespace_ ().empty ())
      {
        this->uid_ref_.set (uid_ref_traits::create (i, f, this));
        continue;
      }
    }

    if (!uid_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "uid-ref",
        "");
    }
  }

  ObservableReference* ObservableReference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ObservableReference (*this, f, c);
  }

  ObservableReference& ObservableReference::
  operator= (const ObservableReference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->uid_ref_ = x.uid_ref_;
    }

    return *this;
  }

  ObservableReference::
  ~ObservableReference ()
  {
  }

  // IndicatorReference
  //

  IndicatorReference::
  IndicatorReference ()
  : ::xml_schema::type (),
    uid_ref_ (this),
    euid_ref_ (this),
    version_ (this)
  {
  }

  IndicatorReference::
  IndicatorReference (const IndicatorReference& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    uid_ref_ (x.uid_ref_, f, this),
    euid_ref_ (x.euid_ref_, f, this),
    version_ (x.version_, f, this)
  {
  }

  IndicatorReference::
  IndicatorReference (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    uid_ref_ (this),
    euid_ref_ (this),
    version_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IndicatorReference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "uid-ref" && n.namespace_ ().empty ())
      {
        this->uid_ref_.set (uid_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "euid-ref" && n.namespace_ ().empty ())
      {
        this->euid_ref_.set (euid_ref_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }
    }
  }

  IndicatorReference* IndicatorReference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IndicatorReference (*this, f, c);
  }

  IndicatorReference& IndicatorReference::
  operator= (const IndicatorReference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->uid_ref_ = x.uid_ref_;
      this->euid_ref_ = x.euid_ref_;
      this->version_ = x.version_;
    }

    return *this;
  }

  IndicatorReference::
  ~IndicatorReference ()
  {
  }

  // occurrence
  //

  occurrence::
  occurrence (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_occurrence_convert ();
  }

  occurrence::
  occurrence (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_occurrence_convert ();
  }

  occurrence::
  occurrence (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_occurrence_convert ();
  }

  occurrence* occurrence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class occurrence (*this, f, c);
  }

  occurrence::value occurrence::
  _xsd_occurrence_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_occurrence_literals_);
    const value* i (::std::lower_bound (
                      _xsd_occurrence_indexes_,
                      _xsd_occurrence_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_occurrence_indexes_ + 2 || _xsd_occurrence_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const occurrence::
  _xsd_occurrence_literals_[2] =
  {
    "actual",
    "potential"
  };

  const occurrence::value occurrence::
  _xsd_occurrence_indexes_[2] =
  {
    ::iodef_2_0::occurrence::actual,
    ::iodef_2_0::occurrence::potential
  };

  // completion
  //

  completion::
  completion (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_completion_convert ();
  }

  completion::
  completion (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_completion_convert ();
  }

  completion::
  completion (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_completion_convert ();
  }

  completion* completion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class completion (*this, f, c);
  }

  completion::value completion::
  _xsd_completion_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_completion_literals_);
    const value* i (::std::lower_bound (
                      _xsd_completion_indexes_,
                      _xsd_completion_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_completion_indexes_ + 2 || _xsd_completion_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const completion::
  _xsd_completion_literals_[2] =
  {
    "failed",
    "succeeded"
  };

  const completion::value completion::
  _xsd_completion_indexes_[2] =
  {
    ::iodef_2_0::completion::failed,
    ::iodef_2_0::completion::succeeded
  };

  // record_type
  //

  record_type::
  record_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_record_type_convert ();
  }

  record_type::
  record_type (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_record_type_convert ();
  }

  record_type::
  record_type (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_record_type_convert ();
  }

  record_type* record_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class record_type (*this, f, c);
  }

  record_type::value record_type::
  _xsd_record_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_record_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_record_type_indexes_,
                      _xsd_record_type_indexes_ + 37,
                      *this,
                      c));

    if (i == _xsd_record_type_indexes_ + 37 || _xsd_record_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const record_type::
  _xsd_record_type_literals_[37] =
  {
    "A",
    "AAAA",
    "AFSDB",
    "APL",
    "AXFR",
    "CAA",
    "CERT",
    "CNAME",
    "DHCID",
    "DLV",
    "DNAME",
    "DNSKEY",
    "DS",
    "HIP",
    "IXFR",
    "IPSECKEY",
    "LOC",
    "MX",
    "NAPTR",
    "NS",
    "NSEC",
    "NSEC3",
    "NSEC3PARAM",
    "OPT",
    "PTR",
    "RRSIG",
    "RP",
    "SIG",
    "SOA",
    "SPF",
    "SRV",
    "SSHFP",
    "TA",
    "TKEY",
    "TLSA",
    "TSIG",
    "TXT"
  };

  const record_type::value record_type::
  _xsd_record_type_indexes_[37] =
  {
    ::iodef_2_0::record_type::A,
    ::iodef_2_0::record_type::AAAA,
    ::iodef_2_0::record_type::AFSDB,
    ::iodef_2_0::record_type::APL,
    ::iodef_2_0::record_type::AXFR,
    ::iodef_2_0::record_type::CAA,
    ::iodef_2_0::record_type::CERT,
    ::iodef_2_0::record_type::CNAME,
    ::iodef_2_0::record_type::DHCID,
    ::iodef_2_0::record_type::DLV,
    ::iodef_2_0::record_type::DNAME,
    ::iodef_2_0::record_type::DNSKEY,
    ::iodef_2_0::record_type::DS,
    ::iodef_2_0::record_type::HIP,
    ::iodef_2_0::record_type::IPSECKEY,
    ::iodef_2_0::record_type::IXFR,
    ::iodef_2_0::record_type::LOC,
    ::iodef_2_0::record_type::MX,
    ::iodef_2_0::record_type::NAPTR,
    ::iodef_2_0::record_type::NS,
    ::iodef_2_0::record_type::NSEC,
    ::iodef_2_0::record_type::NSEC3,
    ::iodef_2_0::record_type::NSEC3PARAM,
    ::iodef_2_0::record_type::OPT,
    ::iodef_2_0::record_type::PTR,
    ::iodef_2_0::record_type::RP,
    ::iodef_2_0::record_type::RRSIG,
    ::iodef_2_0::record_type::SIG,
    ::iodef_2_0::record_type::SOA,
    ::iodef_2_0::record_type::SPF,
    ::iodef_2_0::record_type::SRV,
    ::iodef_2_0::record_type::SSHFP,
    ::iodef_2_0::record_type::TA,
    ::iodef_2_0::record_type::TKEY,
    ::iodef_2_0::record_type::TLSA,
    ::iodef_2_0::record_type::TSIG,
    ::iodef_2_0::record_type::TXT
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace iodef_2_0
{
  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IODEF_Document > (
      ::iodef_2_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IODEF_Document > (
      ::iodef_2_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IODEF_Document > (
      ::iodef_2_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IODEF_Document_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IODEF_Document_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IODEF_Document > (
      ::iodef_2_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IODEF_Document > (
      ::iodef_2_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IODEF_Document > (
      ::iodef_2_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::IODEF_Document > (
        ::iodef_2_0::IODEF_Document_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IODEF-Document" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IODEF_Document > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IODEF_Document, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IODEF-Document",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IODEF_Document >
  IODEF_Document_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IODEF-Document" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IODEF_Document > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IODEF_Document, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IODEF-Document",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Incident > (
      ::iodef_2_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Incident > (
      ::iodef_2_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Incident > (
      ::iodef_2_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Incident_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Incident_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Incident_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Incident_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Incident_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Incident_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Incident > (
      ::iodef_2_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Incident > (
      ::iodef_2_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Incident > (
      ::iodef_2_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Incident > (
        ::iodef_2_0::Incident_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Incident" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Incident > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Incident, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Incident",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Incident >
  Incident_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Incident" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Incident > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Incident, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Incident",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IncidentIDType > (
      ::iodef_2_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IncidentIDType > (
      ::iodef_2_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IncidentIDType > (
      ::iodef_2_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IncidentID (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IncidentID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IncidentID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IncidentID (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IncidentID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IncidentID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IncidentIDType > (
      ::iodef_2_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IncidentIDType > (
      ::iodef_2_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IncidentIDType > (
      ::iodef_2_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::IncidentIDType > (
        ::iodef_2_0::IncidentID (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IncidentID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IncidentIDType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IncidentIDType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IncidentID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IncidentIDType >
  IncidentID (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IncidentID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IncidentIDType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IncidentIDType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IncidentID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeID > (
      ::iodef_2_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeID > (
      ::iodef_2_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeID > (
      ::iodef_2_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AlternativeID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AlternativeID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AlternativeID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AlternativeID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AlternativeID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AlternativeID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeID > (
      ::iodef_2_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeID > (
      ::iodef_2_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeID > (
      ::iodef_2_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::AlternativeID > (
        ::iodef_2_0::AlternativeID_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "AlternativeID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::AlternativeID > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::AlternativeID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AlternativeID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeID >
  AlternativeID_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "AlternativeID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::AlternativeID > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::AlternativeID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AlternativeID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedActivity > (
      ::iodef_2_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedActivity > (
      ::iodef_2_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedActivity > (
      ::iodef_2_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RelatedActivity_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RelatedActivity_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RelatedActivity_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RelatedActivity_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RelatedActivity_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RelatedActivity_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedActivity > (
      ::iodef_2_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedActivity > (
      ::iodef_2_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedActivity > (
      ::iodef_2_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::RelatedActivity > (
        ::iodef_2_0::RelatedActivity_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RelatedActivity" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RelatedActivity > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RelatedActivity, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RelatedActivity",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedActivity >
  RelatedActivity_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RelatedActivity" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RelatedActivity > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RelatedActivity, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RelatedActivity",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ThreatActor > (
      ::iodef_2_0::ThreatActor_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ThreatActor > (
      ::iodef_2_0::ThreatActor_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ThreatActor > (
      ::iodef_2_0::ThreatActor_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ThreatActor_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ThreatActor_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ThreatActor_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ThreatActor_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ThreatActor_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ThreatActor_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ThreatActor > (
      ::iodef_2_0::ThreatActor_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ThreatActor > (
      ::iodef_2_0::ThreatActor_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ThreatActor > (
      ::iodef_2_0::ThreatActor_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ThreatActor > (
        ::iodef_2_0::ThreatActor_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ThreatActor" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ThreatActor > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ThreatActor, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ThreatActor",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ThreatActor >
  ThreatActor_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ThreatActor" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ThreatActor > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ThreatActor, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ThreatActor",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::ThreatActorID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::ThreatActorID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::ThreatActorID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ThreatActorID (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ThreatActorID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ThreatActorID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ThreatActorID (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ThreatActorID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ThreatActorID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::ThreatActorID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::ThreatActorID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::ThreatActorID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::ThreatActorID (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ThreatActorID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ThreatActorID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  ThreatActorID (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ThreatActorID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ThreatActorID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Campaign > (
      ::iodef_2_0::Campaign_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Campaign > (
      ::iodef_2_0::Campaign_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Campaign > (
      ::iodef_2_0::Campaign_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Campaign_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Campaign_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Campaign_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Campaign_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Campaign_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Campaign_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Campaign > (
      ::iodef_2_0::Campaign_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Campaign > (
      ::iodef_2_0::Campaign_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Campaign > (
      ::iodef_2_0::Campaign_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Campaign > (
        ::iodef_2_0::Campaign_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Campaign" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Campaign > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Campaign, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Campaign",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Campaign >
  Campaign_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Campaign" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Campaign > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Campaign, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Campaign",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::CampaignID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::CampaignID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::CampaignID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::CampaignID (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::CampaignID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::CampaignID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::CampaignID (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::CampaignID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::CampaignID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::CampaignID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::CampaignID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::CampaignID (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::CampaignID (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CampaignID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CampaignID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  CampaignID (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CampaignID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CampaignID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AdditionalData (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AdditionalData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AdditionalData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AdditionalData (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AdditionalData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AdditionalData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
        ::iodef_2_0::AdditionalData (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "AdditionalData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AdditionalData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  AdditionalData (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "AdditionalData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AdditionalData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Contact > (
      ::iodef_2_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Contact > (
      ::iodef_2_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Contact > (
      ::iodef_2_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Contact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Contact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Contact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Contact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Contact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Contact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Contact > (
      ::iodef_2_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Contact > (
      ::iodef_2_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Contact > (
      ::iodef_2_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Contact > (
        ::iodef_2_0::Contact_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Contact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Contact > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Contact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Contact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Contact >
  Contact_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Contact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Contact > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Contact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Contact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ContactName (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ContactName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ContactName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ContactName (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ContactName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ContactName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::ContactName (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ContactName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ContactName",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactName (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ContactName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ContactName",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactTitle (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactTitle (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactTitle (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ContactTitle (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ContactTitle (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ContactTitle (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ContactTitle (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ContactTitle (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ContactTitle (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactTitle (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactTitle (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::ContactTitle (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::ContactTitle (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ContactTitle" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ContactTitle",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  ContactTitle (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ContactTitle" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ContactTitle",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RegistryHandle > (
      ::iodef_2_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RegistryHandle > (
      ::iodef_2_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RegistryHandle > (
      ::iodef_2_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RegistryHandle_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RegistryHandle_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RegistryHandle_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RegistryHandle_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RegistryHandle_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RegistryHandle_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RegistryHandle > (
      ::iodef_2_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RegistryHandle > (
      ::iodef_2_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RegistryHandle > (
      ::iodef_2_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::RegistryHandle > (
        ::iodef_2_0::RegistryHandle_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RegistryHandle" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RegistryHandle > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RegistryHandle, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RegistryHandle",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RegistryHandle >
  RegistryHandle_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RegistryHandle" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RegistryHandle > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RegistryHandle, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RegistryHandle",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::PostalAddress > (
      ::iodef_2_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::PostalAddress > (
      ::iodef_2_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::PostalAddress > (
      ::iodef_2_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::PostalAddress_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::PostalAddress_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::PostalAddress_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::PostalAddress_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::PostalAddress_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::PostalAddress_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::PostalAddress > (
      ::iodef_2_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::PostalAddress > (
      ::iodef_2_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::PostalAddress > (
      ::iodef_2_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::PostalAddress > (
        ::iodef_2_0::PostalAddress_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PostalAddress" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::PostalAddress > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::PostalAddress, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PostalAddress",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::PostalAddress >
  PostalAddress_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PostalAddress" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::PostalAddress > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::PostalAddress, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PostalAddress",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Email (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Email (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Email (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Email (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Email (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Email (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
        ::iodef_2_0::Email (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Email" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Email",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Email (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Email" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Email",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Telephone (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Telephone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Telephone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Telephone (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Telephone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Telephone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
        ::iodef_2_0::Telephone (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Telephone" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Telephone",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Telephone (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Telephone" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Telephone",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Fax (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Fax (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Fax (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Fax (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Fax (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Fax (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
      ::iodef_2_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ContactMeansType > (
        ::iodef_2_0::Fax (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Fax" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Fax",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ContactMeansType >
  Fax (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Fax" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Fax",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DateTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DateTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DateTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DateTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DateTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DateTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::DateTime (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DateTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DateTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DateTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DateTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ReportTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ReportTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ReportTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ReportTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ReportTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ReportTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::ReportTime (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ReportTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ReportTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ReportTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ReportTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DetectTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DetectTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DetectTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DetectTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DetectTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DetectTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::DetectTime (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DetectTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DetectTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DetectTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DetectTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::StartTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::StartTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::StartTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::StartTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::StartTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::StartTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::StartTime (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "StartTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "StartTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "StartTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "StartTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EndTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EndTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EndTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EndTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EndTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EndTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::EndTime (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EndTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EndTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EndTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EndTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RecoveryTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RecoveryTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RecoveryTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecoveryTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecoveryTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecoveryTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecoveryTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecoveryTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecoveryTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RecoveryTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RecoveryTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RecoveryTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::RecoveryTime (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RecoveryTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecoveryTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RecoveryTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RecoveryTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecoveryTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::GenerationTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::GenerationTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::GenerationTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::GenerationTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::GenerationTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::GenerationTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::GenerationTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::GenerationTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::GenerationTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::GenerationTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::GenerationTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::GenerationTime (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::GenerationTime (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GenerationTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GenerationTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  GenerationTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GenerationTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GenerationTime",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::TimezoneType > (
      ::iodef_2_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::TimezoneType > (
      ::iodef_2_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::TimezoneType > (
      ::iodef_2_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Timezone (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Timezone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Timezone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Timezone (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Timezone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Timezone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::TimezoneType > (
      ::iodef_2_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::TimezoneType > (
      ::iodef_2_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::TimezoneType > (
      ::iodef_2_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::TimezoneType > (
        ::iodef_2_0::Timezone (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Timezone" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::TimezoneType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::TimezoneType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Timezone",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::TimezoneType >
  Timezone (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Timezone" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::TimezoneType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::TimezoneType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Timezone",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::History > (
      ::iodef_2_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::History > (
      ::iodef_2_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::History > (
      ::iodef_2_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::History_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::History_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::History_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::History_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::History_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::History_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::History > (
      ::iodef_2_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::History > (
      ::iodef_2_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::History > (
      ::iodef_2_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::History > (
        ::iodef_2_0::History_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "History" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::History > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::History, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "History",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::History >
  History_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "History" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::History > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::History, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "History",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::HistoryItem > (
      ::iodef_2_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::HistoryItem > (
      ::iodef_2_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::HistoryItem > (
      ::iodef_2_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HistoryItem_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HistoryItem_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HistoryItem_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HistoryItem_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HistoryItem_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HistoryItem_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::HistoryItem > (
      ::iodef_2_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::HistoryItem > (
      ::iodef_2_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::HistoryItem > (
      ::iodef_2_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::HistoryItem > (
        ::iodef_2_0::HistoryItem_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "HistoryItem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::HistoryItem > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::HistoryItem, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "HistoryItem",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::HistoryItem >
  HistoryItem_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "HistoryItem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::HistoryItem > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::HistoryItem, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "HistoryItem",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::DefinedCOA (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::DefinedCOA (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::DefinedCOA (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DefinedCOA (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DefinedCOA (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DefinedCOA (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DefinedCOA (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DefinedCOA (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DefinedCOA (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::DefinedCOA (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::DefinedCOA (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::DefinedCOA (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::DefinedCOA (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DefinedCOA" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DefinedCOA",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  DefinedCOA (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DefinedCOA" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DefinedCOA",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Expectation > (
      ::iodef_2_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Expectation > (
      ::iodef_2_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Expectation > (
      ::iodef_2_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Expectation_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Expectation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Expectation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Expectation_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Expectation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Expectation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Expectation > (
      ::iodef_2_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Expectation > (
      ::iodef_2_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Expectation > (
      ::iodef_2_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Expectation > (
        ::iodef_2_0::Expectation_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Expectation" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Expectation > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Expectation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Expectation",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Expectation >
  Expectation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Expectation" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Expectation > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Expectation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Expectation",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Discovery > (
      ::iodef_2_0::Discovery_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Discovery > (
      ::iodef_2_0::Discovery_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Discovery > (
      ::iodef_2_0::Discovery_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Discovery_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Discovery_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Discovery_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Discovery_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Discovery_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Discovery_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Discovery > (
      ::iodef_2_0::Discovery_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Discovery > (
      ::iodef_2_0::Discovery_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Discovery > (
      ::iodef_2_0::Discovery_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Discovery > (
        ::iodef_2_0::Discovery_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Discovery" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Discovery > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Discovery, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Discovery",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Discovery >
  Discovery_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Discovery" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Discovery > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Discovery, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Discovery",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::DetectionPattern > (
      ::iodef_2_0::DetectionPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DetectionPattern > (
      ::iodef_2_0::DetectionPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DetectionPattern > (
      ::iodef_2_0::DetectionPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DetectionPattern_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DetectionPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DetectionPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DetectionPattern_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DetectionPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DetectionPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::DetectionPattern > (
      ::iodef_2_0::DetectionPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DetectionPattern > (
      ::iodef_2_0::DetectionPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DetectionPattern > (
      ::iodef_2_0::DetectionPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::DetectionPattern > (
        ::iodef_2_0::DetectionPattern_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DetectionPattern" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::DetectionPattern > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::DetectionPattern, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DetectionPattern",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::DetectionPattern >
  DetectionPattern_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DetectionPattern" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::DetectionPattern > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::DetectionPattern, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DetectionPattern",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Method > (
      ::iodef_2_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Method > (
      ::iodef_2_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Method > (
      ::iodef_2_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Method_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Method_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Method_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Method_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Method_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Method_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Method > (
      ::iodef_2_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Method > (
      ::iodef_2_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Method > (
      ::iodef_2_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Method > (
        ::iodef_2_0::Method_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Method" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Method > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Method, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Method",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Method >
  Method_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Method" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Method > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Method, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Method",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Reference > (
      ::iodef_2_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Reference > (
      ::iodef_2_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Reference > (
      ::iodef_2_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Reference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Reference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Reference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Reference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Reference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Reference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Reference > (
      ::iodef_2_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Reference > (
      ::iodef_2_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Reference > (
      ::iodef_2_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Reference > (
        ::iodef_2_0::Reference_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Reference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Reference > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Reference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Reference",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Reference >
  Reference_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Reference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Reference > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Reference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Reference",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Assessment > (
      ::iodef_2_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Assessment > (
      ::iodef_2_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Assessment > (
      ::iodef_2_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Assessment_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Assessment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Assessment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Assessment_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Assessment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Assessment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Assessment > (
      ::iodef_2_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Assessment > (
      ::iodef_2_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Assessment > (
      ::iodef_2_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Assessment > (
        ::iodef_2_0::Assessment_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Assessment" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Assessment > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Assessment, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Assessment",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Assessment >
  Assessment_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Assessment" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Assessment > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Assessment, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Assessment",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::IncidentCategory (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::IncidentCategory (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::IncidentCategory (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IncidentCategory (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IncidentCategory (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IncidentCategory (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IncidentCategory (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IncidentCategory (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IncidentCategory (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::IncidentCategory (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::IncidentCategory (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::IncidentCategory (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::IncidentCategory (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IncidentCategory" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IncidentCategory",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  IncidentCategory (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IncidentCategory" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IncidentCategory",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::BusinessImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::BusinessImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::BusinessImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BusinessImpact (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BusinessImpact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BusinessImpact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BusinessImpact (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BusinessImpact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BusinessImpact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::BusinessImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::BusinessImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::BusinessImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
        ::iodef_2_0::BusinessImpact (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "BusinessImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::BusinessImpactType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BusinessImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  BusinessImpact (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "BusinessImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::BusinessImpactType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BusinessImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::IntendedImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::IntendedImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::IntendedImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IntendedImpact (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IntendedImpact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IntendedImpact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IntendedImpact (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IntendedImpact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IntendedImpact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::IntendedImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::IntendedImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
      ::iodef_2_0::IntendedImpact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > (
        ::iodef_2_0::IntendedImpact (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IntendedImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::BusinessImpactType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IntendedImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::BusinessImpactType >
  IntendedImpact (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IntendedImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::BusinessImpactType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::BusinessImpactType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IntendedImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::MitigatingFactor (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::MitigatingFactor (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::MitigatingFactor (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::MitigatingFactor (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::MitigatingFactor (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::MitigatingFactor (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::MitigatingFactor (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::MitigatingFactor (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::MitigatingFactor (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::MitigatingFactor (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::MitigatingFactor (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::MitigatingFactor (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::MitigatingFactor (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MitigatingFactor" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MitigatingFactor",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  MitigatingFactor (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "MitigatingFactor" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MitigatingFactor",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SystemImpact > (
      ::iodef_2_0::SystemImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SystemImpact > (
      ::iodef_2_0::SystemImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SystemImpact > (
      ::iodef_2_0::SystemImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SystemImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SystemImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SystemImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SystemImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SystemImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SystemImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SystemImpact > (
      ::iodef_2_0::SystemImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SystemImpact > (
      ::iodef_2_0::SystemImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SystemImpact > (
      ::iodef_2_0::SystemImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::SystemImpact > (
        ::iodef_2_0::SystemImpact_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SystemImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SystemImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SystemImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SystemImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SystemImpact >
  SystemImpact_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SystemImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SystemImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SystemImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SystemImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::TimeImpact > (
      ::iodef_2_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::TimeImpact > (
      ::iodef_2_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::TimeImpact > (
      ::iodef_2_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::TimeImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::TimeImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::TimeImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::TimeImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::TimeImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::TimeImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::TimeImpact > (
      ::iodef_2_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::TimeImpact > (
      ::iodef_2_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::TimeImpact > (
      ::iodef_2_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::TimeImpact > (
        ::iodef_2_0::TimeImpact_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "TimeImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::TimeImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::TimeImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "TimeImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::TimeImpact >
  TimeImpact_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "TimeImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::TimeImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::TimeImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "TimeImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > (
      ::iodef_2_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > (
      ::iodef_2_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > (
      ::iodef_2_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::MonetaryImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::MonetaryImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::MonetaryImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::MonetaryImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::MonetaryImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::MonetaryImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > (
      ::iodef_2_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > (
      ::iodef_2_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > (
      ::iodef_2_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > (
        ::iodef_2_0::MonetaryImpact_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MonetaryImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MonetaryImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MonetaryImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MonetaryImpact >
  MonetaryImpact_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "MonetaryImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MonetaryImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MonetaryImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MonetaryImpact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Confidence > (
      ::iodef_2_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Confidence > (
      ::iodef_2_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Confidence > (
      ::iodef_2_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Confidence_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Confidence_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Confidence_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Confidence_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Confidence_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Confidence_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Confidence > (
      ::iodef_2_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Confidence > (
      ::iodef_2_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Confidence > (
      ::iodef_2_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Confidence > (
        ::iodef_2_0::Confidence_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Confidence" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Confidence > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Confidence, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Confidence",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Confidence >
  Confidence_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Confidence" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Confidence > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Confidence, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Confidence",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::EventData > (
      ::iodef_2_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::EventData > (
      ::iodef_2_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::EventData > (
      ::iodef_2_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EventData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EventData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EventData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EventData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EventData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EventData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::EventData > (
      ::iodef_2_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::EventData > (
      ::iodef_2_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::EventData > (
      ::iodef_2_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::EventData > (
        ::iodef_2_0::EventData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EventData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::EventData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::EventData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EventData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::EventData >
  EventData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EventData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::EventData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::EventData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EventData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Flow > (
      ::iodef_2_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Flow > (
      ::iodef_2_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Flow > (
      ::iodef_2_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Flow_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Flow_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Flow_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Flow_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Flow_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Flow_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Flow > (
      ::iodef_2_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Flow > (
      ::iodef_2_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Flow > (
      ::iodef_2_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Flow > (
        ::iodef_2_0::Flow_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Flow" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Flow > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Flow, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Flow",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Flow >
  Flow_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Flow" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Flow > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Flow, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Flow",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::System > (
      ::iodef_2_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::System > (
      ::iodef_2_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::System > (
      ::iodef_2_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::System_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::System_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::System_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::System_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::System_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::System_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::System > (
      ::iodef_2_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::System > (
      ::iodef_2_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::System > (
      ::iodef_2_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::System > (
        ::iodef_2_0::System_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "System" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::System > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::System, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "System",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::System >
  System_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "System" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::System > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::System, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "System",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Node > (
      ::iodef_2_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Node > (
      ::iodef_2_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Node > (
      ::iodef_2_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Node_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Node_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Node_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Node_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Node_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Node_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Node > (
      ::iodef_2_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Node > (
      ::iodef_2_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Node > (
      ::iodef_2_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Node > (
        ::iodef_2_0::Node_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Node" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Node > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Node, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Node",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Node >
  Node_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Node" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Node > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Node, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Node",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Address > (
      ::iodef_2_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Address > (
      ::iodef_2_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Address > (
      ::iodef_2_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Address_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Address_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Address_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Address_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Address_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Address_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Address > (
      ::iodef_2_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Address > (
      ::iodef_2_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Address > (
      ::iodef_2_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Address > (
        ::iodef_2_0::Address_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Address" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Address > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Address, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Address",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Address >
  Address_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Address" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Address > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Address, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Address",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Location (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Location (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Location (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Location (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Location (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Location (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::Location (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Location" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Location",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Location (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Location" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Location",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::NodeRole > (
      ::iodef_2_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::NodeRole > (
      ::iodef_2_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::NodeRole > (
      ::iodef_2_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::NodeRole_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::NodeRole_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::NodeRole_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::NodeRole_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::NodeRole_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::NodeRole_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::NodeRole > (
      ::iodef_2_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::NodeRole > (
      ::iodef_2_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::NodeRole > (
      ::iodef_2_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::NodeRole > (
        ::iodef_2_0::NodeRole_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "NodeRole" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::NodeRole > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::NodeRole, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "NodeRole",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::NodeRole >
  NodeRole_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "NodeRole" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::NodeRole > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::NodeRole, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "NodeRole",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Service > (
      ::iodef_2_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Service > (
      ::iodef_2_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Service > (
      ::iodef_2_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Service_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Service_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Service_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Service_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Service_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Service_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Service > (
      ::iodef_2_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Service > (
      ::iodef_2_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Service > (
      ::iodef_2_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Service > (
        ::iodef_2_0::Service_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Service" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Service > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Service, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Service",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Service >
  Service_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Service" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Service > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Service, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Service",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::Port (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::Port (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::Port (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Port (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Port (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Port (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Port (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Port (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Port (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::Port (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::Port (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::Port (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::integer > (
        ::iodef_2_0::Port (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Port" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Port",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  Port (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Port" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Port",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::PortlistType > (
      ::iodef_2_0::Portlist (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::PortlistType > (
      ::iodef_2_0::Portlist (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::PortlistType > (
      ::iodef_2_0::Portlist (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Portlist (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Portlist (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Portlist (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Portlist (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Portlist (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Portlist (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::PortlistType > (
      ::iodef_2_0::Portlist (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::PortlistType > (
      ::iodef_2_0::Portlist (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::PortlistType > (
      ::iodef_2_0::Portlist (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::PortlistType > (
        ::iodef_2_0::Portlist (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Portlist" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::PortlistType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::PortlistType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Portlist",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::PortlistType >
  Portlist (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Portlist" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::PortlistType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::PortlistType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Portlist",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoType (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoType (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoType (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoType (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoType (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoType (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::integer > (
        ::iodef_2_0::ProtoType (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ProtoType" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ProtoType",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoType (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ProtoType" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ProtoType",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoCode (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoCode (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoCode (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoCode (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoCode (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoCode (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoCode (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoCode (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoCode (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoCode (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoCode (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoCode (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::integer > (
        ::iodef_2_0::ProtoCode (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ProtoCode" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ProtoCode",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoCode (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ProtoCode" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ProtoCode",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoField (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoField (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ProtoField (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoField (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoField (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ProtoField (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::ProtoField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::integer > (
        ::iodef_2_0::ProtoField (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ProtoField" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ProtoField",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  ProtoField (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ProtoField" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ProtoField",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::ApplicationHeader (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::ApplicationHeader (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::ApplicationHeader (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ApplicationHeader (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ApplicationHeader (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ApplicationHeader (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ApplicationHeader (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ApplicationHeader (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ApplicationHeader (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::ApplicationHeader (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::ApplicationHeader (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::ApplicationHeader (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
        ::iodef_2_0::ApplicationHeader (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ApplicationHeader" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ApplicationHeaderType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ApplicationHeader",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  ApplicationHeader (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ApplicationHeader" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ApplicationHeaderType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ApplicationHeader",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ServiceName > (
      ::iodef_2_0::ServiceName_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ServiceName > (
      ::iodef_2_0::ServiceName_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ServiceName > (
      ::iodef_2_0::ServiceName_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ServiceName_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ServiceName_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ServiceName_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ServiceName_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ServiceName_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ServiceName_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ServiceName > (
      ::iodef_2_0::ServiceName_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ServiceName > (
      ::iodef_2_0::ServiceName_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ServiceName > (
      ::iodef_2_0::ServiceName_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ServiceName > (
        ::iodef_2_0::ServiceName_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ServiceName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ServiceName > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ServiceName, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ServiceName",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ServiceName >
  ServiceName_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ServiceName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ServiceName > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ServiceName, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ServiceName",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::IANAService (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::IANAService (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::IANAService (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IANAService (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IANAService (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IANAService (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IANAService (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IANAService (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IANAService (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::IANAService (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::IANAService (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::IANAService (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::IANAService (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IANAService" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IANAService",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  IANAService (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IANAService" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IANAService",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Counter > (
      ::iodef_2_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Counter > (
      ::iodef_2_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Counter > (
      ::iodef_2_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Counter_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Counter_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Counter_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Counter_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Counter_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Counter_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Counter > (
      ::iodef_2_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Counter > (
      ::iodef_2_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Counter > (
      ::iodef_2_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Counter > (
        ::iodef_2_0::Counter_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Counter" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Counter > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Counter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Counter",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Counter >
  Counter_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Counter" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Counter > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Counter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Counter",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::EmailData > (
      ::iodef_2_0::EmailData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::EmailData > (
      ::iodef_2_0::EmailData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::EmailData > (
      ::iodef_2_0::EmailData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::EmailData > (
      ::iodef_2_0::EmailData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::EmailData > (
      ::iodef_2_0::EmailData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::EmailData > (
      ::iodef_2_0::EmailData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::EmailData > (
        ::iodef_2_0::EmailData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EmailData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::EmailData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::EmailData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::EmailData >
  EmailData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EmailData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::EmailData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::EmailData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailFrom (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailFrom (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailFrom (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailFrom (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailFrom (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailFrom (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailFrom (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailFrom (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailFrom (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailFrom (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailFrom (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailFrom (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::EmailFrom (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EmailFrom" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailFrom",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailFrom (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EmailFrom" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailFrom",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailSubject (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailSubject (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailSubject (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailSubject (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailSubject (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailSubject (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailSubject (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailSubject (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailSubject (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailSubject (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailSubject (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailSubject (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::EmailSubject (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EmailSubject" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailSubject",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailSubject (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EmailSubject" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailSubject",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailX_Mailer (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailX_Mailer (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailX_Mailer (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailX_Mailer (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailX_Mailer (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailX_Mailer (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailX_Mailer (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailX_Mailer (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailX_Mailer (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailX_Mailer (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailX_Mailer (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::EmailX_Mailer (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::EmailX_Mailer (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EmailX-Mailer" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailX-Mailer",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  EmailX_Mailer (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EmailX-Mailer" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailX-Mailer",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::EmailHeaderField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::EmailHeaderField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::EmailHeaderField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailHeaderField (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailHeaderField (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::EmailHeaderField (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailHeaderField (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailHeaderField (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::EmailHeaderField (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::EmailHeaderField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::EmailHeaderField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
      ::iodef_2_0::EmailHeaderField (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > (
        ::iodef_2_0::EmailHeaderField (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EmailHeaderField" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ApplicationHeaderType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailHeaderField",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType >
  EmailHeaderField (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EmailHeaderField" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ApplicationHeaderType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ApplicationHeaderType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EmailHeaderField",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainData > (
      ::iodef_2_0::DomainData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainData > (
      ::iodef_2_0::DomainData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainData > (
      ::iodef_2_0::DomainData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DomainData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DomainData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DomainData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DomainData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DomainData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DomainData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainData > (
      ::iodef_2_0::DomainData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainData > (
      ::iodef_2_0::DomainData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainData > (
      ::iodef_2_0::DomainData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::DomainData > (
        ::iodef_2_0::DomainData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DomainData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::DomainData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::DomainData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DomainData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::DomainData >
  DomainData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DomainData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::DomainData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::DomainData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DomainData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Name (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Name (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Name (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Name (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Name (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Name (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Name (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Name (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Name (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Name (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Name (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Name (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::Name (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Name" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Name",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  Name (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Name" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Name",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateDomainWasChecked (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateDomainWasChecked (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateDomainWasChecked (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DateDomainWasChecked (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DateDomainWasChecked (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DateDomainWasChecked (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DateDomainWasChecked (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DateDomainWasChecked (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DateDomainWasChecked (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateDomainWasChecked (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateDomainWasChecked (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::DateDomainWasChecked (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::DateDomainWasChecked (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DateDomainWasChecked" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DateDomainWasChecked",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateDomainWasChecked (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DateDomainWasChecked" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DateDomainWasChecked",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RegistrationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RegistrationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RegistrationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RegistrationDate (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RegistrationDate (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RegistrationDate (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RegistrationDate (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RegistrationDate (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RegistrationDate (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RegistrationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RegistrationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::RegistrationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::RegistrationDate (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RegistrationDate" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RegistrationDate",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  RegistrationDate (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RegistrationDate" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RegistrationDate",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ExpirationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ExpirationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ExpirationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ExpirationDate (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ExpirationDate (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ExpirationDate (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ExpirationDate (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ExpirationDate (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ExpirationDate (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ExpirationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ExpirationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::date_time > (
      ::iodef_2_0::ExpirationDate (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::date_time > (
        ::iodef_2_0::ExpirationDate (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ExpirationDate" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ExpirationDate",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ExpirationDate (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ExpirationDate" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ExpirationDate",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedDNS > (
      ::iodef_2_0::RelatedDNS_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedDNS > (
      ::iodef_2_0::RelatedDNS_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedDNS > (
      ::iodef_2_0::RelatedDNS_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RelatedDNS_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RelatedDNS_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RelatedDNS_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RelatedDNS_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RelatedDNS_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RelatedDNS_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedDNS > (
      ::iodef_2_0::RelatedDNS_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedDNS > (
      ::iodef_2_0::RelatedDNS_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RelatedDNS > (
      ::iodef_2_0::RelatedDNS_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::RelatedDNS > (
        ::iodef_2_0::RelatedDNS_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RelatedDNS" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RelatedDNS > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RelatedDNS, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RelatedDNS",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RelatedDNS >
  RelatedDNS_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RelatedDNS" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RelatedDNS > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RelatedDNS, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RelatedDNS",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Nameservers > (
      ::iodef_2_0::Nameservers_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Nameservers > (
      ::iodef_2_0::Nameservers_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Nameservers > (
      ::iodef_2_0::Nameservers_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Nameservers_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Nameservers_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Nameservers_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Nameservers_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Nameservers_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Nameservers_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Nameservers > (
      ::iodef_2_0::Nameservers_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Nameservers > (
      ::iodef_2_0::Nameservers_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Nameservers > (
      ::iodef_2_0::Nameservers_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Nameservers > (
        ::iodef_2_0::Nameservers_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Nameservers" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Nameservers > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Nameservers, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Nameservers",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Nameservers >
  Nameservers_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Nameservers" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Nameservers > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Nameservers, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Nameservers",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Server (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Server (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Server (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Server (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Server (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Server (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Server (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Server (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Server (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Server (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Server (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Server (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::Server (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Server" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Server",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  Server (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Server" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Server",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainContacts > (
      ::iodef_2_0::DomainContacts_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainContacts > (
      ::iodef_2_0::DomainContacts_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainContacts > (
      ::iodef_2_0::DomainContacts_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DomainContacts_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DomainContacts_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::DomainContacts_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DomainContacts_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DomainContacts_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::DomainContacts_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainContacts > (
      ::iodef_2_0::DomainContacts_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainContacts > (
      ::iodef_2_0::DomainContacts_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::DomainContacts > (
      ::iodef_2_0::DomainContacts_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::DomainContacts > (
        ::iodef_2_0::DomainContacts_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DomainContacts" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::DomainContacts > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::DomainContacts, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DomainContacts",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::DomainContacts >
  DomainContacts_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DomainContacts" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::DomainContacts > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::DomainContacts, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DomainContacts",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::SameDomainContact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::SameDomainContact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::SameDomainContact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SameDomainContact (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SameDomainContact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SameDomainContact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SameDomainContact (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SameDomainContact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SameDomainContact (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::SameDomainContact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::SameDomainContact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::SameDomainContact (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::SameDomainContact (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SameDomainContact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SameDomainContact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  SameDomainContact (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SameDomainContact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SameDomainContact",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Record > (
      ::iodef_2_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Record > (
      ::iodef_2_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Record > (
      ::iodef_2_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Record_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Record_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Record_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Record_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Record_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Record_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Record > (
      ::iodef_2_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Record > (
      ::iodef_2_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Record > (
      ::iodef_2_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Record > (
        ::iodef_2_0::Record_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Record" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Record > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Record, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Record",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Record >
  Record_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Record" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Record > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Record, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Record",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordData > (
      ::iodef_2_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordData > (
      ::iodef_2_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordData > (
      ::iodef_2_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordData > (
      ::iodef_2_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordData > (
      ::iodef_2_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordData > (
      ::iodef_2_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::RecordData > (
        ::iodef_2_0::RecordData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RecordData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RecordData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RecordData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RecordData >
  RecordData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RecordData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RecordData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RecordData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordPattern > (
      ::iodef_2_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordPattern > (
      ::iodef_2_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordPattern > (
      ::iodef_2_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordPattern_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordPattern_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordPattern > (
      ::iodef_2_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordPattern > (
      ::iodef_2_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::RecordPattern > (
      ::iodef_2_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::RecordPattern > (
        ::iodef_2_0::RecordPattern_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RecordPattern" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RecordPattern > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RecordPattern, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordPattern",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::RecordPattern >
  RecordPattern_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RecordPattern" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::RecordPattern > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::RecordPattern, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordPattern",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordItem (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordItem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::RecordItem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordItem (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordItem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::RecordItem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
        ::iodef_2_0::RecordItem (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RecordItem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordItem",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  RecordItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RecordItem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordItem",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > (
      ::iodef_2_0::WindowsRegistryKeysModified_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > (
      ::iodef_2_0::WindowsRegistryKeysModified_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (const ::std::string& u,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > (
      ::iodef_2_0::WindowsRegistryKeysModified_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::WindowsRegistryKeysModified_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::WindowsRegistryKeysModified_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::std::istream& is,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::WindowsRegistryKeysModified_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::WindowsRegistryKeysModified_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::WindowsRegistryKeysModified_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::std::istream& is,
                                const ::std::string& sid,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::WindowsRegistryKeysModified_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > (
      ::iodef_2_0::WindowsRegistryKeysModified_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > (
      ::iodef_2_0::WindowsRegistryKeysModified_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::xercesc::InputSource& i,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > (
      ::iodef_2_0::WindowsRegistryKeysModified_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (const ::xercesc::DOMDocument& doc,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > (
        ::iodef_2_0::WindowsRegistryKeysModified_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "WindowsRegistryKeysModified" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::WindowsRegistryKeysModified, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "WindowsRegistryKeysModified",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified >
  WindowsRegistryKeysModified_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "WindowsRegistryKeysModified" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::WindowsRegistryKeysModified > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::WindowsRegistryKeysModified, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "WindowsRegistryKeysModified",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Key > (
      ::iodef_2_0::Key_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Key > (
      ::iodef_2_0::Key_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Key > (
      ::iodef_2_0::Key_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Key_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Key_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Key_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Key_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Key_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Key_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Key > (
      ::iodef_2_0::Key_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Key > (
      ::iodef_2_0::Key_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Key > (
      ::iodef_2_0::Key_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Key > (
        ::iodef_2_0::Key_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Key" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Key > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Key, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Key",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Key >
  Key_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Key" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Key > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Key, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Key",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::KeyName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::KeyName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::KeyName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::KeyName (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::KeyName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::KeyName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::KeyName (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::KeyName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::KeyName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::KeyName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::KeyName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::KeyName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::KeyName (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "KeyName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "KeyName",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  KeyName (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "KeyName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "KeyName",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Value (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Value (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Value (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Value (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Value (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Value (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Value (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Value (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Value (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Value (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Value (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::Value (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::Value (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Value" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Value",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  Value (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Value" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Value",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::FileData > (
      ::iodef_2_0::FileData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::FileData > (
      ::iodef_2_0::FileData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::FileData > (
      ::iodef_2_0::FileData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::FileData > (
      ::iodef_2_0::FileData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::FileData > (
      ::iodef_2_0::FileData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::FileData > (
      ::iodef_2_0::FileData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::FileData > (
        ::iodef_2_0::FileData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FileData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::FileData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::FileData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::FileData >
  FileData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FileData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::FileData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::FileData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::File > (
      ::iodef_2_0::File_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::File > (
      ::iodef_2_0::File_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::File > (
      ::iodef_2_0::File_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::File_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::File_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::File_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::File_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::File_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::File_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::File > (
      ::iodef_2_0::File_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::File > (
      ::iodef_2_0::File_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::File > (
      ::iodef_2_0::File_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::File > (
        ::iodef_2_0::File_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "File" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::File > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::File, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "File",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::File >
  File_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "File" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::File > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::File, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "File",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::FileName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::FileName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::FileName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileName (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileName (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::FileName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::FileName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::string > (
      ::iodef_2_0::FileName (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::string > (
        ::iodef_2_0::FileName (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FileName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileName",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::string >
  FileName (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FileName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::string > r (
        ::xsd::cxx::tree::traits< ::xml_schema::string, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileName",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileSize (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileSize (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileSize (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileSize (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileSize (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileSize (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileSize (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileSize (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileSize (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileSize (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileSize (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileSize (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::integer > (
        ::iodef_2_0::FileSize (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FileSize" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileSize",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileSize (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FileSize" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileSize",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileType (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileType (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileType (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileType (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileType (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileType (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::integer > (
      ::iodef_2_0::FileType (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::integer > (
        ::iodef_2_0::FileType (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FileType" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileType",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::integer >
  FileType (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FileType" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::integer > r (
        new ::xml_schema::integer (
          ::xsd::cxx::tree::traits< ::xml_schema::integer, char >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileType",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::FileProperties (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::FileProperties (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::FileProperties (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileProperties (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileProperties (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FileProperties (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileProperties (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileProperties (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FileProperties (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::FileProperties (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::FileProperties (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
      ::iodef_2_0::FileProperties (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ExtensionType > (
        ::iodef_2_0::FileProperties (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FileProperties" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileProperties",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ExtensionType >
  FileProperties (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FileProperties" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FileProperties",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::HashData > (
      ::iodef_2_0::HashData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::HashData > (
      ::iodef_2_0::HashData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::HashData > (
      ::iodef_2_0::HashData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HashData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HashData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HashData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HashData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HashData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HashData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::HashData > (
      ::iodef_2_0::HashData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::HashData > (
      ::iodef_2_0::HashData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::HashData > (
      ::iodef_2_0::HashData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::HashData > (
        ::iodef_2_0::HashData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "HashData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::HashData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::HashData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "HashData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::HashData >
  HashData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "HashData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::HashData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::HashData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "HashData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::HashTarget (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::HashTarget (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::HashTarget (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HashTarget (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HashTarget (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::HashTarget (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HashTarget (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HashTarget (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::HashTarget (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::HashTarget (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::HashTarget (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::HashTarget (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::HashTarget (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "HashTarget" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "HashTarget",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  HashTarget (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "HashTarget" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "HashTarget",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Hash > (
      ::iodef_2_0::Hash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Hash > (
      ::iodef_2_0::Hash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Hash > (
      ::iodef_2_0::Hash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Hash_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Hash_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Hash_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Hash_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Hash_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Hash_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Hash > (
      ::iodef_2_0::Hash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Hash > (
      ::iodef_2_0::Hash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Hash > (
      ::iodef_2_0::Hash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Hash > (
        ::iodef_2_0::Hash_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Hash" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Hash > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Hash, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Hash",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Hash >
  Hash_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Hash" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Hash > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Hash, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Hash",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::FuzzyHash > (
      ::iodef_2_0::FuzzyHash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::FuzzyHash > (
      ::iodef_2_0::FuzzyHash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::FuzzyHash > (
      ::iodef_2_0::FuzzyHash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FuzzyHash_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FuzzyHash_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::FuzzyHash_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FuzzyHash_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FuzzyHash_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::FuzzyHash_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::FuzzyHash > (
      ::iodef_2_0::FuzzyHash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::FuzzyHash > (
      ::iodef_2_0::FuzzyHash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::FuzzyHash > (
      ::iodef_2_0::FuzzyHash_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::FuzzyHash > (
        ::iodef_2_0::FuzzyHash_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FuzzyHash" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::FuzzyHash > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::FuzzyHash, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FuzzyHash",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::FuzzyHash >
  FuzzyHash_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FuzzyHash" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::FuzzyHash > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::FuzzyHash, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FuzzyHash",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SignatureData > (
      ::iodef_2_0::SignatureData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SignatureData > (
      ::iodef_2_0::SignatureData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SignatureData > (
      ::iodef_2_0::SignatureData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SignatureData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SignatureData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SignatureData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SignatureData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SignatureData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SignatureData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SignatureData > (
      ::iodef_2_0::SignatureData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SignatureData > (
      ::iodef_2_0::SignatureData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SignatureData > (
      ::iodef_2_0::SignatureData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::SignatureData > (
        ::iodef_2_0::SignatureData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SignatureData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SignatureData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SignatureData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SignatureData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SignatureData >
  SignatureData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SignatureData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SignatureData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SignatureData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SignatureData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::CertificateData > (
      ::iodef_2_0::CertificateData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::CertificateData > (
      ::iodef_2_0::CertificateData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::CertificateData > (
      ::iodef_2_0::CertificateData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::CertificateData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::CertificateData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::CertificateData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::CertificateData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::CertificateData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::CertificateData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::CertificateData > (
      ::iodef_2_0::CertificateData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::CertificateData > (
      ::iodef_2_0::CertificateData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::CertificateData > (
      ::iodef_2_0::CertificateData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::CertificateData > (
        ::iodef_2_0::CertificateData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CertificateData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::CertificateData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::CertificateData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CertificateData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::CertificateData >
  CertificateData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CertificateData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::CertificateData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::CertificateData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CertificateData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Certificate > (
      ::iodef_2_0::Certificate_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Certificate > (
      ::iodef_2_0::Certificate_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Certificate > (
      ::iodef_2_0::Certificate_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Certificate_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Certificate_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Certificate_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Certificate_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Certificate_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Certificate_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Certificate > (
      ::iodef_2_0::Certificate_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Certificate > (
      ::iodef_2_0::Certificate_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Certificate > (
      ::iodef_2_0::Certificate_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Certificate > (
        ::iodef_2_0::Certificate_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Certificate" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Certificate > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Certificate, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Certificate",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Certificate >
  Certificate_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Certificate" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Certificate > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Certificate, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Certificate",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareReference > (
      ::iodef_2_0::SoftwareReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareReference > (
      ::iodef_2_0::SoftwareReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareReference > (
      ::iodef_2_0::SoftwareReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SoftwareReference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SoftwareReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::SoftwareReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SoftwareReference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SoftwareReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::SoftwareReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareReference > (
      ::iodef_2_0::SoftwareReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareReference > (
      ::iodef_2_0::SoftwareReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareReference > (
      ::iodef_2_0::SoftwareReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::SoftwareReference > (
        ::iodef_2_0::SoftwareReference_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SoftwareReference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SoftwareReference > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SoftwareReference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SoftwareReference",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareReference >
  SoftwareReference_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SoftwareReference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SoftwareReference > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SoftwareReference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SoftwareReference",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Application (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Application (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Application (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Application (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Application (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Application (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
        ::iodef_2_0::Application (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Application" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SoftwareType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SoftwareType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Application",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  Application (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Application" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SoftwareType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SoftwareType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Application",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::OperatingSystem (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::OperatingSystem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::OperatingSystem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::OperatingSystem (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::OperatingSystem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::OperatingSystem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
      ::iodef_2_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::SoftwareType > (
        ::iodef_2_0::OperatingSystem (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "OperatingSystem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SoftwareType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SoftwareType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OperatingSystem",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::SoftwareType >
  OperatingSystem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "OperatingSystem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::SoftwareType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::SoftwareType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OperatingSystem",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorData > (
      ::iodef_2_0::IndicatorData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorData > (
      ::iodef_2_0::IndicatorData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorData > (
      ::iodef_2_0::IndicatorData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorData > (
      ::iodef_2_0::IndicatorData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorData > (
      ::iodef_2_0::IndicatorData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorData > (
      ::iodef_2_0::IndicatorData_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::IndicatorData > (
        ::iodef_2_0::IndicatorData_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IndicatorData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IndicatorData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IndicatorData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IndicatorData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorData >
  IndicatorData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IndicatorData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IndicatorData > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IndicatorData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IndicatorData",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Indicator > (
      ::iodef_2_0::Indicator_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Indicator > (
      ::iodef_2_0::Indicator_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Indicator > (
      ::iodef_2_0::Indicator_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Indicator_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Indicator_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Indicator_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Indicator_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Indicator_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Indicator_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Indicator > (
      ::iodef_2_0::Indicator_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Indicator > (
      ::iodef_2_0::Indicator_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Indicator > (
      ::iodef_2_0::Indicator_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Indicator > (
        ::iodef_2_0::Indicator_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Indicator" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Indicator > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Indicator, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Indicator",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Indicator >
  Indicator_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Indicator" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Indicator > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Indicator, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Indicator",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorID > (
      ::iodef_2_0::IndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorID > (
      ::iodef_2_0::IndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorID > (
      ::iodef_2_0::IndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorID > (
      ::iodef_2_0::IndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorID > (
      ::iodef_2_0::IndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorID > (
      ::iodef_2_0::IndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::IndicatorID > (
        ::iodef_2_0::IndicatorID_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IndicatorID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IndicatorID > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IndicatorID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IndicatorID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorID >
  IndicatorID_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IndicatorID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IndicatorID > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IndicatorID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IndicatorID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > (
      ::iodef_2_0::AlternativeIndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > (
      ::iodef_2_0::AlternativeIndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > (
      ::iodef_2_0::AlternativeIndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AlternativeIndicatorID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AlternativeIndicatorID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::AlternativeIndicatorID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AlternativeIndicatorID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AlternativeIndicatorID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::AlternativeIndicatorID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > (
      ::iodef_2_0::AlternativeIndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > (
      ::iodef_2_0::AlternativeIndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > (
      ::iodef_2_0::AlternativeIndicatorID_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > (
        ::iodef_2_0::AlternativeIndicatorID_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "AlternativeIndicatorID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::AlternativeIndicatorID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AlternativeIndicatorID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID >
  AlternativeIndicatorID_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "AlternativeIndicatorID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::AlternativeIndicatorID > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::AlternativeIndicatorID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AlternativeIndicatorID",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Observable > (
      ::iodef_2_0::Observable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Observable > (
      ::iodef_2_0::Observable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Observable > (
      ::iodef_2_0::Observable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Observable_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Observable_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Observable_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Observable_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Observable_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Observable_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::Observable > (
      ::iodef_2_0::Observable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Observable > (
      ::iodef_2_0::Observable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::Observable > (
      ::iodef_2_0::Observable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::Observable > (
        ::iodef_2_0::Observable_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Observable" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Observable > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Observable, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Observable",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::Observable >
  Observable_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Observable" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::Observable > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::Observable, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Observable",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservable > (
      ::iodef_2_0::BulkObservable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservable > (
      ::iodef_2_0::BulkObservable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservable > (
      ::iodef_2_0::BulkObservable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BulkObservable_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BulkObservable_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BulkObservable_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BulkObservable_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BulkObservable_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BulkObservable_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservable > (
      ::iodef_2_0::BulkObservable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservable > (
      ::iodef_2_0::BulkObservable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservable > (
      ::iodef_2_0::BulkObservable_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::BulkObservable > (
        ::iodef_2_0::BulkObservable_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "BulkObservable" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::BulkObservable > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::BulkObservable, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BulkObservable",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservable >
  BulkObservable_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "BulkObservable" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::BulkObservable > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::BulkObservable, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BulkObservable",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > (
      ::iodef_2_0::BulkObservableFormat_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > (
      ::iodef_2_0::BulkObservableFormat_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > (
      ::iodef_2_0::BulkObservableFormat_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BulkObservableFormat_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BulkObservableFormat_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::BulkObservableFormat_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BulkObservableFormat_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BulkObservableFormat_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::BulkObservableFormat_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > (
      ::iodef_2_0::BulkObservableFormat_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > (
      ::iodef_2_0::BulkObservableFormat_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > (
      ::iodef_2_0::BulkObservableFormat_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > (
        ::iodef_2_0::BulkObservableFormat_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "BulkObservableFormat" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::BulkObservableFormat, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BulkObservableFormat",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat >
  BulkObservableFormat_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "BulkObservableFormat" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::BulkObservableFormat > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::BulkObservableFormat, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BulkObservableFormat",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > (
      ::iodef_2_0::IndicatorExpression_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > (
      ::iodef_2_0::IndicatorExpression_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > (
      ::iodef_2_0::IndicatorExpression_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorExpression_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorExpression_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorExpression_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorExpression_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorExpression_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorExpression_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > (
      ::iodef_2_0::IndicatorExpression_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > (
      ::iodef_2_0::IndicatorExpression_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > (
      ::iodef_2_0::IndicatorExpression_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > (
        ::iodef_2_0::IndicatorExpression_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IndicatorExpression" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IndicatorExpression, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IndicatorExpression",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorExpression >
  IndicatorExpression_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IndicatorExpression" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IndicatorExpression > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IndicatorExpression, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IndicatorExpression",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ObservableReference > (
      ::iodef_2_0::ObservableReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ObservableReference > (
      ::iodef_2_0::ObservableReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ObservableReference > (
      ::iodef_2_0::ObservableReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ObservableReference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ObservableReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::ObservableReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ObservableReference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ObservableReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::ObservableReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::ObservableReference > (
      ::iodef_2_0::ObservableReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ObservableReference > (
      ::iodef_2_0::ObservableReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::ObservableReference > (
      ::iodef_2_0::ObservableReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::ObservableReference > (
        ::iodef_2_0::ObservableReference_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ObservableReference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ObservableReference > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ObservableReference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ObservableReference",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::ObservableReference >
  ObservableReference_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ObservableReference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::ObservableReference > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::ObservableReference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ObservableReference",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorReference > (
      ::iodef_2_0::IndicatorReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorReference > (
      ::iodef_2_0::IndicatorReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorReference > (
      ::iodef_2_0::IndicatorReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorReference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::IndicatorReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorReference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::IndicatorReference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorReference > (
      ::iodef_2_0::IndicatorReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorReference > (
      ::iodef_2_0::IndicatorReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::IndicatorReference > (
      ::iodef_2_0::IndicatorReference_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::IndicatorReference > (
        ::iodef_2_0::IndicatorReference_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IndicatorReference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IndicatorReference > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IndicatorReference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IndicatorReference",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::IndicatorReference >
  IndicatorReference_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IndicatorReference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::IndicatorReference > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::IndicatorReference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IndicatorReference",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Description (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Description (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::Description (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Description (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Description (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::Description (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
      ::iodef_2_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::iodef_2_0::MLStringType > (
        ::iodef_2_0::Description (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Description" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Description",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::iodef_2_0::MLStringType >
  Description (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Description" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::iodef_2_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_2_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Description",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::uri > (
      ::iodef_2_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::uri > (
      ::iodef_2_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::uri > (
      ::iodef_2_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::URL (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::URL (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_2_0::URL (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::URL (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::URL (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_2_0::URL (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::xml_schema::uri > (
      ::iodef_2_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::uri > (
      ::iodef_2_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::xml_schema::uri > (
      ::iodef_2_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::xml_schema::uri > (
        ::iodef_2_0::URL (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "URL" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::uri > r (
        ::xsd::cxx::tree::traits< ::xml_schema::uri, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "URL",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "URL" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-2.0")
    {
      ::std::auto_ptr< ::xml_schema::uri > r (
        ::xsd::cxx::tree::traits< ::xml_schema::uri, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "URL",
      "urn:ietf:params:xml:ns:iodef-2.0");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

