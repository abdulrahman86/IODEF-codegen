// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "iodef-01.hxx"

namespace iodef_1_0
{
  // IncidentIDType
  // 

  const IncidentIDType::name_type& IncidentIDType::
  name () const
  {
    return this->name_.get ();
  }

  IncidentIDType::name_type& IncidentIDType::
  name ()
  {
    return this->name_.get ();
  }

  void IncidentIDType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void IncidentIDType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const IncidentIDType::instance_optional& IncidentIDType::
  instance () const
  {
    return this->instance_;
  }

  IncidentIDType::instance_optional& IncidentIDType::
  instance ()
  {
    return this->instance_;
  }

  void IncidentIDType::
  instance (const instance_type& x)
  {
    this->instance_.set (x);
  }

  void IncidentIDType::
  instance (const instance_optional& x)
  {
    this->instance_ = x;
  }

  void IncidentIDType::
  instance (::std::auto_ptr< instance_type > x)
  {
    this->instance_.set (x);
  }

  const IncidentIDType::restriction_type& IncidentIDType::
  restriction () const
  {
    return this->restriction_.get ();
  }

  IncidentIDType::restriction_type& IncidentIDType::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void IncidentIDType::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void IncidentIDType::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const IncidentIDType::restriction_type& IncidentIDType::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }


  // ContactMeansType
  // 

  const ContactMeansType::meaning_optional& ContactMeansType::
  meaning () const
  {
    return this->meaning_;
  }

  ContactMeansType::meaning_optional& ContactMeansType::
  meaning ()
  {
    return this->meaning_;
  }

  void ContactMeansType::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void ContactMeansType::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void ContactMeansType::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }


  // TimezoneType
  // 


  // PortlistType
  // 


  // SoftwareType
  // 

  const SoftwareType::URL_optional& SoftwareType::
  URL () const
  {
    return this->URL_;
  }

  SoftwareType::URL_optional& SoftwareType::
  URL ()
  {
    return this->URL_;
  }

  void SoftwareType::
  URL (const URL_type& x)
  {
    this->URL_.set (x);
  }

  void SoftwareType::
  URL (const URL_optional& x)
  {
    this->URL_ = x;
  }

  void SoftwareType::
  URL (::std::auto_ptr< URL_type > x)
  {
    this->URL_.set (x);
  }

  const SoftwareType::swid_type& SoftwareType::
  swid () const
  {
    return this->swid_.get ();
  }

  SoftwareType::swid_type& SoftwareType::
  swid ()
  {
    return this->swid_.get ();
  }

  void SoftwareType::
  swid (const swid_type& x)
  {
    this->swid_.set (x);
  }

  void SoftwareType::
  swid (::std::auto_ptr< swid_type > x)
  {
    this->swid_.set (x);
  }

  const SoftwareType::swid_type& SoftwareType::
  swid_default_value ()
  {
    return swid_default_value_;
  }

  const SoftwareType::configid_type& SoftwareType::
  configid () const
  {
    return this->configid_.get ();
  }

  SoftwareType::configid_type& SoftwareType::
  configid ()
  {
    return this->configid_.get ();
  }

  void SoftwareType::
  configid (const configid_type& x)
  {
    this->configid_.set (x);
  }

  void SoftwareType::
  configid (::std::auto_ptr< configid_type > x)
  {
    this->configid_.set (x);
  }

  const SoftwareType::configid_type& SoftwareType::
  configid_default_value ()
  {
    return configid_default_value_;
  }

  const SoftwareType::vendor_optional& SoftwareType::
  vendor () const
  {
    return this->vendor_;
  }

  SoftwareType::vendor_optional& SoftwareType::
  vendor ()
  {
    return this->vendor_;
  }

  void SoftwareType::
  vendor (const vendor_type& x)
  {
    this->vendor_.set (x);
  }

  void SoftwareType::
  vendor (const vendor_optional& x)
  {
    this->vendor_ = x;
  }

  void SoftwareType::
  vendor (::std::auto_ptr< vendor_type > x)
  {
    this->vendor_.set (x);
  }

  const SoftwareType::family_optional& SoftwareType::
  family () const
  {
    return this->family_;
  }

  SoftwareType::family_optional& SoftwareType::
  family ()
  {
    return this->family_;
  }

  void SoftwareType::
  family (const family_type& x)
  {
    this->family_.set (x);
  }

  void SoftwareType::
  family (const family_optional& x)
  {
    this->family_ = x;
  }

  void SoftwareType::
  family (::std::auto_ptr< family_type > x)
  {
    this->family_.set (x);
  }

  const SoftwareType::name_optional& SoftwareType::
  name () const
  {
    return this->name_;
  }

  SoftwareType::name_optional& SoftwareType::
  name ()
  {
    return this->name_;
  }

  void SoftwareType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void SoftwareType::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void SoftwareType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const SoftwareType::version_optional& SoftwareType::
  version () const
  {
    return this->version_;
  }

  SoftwareType::version_optional& SoftwareType::
  version ()
  {
    return this->version_;
  }

  void SoftwareType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void SoftwareType::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void SoftwareType::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const SoftwareType::patch_optional& SoftwareType::
  patch () const
  {
    return this->patch_;
  }

  SoftwareType::patch_optional& SoftwareType::
  patch ()
  {
    return this->patch_;
  }

  void SoftwareType::
  patch (const patch_type& x)
  {
    this->patch_.set (x);
  }

  void SoftwareType::
  patch (const patch_optional& x)
  {
    this->patch_ = x;
  }

  void SoftwareType::
  patch (::std::auto_ptr< patch_type > x)
  {
    this->patch_.set (x);
  }


  // PositiveFloatType
  // 


  // MLStringType
  // 

  const MLStringType::lang_optional& MLStringType::
  lang () const
  {
    return this->lang_;
  }

  MLStringType::lang_optional& MLStringType::
  lang ()
  {
    return this->lang_;
  }

  void MLStringType::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void MLStringType::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void MLStringType::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // ExtensionType
  // 

  const ExtensionType::dtype_type& ExtensionType::
  dtype () const
  {
    return this->dtype_.get ();
  }

  ExtensionType::dtype_type& ExtensionType::
  dtype ()
  {
    return this->dtype_.get ();
  }

  void ExtensionType::
  dtype (const dtype_type& x)
  {
    this->dtype_.set (x);
  }

  void ExtensionType::
  dtype (::std::auto_ptr< dtype_type > x)
  {
    this->dtype_.set (x);
  }

  const ExtensionType::ext_dtype_optional& ExtensionType::
  ext_dtype () const
  {
    return this->ext_dtype_;
  }

  ExtensionType::ext_dtype_optional& ExtensionType::
  ext_dtype ()
  {
    return this->ext_dtype_;
  }

  void ExtensionType::
  ext_dtype (const ext_dtype_type& x)
  {
    this->ext_dtype_.set (x);
  }

  void ExtensionType::
  ext_dtype (const ext_dtype_optional& x)
  {
    this->ext_dtype_ = x;
  }

  void ExtensionType::
  ext_dtype (::std::auto_ptr< ext_dtype_type > x)
  {
    this->ext_dtype_.set (x);
  }

  const ExtensionType::meaning_optional& ExtensionType::
  meaning () const
  {
    return this->meaning_;
  }

  ExtensionType::meaning_optional& ExtensionType::
  meaning ()
  {
    return this->meaning_;
  }

  void ExtensionType::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void ExtensionType::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void ExtensionType::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }

  const ExtensionType::formatid_optional& ExtensionType::
  formatid () const
  {
    return this->formatid_;
  }

  ExtensionType::formatid_optional& ExtensionType::
  formatid ()
  {
    return this->formatid_;
  }

  void ExtensionType::
  formatid (const formatid_type& x)
  {
    this->formatid_.set (x);
  }

  void ExtensionType::
  formatid (const formatid_optional& x)
  {
    this->formatid_ = x;
  }

  void ExtensionType::
  formatid (::std::auto_ptr< formatid_type > x)
  {
    this->formatid_.set (x);
  }

  const ExtensionType::restriction_optional& ExtensionType::
  restriction () const
  {
    return this->restriction_;
  }

  ExtensionType::restriction_optional& ExtensionType::
  restriction ()
  {
    return this->restriction_;
  }

  void ExtensionType::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void ExtensionType::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void ExtensionType::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // restriction_type
  // 

  restriction_type::
  restriction_type (value v)
  : ::xml_schema::nmtoken (_xsd_restriction_type_literals_[v])
  {
  }

  restriction_type::
  restriction_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  restriction_type::
  restriction_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  restriction_type::
  restriction_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  restriction_type::
  restriction_type (const restriction_type& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  restriction_type& restriction_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_restriction_type_literals_[v]);

    return *this;
  }


  // severity_type
  // 

  severity_type::
  severity_type (value v)
  : ::xml_schema::nmtoken (_xsd_severity_type_literals_[v])
  {
  }

  severity_type::
  severity_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  severity_type::
  severity_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  severity_type::
  severity_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  severity_type::
  severity_type (const severity_type& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  severity_type& severity_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_severity_type_literals_[v]);

    return *this;
  }


  // duration_type
  // 

  duration_type::
  duration_type (value v)
  : ::xml_schema::nmtoken (_xsd_duration_type_literals_[v])
  {
  }

  duration_type::
  duration_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  duration_type::
  duration_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  duration_type::
  duration_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  duration_type::
  duration_type (const duration_type& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  duration_type& duration_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_duration_type_literals_[v]);

    return *this;
  }


  // action_type
  // 

  action_type::
  action_type (value v)
  : ::xml_schema::nmtoken (_xsd_action_type_literals_[v])
  {
  }

  action_type::
  action_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  action_type::
  action_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  action_type::
  action_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  action_type::
  action_type (const action_type& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  action_type& action_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_action_type_literals_[v]);

    return *this;
  }


  // dtype_type
  // 

  dtype_type::
  dtype_type (value v)
  : ::xml_schema::nmtoken (_xsd_dtype_type_literals_[v])
  {
  }

  dtype_type::
  dtype_type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dtype_type::
  dtype_type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dtype_type::
  dtype_type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  dtype_type::
  dtype_type (const dtype_type& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  dtype_type& dtype_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_dtype_type_literals_[v]);

    return *this;
  }


  // IODEF_Document
  // 

  const IODEF_Document::Incident_sequence& IODEF_Document::
  Incident () const
  {
    return this->Incident_;
  }

  IODEF_Document::Incident_sequence& IODEF_Document::
  Incident ()
  {
    return this->Incident_;
  }

  void IODEF_Document::
  Incident (const Incident_sequence& s)
  {
    this->Incident_ = s;
  }

  const IODEF_Document::version_type& IODEF_Document::
  version () const
  {
    return this->version_.get ();
  }

  const IODEF_Document::version_type& IODEF_Document::
  version_default_value ()
  {
    return version_default_value_;
  }

  const IODEF_Document::lang_type& IODEF_Document::
  lang () const
  {
    return this->lang_.get ();
  }

  IODEF_Document::lang_type& IODEF_Document::
  lang ()
  {
    return this->lang_.get ();
  }

  void IODEF_Document::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void IODEF_Document::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const IODEF_Document::formatid_optional& IODEF_Document::
  formatid () const
  {
    return this->formatid_;
  }

  IODEF_Document::formatid_optional& IODEF_Document::
  formatid ()
  {
    return this->formatid_;
  }

  void IODEF_Document::
  formatid (const formatid_type& x)
  {
    this->formatid_.set (x);
  }

  void IODEF_Document::
  formatid (const formatid_optional& x)
  {
    this->formatid_ = x;
  }

  void IODEF_Document::
  formatid (::std::auto_ptr< formatid_type > x)
  {
    this->formatid_.set (x);
  }


  // Incident
  // 

  const Incident::IncidentID_type& Incident::
  IncidentID () const
  {
    return this->IncidentID_.get ();
  }

  Incident::IncidentID_type& Incident::
  IncidentID ()
  {
    return this->IncidentID_.get ();
  }

  void Incident::
  IncidentID (const IncidentID_type& x)
  {
    this->IncidentID_.set (x);
  }

  void Incident::
  IncidentID (::std::auto_ptr< IncidentID_type > x)
  {
    this->IncidentID_.set (x);
  }

  const Incident::AlternativeID_optional& Incident::
  AlternativeID () const
  {
    return this->AlternativeID_;
  }

  Incident::AlternativeID_optional& Incident::
  AlternativeID ()
  {
    return this->AlternativeID_;
  }

  void Incident::
  AlternativeID (const AlternativeID_type& x)
  {
    this->AlternativeID_.set (x);
  }

  void Incident::
  AlternativeID (const AlternativeID_optional& x)
  {
    this->AlternativeID_ = x;
  }

  void Incident::
  AlternativeID (::std::auto_ptr< AlternativeID_type > x)
  {
    this->AlternativeID_.set (x);
  }

  const Incident::RelatedActivity_optional& Incident::
  RelatedActivity () const
  {
    return this->RelatedActivity_;
  }

  Incident::RelatedActivity_optional& Incident::
  RelatedActivity ()
  {
    return this->RelatedActivity_;
  }

  void Incident::
  RelatedActivity (const RelatedActivity_type& x)
  {
    this->RelatedActivity_.set (x);
  }

  void Incident::
  RelatedActivity (const RelatedActivity_optional& x)
  {
    this->RelatedActivity_ = x;
  }

  void Incident::
  RelatedActivity (::std::auto_ptr< RelatedActivity_type > x)
  {
    this->RelatedActivity_.set (x);
  }

  const Incident::DetectTime_optional& Incident::
  DetectTime () const
  {
    return this->DetectTime_;
  }

  Incident::DetectTime_optional& Incident::
  DetectTime ()
  {
    return this->DetectTime_;
  }

  void Incident::
  DetectTime (const DetectTime_type& x)
  {
    this->DetectTime_.set (x);
  }

  void Incident::
  DetectTime (const DetectTime_optional& x)
  {
    this->DetectTime_ = x;
  }

  void Incident::
  DetectTime (::std::auto_ptr< DetectTime_type > x)
  {
    this->DetectTime_.set (x);
  }

  const Incident::StartTime_optional& Incident::
  StartTime () const
  {
    return this->StartTime_;
  }

  Incident::StartTime_optional& Incident::
  StartTime ()
  {
    return this->StartTime_;
  }

  void Incident::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void Incident::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void Incident::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const Incident::EndTime_optional& Incident::
  EndTime () const
  {
    return this->EndTime_;
  }

  Incident::EndTime_optional& Incident::
  EndTime ()
  {
    return this->EndTime_;
  }

  void Incident::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void Incident::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void Incident::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const Incident::ReportTime_type& Incident::
  ReportTime () const
  {
    return this->ReportTime_.get ();
  }

  Incident::ReportTime_type& Incident::
  ReportTime ()
  {
    return this->ReportTime_.get ();
  }

  void Incident::
  ReportTime (const ReportTime_type& x)
  {
    this->ReportTime_.set (x);
  }

  void Incident::
  ReportTime (::std::auto_ptr< ReportTime_type > x)
  {
    this->ReportTime_.set (x);
  }

  const Incident::Description_sequence& Incident::
  Description () const
  {
    return this->Description_;
  }

  Incident::Description_sequence& Incident::
  Description ()
  {
    return this->Description_;
  }

  void Incident::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Incident::Assessment_sequence& Incident::
  Assessment () const
  {
    return this->Assessment_;
  }

  Incident::Assessment_sequence& Incident::
  Assessment ()
  {
    return this->Assessment_;
  }

  void Incident::
  Assessment (const Assessment_sequence& s)
  {
    this->Assessment_ = s;
  }

  const Incident::Method_sequence& Incident::
  Method () const
  {
    return this->Method_;
  }

  Incident::Method_sequence& Incident::
  Method ()
  {
    return this->Method_;
  }

  void Incident::
  Method (const Method_sequence& s)
  {
    this->Method_ = s;
  }

  const Incident::Contact_sequence& Incident::
  Contact () const
  {
    return this->Contact_;
  }

  Incident::Contact_sequence& Incident::
  Contact ()
  {
    return this->Contact_;
  }

  void Incident::
  Contact (const Contact_sequence& s)
  {
    this->Contact_ = s;
  }

  const Incident::EventData_sequence& Incident::
  EventData () const
  {
    return this->EventData_;
  }

  Incident::EventData_sequence& Incident::
  EventData ()
  {
    return this->EventData_;
  }

  void Incident::
  EventData (const EventData_sequence& s)
  {
    this->EventData_ = s;
  }

  const Incident::History_optional& Incident::
  History () const
  {
    return this->History_;
  }

  Incident::History_optional& Incident::
  History ()
  {
    return this->History_;
  }

  void Incident::
  History (const History_type& x)
  {
    this->History_.set (x);
  }

  void Incident::
  History (const History_optional& x)
  {
    this->History_ = x;
  }

  void Incident::
  History (::std::auto_ptr< History_type > x)
  {
    this->History_.set (x);
  }

  const Incident::AdditionalData_sequence& Incident::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Incident::AdditionalData_sequence& Incident::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Incident::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Incident::purpose_type& Incident::
  purpose () const
  {
    return this->purpose_.get ();
  }

  Incident::purpose_type& Incident::
  purpose ()
  {
    return this->purpose_.get ();
  }

  void Incident::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void Incident::
  purpose (::std::auto_ptr< purpose_type > x)
  {
    this->purpose_.set (x);
  }

  const Incident::ext_purpose_optional& Incident::
  ext_purpose () const
  {
    return this->ext_purpose_;
  }

  Incident::ext_purpose_optional& Incident::
  ext_purpose ()
  {
    return this->ext_purpose_;
  }

  void Incident::
  ext_purpose (const ext_purpose_type& x)
  {
    this->ext_purpose_.set (x);
  }

  void Incident::
  ext_purpose (const ext_purpose_optional& x)
  {
    this->ext_purpose_ = x;
  }

  void Incident::
  ext_purpose (::std::auto_ptr< ext_purpose_type > x)
  {
    this->ext_purpose_.set (x);
  }

  const Incident::lang_optional& Incident::
  lang () const
  {
    return this->lang_;
  }

  Incident::lang_optional& Incident::
  lang ()
  {
    return this->lang_;
  }

  void Incident::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void Incident::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void Incident::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const Incident::restriction_type& Incident::
  restriction () const
  {
    return this->restriction_.get ();
  }

  Incident::restriction_type& Incident::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void Incident::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Incident::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Incident::restriction_type& Incident::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }


  // AlternativeID
  // 

  const AlternativeID::IncidentID_sequence& AlternativeID::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  AlternativeID::IncidentID_sequence& AlternativeID::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void AlternativeID::
  IncidentID (const IncidentID_sequence& s)
  {
    this->IncidentID_ = s;
  }

  const AlternativeID::restriction_optional& AlternativeID::
  restriction () const
  {
    return this->restriction_;
  }

  AlternativeID::restriction_optional& AlternativeID::
  restriction ()
  {
    return this->restriction_;
  }

  void AlternativeID::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void AlternativeID::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void AlternativeID::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // RelatedActivity
  // 

  const RelatedActivity::IncidentID_sequence& RelatedActivity::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  RelatedActivity::IncidentID_sequence& RelatedActivity::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void RelatedActivity::
  IncidentID (const IncidentID_sequence& s)
  {
    this->IncidentID_ = s;
  }

  const RelatedActivity::URL_sequence& RelatedActivity::
  URL () const
  {
    return this->URL_;
  }

  RelatedActivity::URL_sequence& RelatedActivity::
  URL ()
  {
    return this->URL_;
  }

  void RelatedActivity::
  URL (const URL_sequence& s)
  {
    this->URL_ = s;
  }

  const RelatedActivity::restriction_optional& RelatedActivity::
  restriction () const
  {
    return this->restriction_;
  }

  RelatedActivity::restriction_optional& RelatedActivity::
  restriction ()
  {
    return this->restriction_;
  }

  void RelatedActivity::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void RelatedActivity::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void RelatedActivity::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Contact
  // 

  const Contact::ContactName_optional& Contact::
  ContactName () const
  {
    return this->ContactName_;
  }

  Contact::ContactName_optional& Contact::
  ContactName ()
  {
    return this->ContactName_;
  }

  void Contact::
  ContactName (const ContactName_type& x)
  {
    this->ContactName_.set (x);
  }

  void Contact::
  ContactName (const ContactName_optional& x)
  {
    this->ContactName_ = x;
  }

  void Contact::
  ContactName (::std::auto_ptr< ContactName_type > x)
  {
    this->ContactName_.set (x);
  }

  const Contact::Description_sequence& Contact::
  Description () const
  {
    return this->Description_;
  }

  Contact::Description_sequence& Contact::
  Description ()
  {
    return this->Description_;
  }

  void Contact::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Contact::RegistryHandle_sequence& Contact::
  RegistryHandle () const
  {
    return this->RegistryHandle_;
  }

  Contact::RegistryHandle_sequence& Contact::
  RegistryHandle ()
  {
    return this->RegistryHandle_;
  }

  void Contact::
  RegistryHandle (const RegistryHandle_sequence& s)
  {
    this->RegistryHandle_ = s;
  }

  const Contact::PostalAddress_optional& Contact::
  PostalAddress () const
  {
    return this->PostalAddress_;
  }

  Contact::PostalAddress_optional& Contact::
  PostalAddress ()
  {
    return this->PostalAddress_;
  }

  void Contact::
  PostalAddress (const PostalAddress_type& x)
  {
    this->PostalAddress_.set (x);
  }

  void Contact::
  PostalAddress (const PostalAddress_optional& x)
  {
    this->PostalAddress_ = x;
  }

  void Contact::
  PostalAddress (::std::auto_ptr< PostalAddress_type > x)
  {
    this->PostalAddress_.set (x);
  }

  const Contact::Email_sequence& Contact::
  Email () const
  {
    return this->Email_;
  }

  Contact::Email_sequence& Contact::
  Email ()
  {
    return this->Email_;
  }

  void Contact::
  Email (const Email_sequence& s)
  {
    this->Email_ = s;
  }

  const Contact::Telephone_sequence& Contact::
  Telephone () const
  {
    return this->Telephone_;
  }

  Contact::Telephone_sequence& Contact::
  Telephone ()
  {
    return this->Telephone_;
  }

  void Contact::
  Telephone (const Telephone_sequence& s)
  {
    this->Telephone_ = s;
  }

  const Contact::Fax_optional& Contact::
  Fax () const
  {
    return this->Fax_;
  }

  Contact::Fax_optional& Contact::
  Fax ()
  {
    return this->Fax_;
  }

  void Contact::
  Fax (const Fax_type& x)
  {
    this->Fax_.set (x);
  }

  void Contact::
  Fax (const Fax_optional& x)
  {
    this->Fax_ = x;
  }

  void Contact::
  Fax (::std::auto_ptr< Fax_type > x)
  {
    this->Fax_.set (x);
  }

  const Contact::Timezone_optional& Contact::
  Timezone () const
  {
    return this->Timezone_;
  }

  Contact::Timezone_optional& Contact::
  Timezone ()
  {
    return this->Timezone_;
  }

  void Contact::
  Timezone (const Timezone_type& x)
  {
    this->Timezone_.set (x);
  }

  void Contact::
  Timezone (const Timezone_optional& x)
  {
    this->Timezone_ = x;
  }

  void Contact::
  Timezone (::std::auto_ptr< Timezone_type > x)
  {
    this->Timezone_.set (x);
  }

  const Contact::Contact1_sequence& Contact::
  Contact1 () const
  {
    return this->Contact1_;
  }

  Contact::Contact1_sequence& Contact::
  Contact1 ()
  {
    return this->Contact1_;
  }

  void Contact::
  Contact1 (const Contact1_sequence& s)
  {
    this->Contact1_ = s;
  }

  const Contact::AdditionalData_sequence& Contact::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Contact::AdditionalData_sequence& Contact::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Contact::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Contact::role_type& Contact::
  role () const
  {
    return this->role_.get ();
  }

  Contact::role_type& Contact::
  role ()
  {
    return this->role_.get ();
  }

  void Contact::
  role (const role_type& x)
  {
    this->role_.set (x);
  }

  void Contact::
  role (::std::auto_ptr< role_type > x)
  {
    this->role_.set (x);
  }

  const Contact::ext_role_optional& Contact::
  ext_role () const
  {
    return this->ext_role_;
  }

  Contact::ext_role_optional& Contact::
  ext_role ()
  {
    return this->ext_role_;
  }

  void Contact::
  ext_role (const ext_role_type& x)
  {
    this->ext_role_.set (x);
  }

  void Contact::
  ext_role (const ext_role_optional& x)
  {
    this->ext_role_ = x;
  }

  void Contact::
  ext_role (::std::auto_ptr< ext_role_type > x)
  {
    this->ext_role_.set (x);
  }

  const Contact::type_type& Contact::
  type () const
  {
    return this->type_.get ();
  }

  Contact::type_type& Contact::
  type ()
  {
    return this->type_.get ();
  }

  void Contact::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Contact::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const Contact::ext_type_optional& Contact::
  ext_type () const
  {
    return this->ext_type_;
  }

  Contact::ext_type_optional& Contact::
  ext_type ()
  {
    return this->ext_type_;
  }

  void Contact::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void Contact::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void Contact::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const Contact::restriction_optional& Contact::
  restriction () const
  {
    return this->restriction_;
  }

  Contact::restriction_optional& Contact::
  restriction ()
  {
    return this->restriction_;
  }

  void Contact::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Contact::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Contact::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // RegistryHandle
  // 

  const RegistryHandle::registry_optional& RegistryHandle::
  registry () const
  {
    return this->registry_;
  }

  RegistryHandle::registry_optional& RegistryHandle::
  registry ()
  {
    return this->registry_;
  }

  void RegistryHandle::
  registry (const registry_type& x)
  {
    this->registry_.set (x);
  }

  void RegistryHandle::
  registry (const registry_optional& x)
  {
    this->registry_ = x;
  }

  void RegistryHandle::
  registry (::std::auto_ptr< registry_type > x)
  {
    this->registry_.set (x);
  }

  const RegistryHandle::ext_registry_optional& RegistryHandle::
  ext_registry () const
  {
    return this->ext_registry_;
  }

  RegistryHandle::ext_registry_optional& RegistryHandle::
  ext_registry ()
  {
    return this->ext_registry_;
  }

  void RegistryHandle::
  ext_registry (const ext_registry_type& x)
  {
    this->ext_registry_.set (x);
  }

  void RegistryHandle::
  ext_registry (const ext_registry_optional& x)
  {
    this->ext_registry_ = x;
  }

  void RegistryHandle::
  ext_registry (::std::auto_ptr< ext_registry_type > x)
  {
    this->ext_registry_.set (x);
  }


  // PostalAddress
  // 

  const PostalAddress::meaning_optional& PostalAddress::
  meaning () const
  {
    return this->meaning_;
  }

  PostalAddress::meaning_optional& PostalAddress::
  meaning ()
  {
    return this->meaning_;
  }

  void PostalAddress::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void PostalAddress::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void PostalAddress::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }


  // History
  // 

  const History::HistoryItem_sequence& History::
  HistoryItem () const
  {
    return this->HistoryItem_;
  }

  History::HistoryItem_sequence& History::
  HistoryItem ()
  {
    return this->HistoryItem_;
  }

  void History::
  HistoryItem (const HistoryItem_sequence& s)
  {
    this->HistoryItem_ = s;
  }

  const History::restriction_type& History::
  restriction () const
  {
    return this->restriction_.get ();
  }

  History::restriction_type& History::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void History::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void History::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const History::restriction_type& History::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }


  // HistoryItem
  // 

  const HistoryItem::DateTime_type& HistoryItem::
  DateTime () const
  {
    return this->DateTime_.get ();
  }

  HistoryItem::DateTime_type& HistoryItem::
  DateTime ()
  {
    return this->DateTime_.get ();
  }

  void HistoryItem::
  DateTime (const DateTime_type& x)
  {
    this->DateTime_.set (x);
  }

  void HistoryItem::
  DateTime (::std::auto_ptr< DateTime_type > x)
  {
    this->DateTime_.set (x);
  }

  const HistoryItem::IncidentID_optional& HistoryItem::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  HistoryItem::IncidentID_optional& HistoryItem::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void HistoryItem::
  IncidentID (const IncidentID_type& x)
  {
    this->IncidentID_.set (x);
  }

  void HistoryItem::
  IncidentID (const IncidentID_optional& x)
  {
    this->IncidentID_ = x;
  }

  void HistoryItem::
  IncidentID (::std::auto_ptr< IncidentID_type > x)
  {
    this->IncidentID_.set (x);
  }

  const HistoryItem::Contact_optional& HistoryItem::
  Contact () const
  {
    return this->Contact_;
  }

  HistoryItem::Contact_optional& HistoryItem::
  Contact ()
  {
    return this->Contact_;
  }

  void HistoryItem::
  Contact (const Contact_type& x)
  {
    this->Contact_.set (x);
  }

  void HistoryItem::
  Contact (const Contact_optional& x)
  {
    this->Contact_ = x;
  }

  void HistoryItem::
  Contact (::std::auto_ptr< Contact_type > x)
  {
    this->Contact_.set (x);
  }

  const HistoryItem::Description_sequence& HistoryItem::
  Description () const
  {
    return this->Description_;
  }

  HistoryItem::Description_sequence& HistoryItem::
  Description ()
  {
    return this->Description_;
  }

  void HistoryItem::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const HistoryItem::AdditionalData_sequence& HistoryItem::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  HistoryItem::AdditionalData_sequence& HistoryItem::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void HistoryItem::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const HistoryItem::restriction_optional& HistoryItem::
  restriction () const
  {
    return this->restriction_;
  }

  HistoryItem::restriction_optional& HistoryItem::
  restriction ()
  {
    return this->restriction_;
  }

  void HistoryItem::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void HistoryItem::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void HistoryItem::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const HistoryItem::action_type& HistoryItem::
  action () const
  {
    return this->action_.get ();
  }

  HistoryItem::action_type& HistoryItem::
  action ()
  {
    return this->action_.get ();
  }

  void HistoryItem::
  action (const action_type& x)
  {
    this->action_.set (x);
  }

  void HistoryItem::
  action (::std::auto_ptr< action_type > x)
  {
    this->action_.set (x);
  }

  const HistoryItem::ext_action_optional& HistoryItem::
  ext_action () const
  {
    return this->ext_action_;
  }

  HistoryItem::ext_action_optional& HistoryItem::
  ext_action ()
  {
    return this->ext_action_;
  }

  void HistoryItem::
  ext_action (const ext_action_type& x)
  {
    this->ext_action_.set (x);
  }

  void HistoryItem::
  ext_action (const ext_action_optional& x)
  {
    this->ext_action_ = x;
  }

  void HistoryItem::
  ext_action (::std::auto_ptr< ext_action_type > x)
  {
    this->ext_action_.set (x);
  }


  // Expectation
  // 

  const Expectation::Description_sequence& Expectation::
  Description () const
  {
    return this->Description_;
  }

  Expectation::Description_sequence& Expectation::
  Description ()
  {
    return this->Description_;
  }

  void Expectation::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Expectation::StartTime_optional& Expectation::
  StartTime () const
  {
    return this->StartTime_;
  }

  Expectation::StartTime_optional& Expectation::
  StartTime ()
  {
    return this->StartTime_;
  }

  void Expectation::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void Expectation::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void Expectation::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const Expectation::EndTime_optional& Expectation::
  EndTime () const
  {
    return this->EndTime_;
  }

  Expectation::EndTime_optional& Expectation::
  EndTime ()
  {
    return this->EndTime_;
  }

  void Expectation::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void Expectation::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void Expectation::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const Expectation::Contact_optional& Expectation::
  Contact () const
  {
    return this->Contact_;
  }

  Expectation::Contact_optional& Expectation::
  Contact ()
  {
    return this->Contact_;
  }

  void Expectation::
  Contact (const Contact_type& x)
  {
    this->Contact_.set (x);
  }

  void Expectation::
  Contact (const Contact_optional& x)
  {
    this->Contact_ = x;
  }

  void Expectation::
  Contact (::std::auto_ptr< Contact_type > x)
  {
    this->Contact_.set (x);
  }

  const Expectation::restriction_type& Expectation::
  restriction () const
  {
    return this->restriction_.get ();
  }

  Expectation::restriction_type& Expectation::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void Expectation::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Expectation::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Expectation::restriction_type& Expectation::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }

  const Expectation::severity_optional& Expectation::
  severity () const
  {
    return this->severity_;
  }

  Expectation::severity_optional& Expectation::
  severity ()
  {
    return this->severity_;
  }

  void Expectation::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void Expectation::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void Expectation::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const Expectation::action_type& Expectation::
  action () const
  {
    return this->action_.get ();
  }

  Expectation::action_type& Expectation::
  action ()
  {
    return this->action_.get ();
  }

  void Expectation::
  action (const action_type& x)
  {
    this->action_.set (x);
  }

  void Expectation::
  action (::std::auto_ptr< action_type > x)
  {
    this->action_.set (x);
  }

  const Expectation::action_type& Expectation::
  action_default_value ()
  {
    return action_default_value_;
  }

  const Expectation::ext_action_optional& Expectation::
  ext_action () const
  {
    return this->ext_action_;
  }

  Expectation::ext_action_optional& Expectation::
  ext_action ()
  {
    return this->ext_action_;
  }

  void Expectation::
  ext_action (const ext_action_type& x)
  {
    this->ext_action_.set (x);
  }

  void Expectation::
  ext_action (const ext_action_optional& x)
  {
    this->ext_action_ = x;
  }

  void Expectation::
  ext_action (::std::auto_ptr< ext_action_type > x)
  {
    this->ext_action_.set (x);
  }


  // Method
  // 

  const Method::Reference_sequence& Method::
  Reference () const
  {
    return this->Reference_;
  }

  Method::Reference_sequence& Method::
  Reference ()
  {
    return this->Reference_;
  }

  void Method::
  Reference (const Reference_sequence& s)
  {
    this->Reference_ = s;
  }

  const Method::Description_sequence& Method::
  Description () const
  {
    return this->Description_;
  }

  Method::Description_sequence& Method::
  Description ()
  {
    return this->Description_;
  }

  void Method::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Method::AdditionalData_sequence& Method::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Method::AdditionalData_sequence& Method::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Method::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Method::restriction_optional& Method::
  restriction () const
  {
    return this->restriction_;
  }

  Method::restriction_optional& Method::
  restriction ()
  {
    return this->restriction_;
  }

  void Method::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Method::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Method::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Reference
  // 

  const Reference::ReferenceName_type& Reference::
  ReferenceName () const
  {
    return this->ReferenceName_.get ();
  }

  Reference::ReferenceName_type& Reference::
  ReferenceName ()
  {
    return this->ReferenceName_.get ();
  }

  void Reference::
  ReferenceName (const ReferenceName_type& x)
  {
    this->ReferenceName_.set (x);
  }

  void Reference::
  ReferenceName (::std::auto_ptr< ReferenceName_type > x)
  {
    this->ReferenceName_.set (x);
  }

  const Reference::URL_sequence& Reference::
  URL () const
  {
    return this->URL_;
  }

  Reference::URL_sequence& Reference::
  URL ()
  {
    return this->URL_;
  }

  void Reference::
  URL (const URL_sequence& s)
  {
    this->URL_ = s;
  }

  const Reference::Description_sequence& Reference::
  Description () const
  {
    return this->Description_;
  }

  Reference::Description_sequence& Reference::
  Description ()
  {
    return this->Description_;
  }

  void Reference::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }


  // Assessment
  // 

  const Assessment::Impact_sequence& Assessment::
  Impact () const
  {
    return this->Impact_;
  }

  Assessment::Impact_sequence& Assessment::
  Impact ()
  {
    return this->Impact_;
  }

  void Assessment::
  Impact (const Impact_sequence& s)
  {
    this->Impact_ = s;
  }

  const Assessment::TimeImpact_sequence& Assessment::
  TimeImpact () const
  {
    return this->TimeImpact_;
  }

  Assessment::TimeImpact_sequence& Assessment::
  TimeImpact ()
  {
    return this->TimeImpact_;
  }

  void Assessment::
  TimeImpact (const TimeImpact_sequence& s)
  {
    this->TimeImpact_ = s;
  }

  const Assessment::MonetaryImpact_sequence& Assessment::
  MonetaryImpact () const
  {
    return this->MonetaryImpact_;
  }

  Assessment::MonetaryImpact_sequence& Assessment::
  MonetaryImpact ()
  {
    return this->MonetaryImpact_;
  }

  void Assessment::
  MonetaryImpact (const MonetaryImpact_sequence& s)
  {
    this->MonetaryImpact_ = s;
  }

  const Assessment::Counter_sequence& Assessment::
  Counter () const
  {
    return this->Counter_;
  }

  Assessment::Counter_sequence& Assessment::
  Counter ()
  {
    return this->Counter_;
  }

  void Assessment::
  Counter (const Counter_sequence& s)
  {
    this->Counter_ = s;
  }

  const Assessment::Confidence_optional& Assessment::
  Confidence () const
  {
    return this->Confidence_;
  }

  Assessment::Confidence_optional& Assessment::
  Confidence ()
  {
    return this->Confidence_;
  }

  void Assessment::
  Confidence (const Confidence_type& x)
  {
    this->Confidence_.set (x);
  }

  void Assessment::
  Confidence (const Confidence_optional& x)
  {
    this->Confidence_ = x;
  }

  void Assessment::
  Confidence (::std::auto_ptr< Confidence_type > x)
  {
    this->Confidence_.set (x);
  }

  const Assessment::AdditionalData_sequence& Assessment::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Assessment::AdditionalData_sequence& Assessment::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Assessment::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Assessment::occurrence_optional& Assessment::
  occurrence () const
  {
    return this->occurrence_;
  }

  Assessment::occurrence_optional& Assessment::
  occurrence ()
  {
    return this->occurrence_;
  }

  void Assessment::
  occurrence (const occurrence_type& x)
  {
    this->occurrence_.set (x);
  }

  void Assessment::
  occurrence (const occurrence_optional& x)
  {
    this->occurrence_ = x;
  }

  void Assessment::
  occurrence (::std::auto_ptr< occurrence_type > x)
  {
    this->occurrence_.set (x);
  }

  const Assessment::restriction_optional& Assessment::
  restriction () const
  {
    return this->restriction_;
  }

  Assessment::restriction_optional& Assessment::
  restriction ()
  {
    return this->restriction_;
  }

  void Assessment::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Assessment::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Assessment::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Impact
  // 

  const Impact::severity_optional& Impact::
  severity () const
  {
    return this->severity_;
  }

  Impact::severity_optional& Impact::
  severity ()
  {
    return this->severity_;
  }

  void Impact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void Impact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void Impact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const Impact::completion_optional& Impact::
  completion () const
  {
    return this->completion_;
  }

  Impact::completion_optional& Impact::
  completion ()
  {
    return this->completion_;
  }

  void Impact::
  completion (const completion_type& x)
  {
    this->completion_.set (x);
  }

  void Impact::
  completion (const completion_optional& x)
  {
    this->completion_ = x;
  }

  void Impact::
  completion (::std::auto_ptr< completion_type > x)
  {
    this->completion_.set (x);
  }

  const Impact::type_type& Impact::
  type () const
  {
    return this->type_.get ();
  }

  Impact::type_type& Impact::
  type ()
  {
    return this->type_.get ();
  }

  void Impact::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Impact::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const Impact::type_type& Impact::
  type_default_value ()
  {
    return type_default_value_;
  }

  const Impact::ext_type_optional& Impact::
  ext_type () const
  {
    return this->ext_type_;
  }

  Impact::ext_type_optional& Impact::
  ext_type ()
  {
    return this->ext_type_;
  }

  void Impact::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void Impact::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void Impact::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }


  // TimeImpact
  // 

  const TimeImpact::severity_optional& TimeImpact::
  severity () const
  {
    return this->severity_;
  }

  TimeImpact::severity_optional& TimeImpact::
  severity ()
  {
    return this->severity_;
  }

  void TimeImpact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void TimeImpact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void TimeImpact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const TimeImpact::metric_type& TimeImpact::
  metric () const
  {
    return this->metric_.get ();
  }

  TimeImpact::metric_type& TimeImpact::
  metric ()
  {
    return this->metric_.get ();
  }

  void TimeImpact::
  metric (const metric_type& x)
  {
    this->metric_.set (x);
  }

  void TimeImpact::
  metric (::std::auto_ptr< metric_type > x)
  {
    this->metric_.set (x);
  }

  const TimeImpact::ext_metric_optional& TimeImpact::
  ext_metric () const
  {
    return this->ext_metric_;
  }

  TimeImpact::ext_metric_optional& TimeImpact::
  ext_metric ()
  {
    return this->ext_metric_;
  }

  void TimeImpact::
  ext_metric (const ext_metric_type& x)
  {
    this->ext_metric_.set (x);
  }

  void TimeImpact::
  ext_metric (const ext_metric_optional& x)
  {
    this->ext_metric_ = x;
  }

  void TimeImpact::
  ext_metric (::std::auto_ptr< ext_metric_type > x)
  {
    this->ext_metric_.set (x);
  }

  const TimeImpact::duration_optional& TimeImpact::
  duration () const
  {
    return this->duration_;
  }

  TimeImpact::duration_optional& TimeImpact::
  duration ()
  {
    return this->duration_;
  }

  void TimeImpact::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void TimeImpact::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void TimeImpact::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }

  const TimeImpact::ext_duration_optional& TimeImpact::
  ext_duration () const
  {
    return this->ext_duration_;
  }

  TimeImpact::ext_duration_optional& TimeImpact::
  ext_duration ()
  {
    return this->ext_duration_;
  }

  void TimeImpact::
  ext_duration (const ext_duration_type& x)
  {
    this->ext_duration_.set (x);
  }

  void TimeImpact::
  ext_duration (const ext_duration_optional& x)
  {
    this->ext_duration_ = x;
  }

  void TimeImpact::
  ext_duration (::std::auto_ptr< ext_duration_type > x)
  {
    this->ext_duration_.set (x);
  }


  // MonetaryImpact
  // 

  const MonetaryImpact::severity_optional& MonetaryImpact::
  severity () const
  {
    return this->severity_;
  }

  MonetaryImpact::severity_optional& MonetaryImpact::
  severity ()
  {
    return this->severity_;
  }

  void MonetaryImpact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void MonetaryImpact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void MonetaryImpact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const MonetaryImpact::currency_optional& MonetaryImpact::
  currency () const
  {
    return this->currency_;
  }

  MonetaryImpact::currency_optional& MonetaryImpact::
  currency ()
  {
    return this->currency_;
  }

  void MonetaryImpact::
  currency (const currency_type& x)
  {
    this->currency_.set (x);
  }

  void MonetaryImpact::
  currency (const currency_optional& x)
  {
    this->currency_ = x;
  }

  void MonetaryImpact::
  currency (::std::auto_ptr< currency_type > x)
  {
    this->currency_.set (x);
  }


  // Confidence
  // 

  const Confidence::rating_type& Confidence::
  rating () const
  {
    return this->rating_.get ();
  }

  Confidence::rating_type& Confidence::
  rating ()
  {
    return this->rating_.get ();
  }

  void Confidence::
  rating (const rating_type& x)
  {
    this->rating_.set (x);
  }

  void Confidence::
  rating (::std::auto_ptr< rating_type > x)
  {
    this->rating_.set (x);
  }


  // EventData
  // 

  const EventData::Description_sequence& EventData::
  Description () const
  {
    return this->Description_;
  }

  EventData::Description_sequence& EventData::
  Description ()
  {
    return this->Description_;
  }

  void EventData::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const EventData::DetectTime_optional& EventData::
  DetectTime () const
  {
    return this->DetectTime_;
  }

  EventData::DetectTime_optional& EventData::
  DetectTime ()
  {
    return this->DetectTime_;
  }

  void EventData::
  DetectTime (const DetectTime_type& x)
  {
    this->DetectTime_.set (x);
  }

  void EventData::
  DetectTime (const DetectTime_optional& x)
  {
    this->DetectTime_ = x;
  }

  void EventData::
  DetectTime (::std::auto_ptr< DetectTime_type > x)
  {
    this->DetectTime_.set (x);
  }

  const EventData::StartTime_optional& EventData::
  StartTime () const
  {
    return this->StartTime_;
  }

  EventData::StartTime_optional& EventData::
  StartTime ()
  {
    return this->StartTime_;
  }

  void EventData::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void EventData::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void EventData::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const EventData::EndTime_optional& EventData::
  EndTime () const
  {
    return this->EndTime_;
  }

  EventData::EndTime_optional& EventData::
  EndTime ()
  {
    return this->EndTime_;
  }

  void EventData::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void EventData::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void EventData::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const EventData::Contact_sequence& EventData::
  Contact () const
  {
    return this->Contact_;
  }

  EventData::Contact_sequence& EventData::
  Contact ()
  {
    return this->Contact_;
  }

  void EventData::
  Contact (const Contact_sequence& s)
  {
    this->Contact_ = s;
  }

  const EventData::Assessment_optional& EventData::
  Assessment () const
  {
    return this->Assessment_;
  }

  EventData::Assessment_optional& EventData::
  Assessment ()
  {
    return this->Assessment_;
  }

  void EventData::
  Assessment (const Assessment_type& x)
  {
    this->Assessment_.set (x);
  }

  void EventData::
  Assessment (const Assessment_optional& x)
  {
    this->Assessment_ = x;
  }

  void EventData::
  Assessment (::std::auto_ptr< Assessment_type > x)
  {
    this->Assessment_.set (x);
  }

  const EventData::Method_sequence& EventData::
  Method () const
  {
    return this->Method_;
  }

  EventData::Method_sequence& EventData::
  Method ()
  {
    return this->Method_;
  }

  void EventData::
  Method (const Method_sequence& s)
  {
    this->Method_ = s;
  }

  const EventData::Flow_sequence& EventData::
  Flow () const
  {
    return this->Flow_;
  }

  EventData::Flow_sequence& EventData::
  Flow ()
  {
    return this->Flow_;
  }

  void EventData::
  Flow (const Flow_sequence& s)
  {
    this->Flow_ = s;
  }

  const EventData::Expectation_sequence& EventData::
  Expectation () const
  {
    return this->Expectation_;
  }

  EventData::Expectation_sequence& EventData::
  Expectation ()
  {
    return this->Expectation_;
  }

  void EventData::
  Expectation (const Expectation_sequence& s)
  {
    this->Expectation_ = s;
  }

  const EventData::Record_optional& EventData::
  Record () const
  {
    return this->Record_;
  }

  EventData::Record_optional& EventData::
  Record ()
  {
    return this->Record_;
  }

  void EventData::
  Record (const Record_type& x)
  {
    this->Record_.set (x);
  }

  void EventData::
  Record (const Record_optional& x)
  {
    this->Record_ = x;
  }

  void EventData::
  Record (::std::auto_ptr< Record_type > x)
  {
    this->Record_.set (x);
  }

  const EventData::EventData1_sequence& EventData::
  EventData1 () const
  {
    return this->EventData1_;
  }

  EventData::EventData1_sequence& EventData::
  EventData1 ()
  {
    return this->EventData1_;
  }

  void EventData::
  EventData1 (const EventData1_sequence& s)
  {
    this->EventData1_ = s;
  }

  const EventData::AdditionalData_sequence& EventData::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  EventData::AdditionalData_sequence& EventData::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void EventData::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const EventData::restriction_type& EventData::
  restriction () const
  {
    return this->restriction_.get ();
  }

  EventData::restriction_type& EventData::
  restriction ()
  {
    return this->restriction_.get ();
  }

  void EventData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void EventData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const EventData::restriction_type& EventData::
  restriction_default_value ()
  {
    return restriction_default_value_;
  }


  // Flow
  // 

  const Flow::System_sequence& Flow::
  System () const
  {
    return this->System_;
  }

  Flow::System_sequence& Flow::
  System ()
  {
    return this->System_;
  }

  void Flow::
  System (const System_sequence& s)
  {
    this->System_ = s;
  }


  // System
  // 

  const System::Node_type& System::
  Node () const
  {
    return this->Node_.get ();
  }

  System::Node_type& System::
  Node ()
  {
    return this->Node_.get ();
  }

  void System::
  Node (const Node_type& x)
  {
    this->Node_.set (x);
  }

  void System::
  Node (::std::auto_ptr< Node_type > x)
  {
    this->Node_.set (x);
  }

  const System::Service_sequence& System::
  Service () const
  {
    return this->Service_;
  }

  System::Service_sequence& System::
  Service ()
  {
    return this->Service_;
  }

  void System::
  Service (const Service_sequence& s)
  {
    this->Service_ = s;
  }

  const System::OperatingSystem_sequence& System::
  OperatingSystem () const
  {
    return this->OperatingSystem_;
  }

  System::OperatingSystem_sequence& System::
  OperatingSystem ()
  {
    return this->OperatingSystem_;
  }

  void System::
  OperatingSystem (const OperatingSystem_sequence& s)
  {
    this->OperatingSystem_ = s;
  }

  const System::Counter_sequence& System::
  Counter () const
  {
    return this->Counter_;
  }

  System::Counter_sequence& System::
  Counter ()
  {
    return this->Counter_;
  }

  void System::
  Counter (const Counter_sequence& s)
  {
    this->Counter_ = s;
  }

  const System::Description_sequence& System::
  Description () const
  {
    return this->Description_;
  }

  System::Description_sequence& System::
  Description ()
  {
    return this->Description_;
  }

  void System::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const System::AdditionalData_sequence& System::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  System::AdditionalData_sequence& System::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void System::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const System::restriction_optional& System::
  restriction () const
  {
    return this->restriction_;
  }

  System::restriction_optional& System::
  restriction ()
  {
    return this->restriction_;
  }

  void System::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void System::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void System::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const System::interface_optional& System::
  interface () const
  {
    return this->interface_;
  }

  System::interface_optional& System::
  interface ()
  {
    return this->interface_;
  }

  void System::
  interface (const interface_type& x)
  {
    this->interface_.set (x);
  }

  void System::
  interface (const interface_optional& x)
  {
    this->interface_ = x;
  }

  void System::
  interface (::std::auto_ptr< interface_type > x)
  {
    this->interface_.set (x);
  }

  const System::category_optional& System::
  category () const
  {
    return this->category_;
  }

  System::category_optional& System::
  category ()
  {
    return this->category_;
  }

  void System::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void System::
  category (const category_optional& x)
  {
    this->category_ = x;
  }

  void System::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const System::ext_category_optional& System::
  ext_category () const
  {
    return this->ext_category_;
  }

  System::ext_category_optional& System::
  ext_category ()
  {
    return this->ext_category_;
  }

  void System::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void System::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void System::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }

  const System::spoofed_type& System::
  spoofed () const
  {
    return this->spoofed_.get ();
  }

  System::spoofed_type& System::
  spoofed ()
  {
    return this->spoofed_.get ();
  }

  void System::
  spoofed (const spoofed_type& x)
  {
    this->spoofed_.set (x);
  }

  void System::
  spoofed (::std::auto_ptr< spoofed_type > x)
  {
    this->spoofed_.set (x);
  }

  const System::spoofed_type& System::
  spoofed_default_value ()
  {
    return spoofed_default_value_;
  }


  // Node
  // 

  const Node::NodeName_sequence& Node::
  NodeName () const
  {
    return this->NodeName_;
  }

  Node::NodeName_sequence& Node::
  NodeName ()
  {
    return this->NodeName_;
  }

  void Node::
  NodeName (const NodeName_sequence& s)
  {
    this->NodeName_ = s;
  }

  const Node::Address_sequence& Node::
  Address () const
  {
    return this->Address_;
  }

  Node::Address_sequence& Node::
  Address ()
  {
    return this->Address_;
  }

  void Node::
  Address (const Address_sequence& s)
  {
    this->Address_ = s;
  }

  const Node::Location_optional& Node::
  Location () const
  {
    return this->Location_;
  }

  Node::Location_optional& Node::
  Location ()
  {
    return this->Location_;
  }

  void Node::
  Location (const Location_type& x)
  {
    this->Location_.set (x);
  }

  void Node::
  Location (const Location_optional& x)
  {
    this->Location_ = x;
  }

  void Node::
  Location (::std::auto_ptr< Location_type > x)
  {
    this->Location_.set (x);
  }

  const Node::DateTime_optional& Node::
  DateTime () const
  {
    return this->DateTime_;
  }

  Node::DateTime_optional& Node::
  DateTime ()
  {
    return this->DateTime_;
  }

  void Node::
  DateTime (const DateTime_type& x)
  {
    this->DateTime_.set (x);
  }

  void Node::
  DateTime (const DateTime_optional& x)
  {
    this->DateTime_ = x;
  }

  void Node::
  DateTime (::std::auto_ptr< DateTime_type > x)
  {
    this->DateTime_.set (x);
  }

  const Node::NodeRole_sequence& Node::
  NodeRole () const
  {
    return this->NodeRole_;
  }

  Node::NodeRole_sequence& Node::
  NodeRole ()
  {
    return this->NodeRole_;
  }

  void Node::
  NodeRole (const NodeRole_sequence& s)
  {
    this->NodeRole_ = s;
  }

  const Node::Counter_sequence& Node::
  Counter () const
  {
    return this->Counter_;
  }

  Node::Counter_sequence& Node::
  Counter ()
  {
    return this->Counter_;
  }

  void Node::
  Counter (const Counter_sequence& s)
  {
    this->Counter_ = s;
  }


  // Address
  // 

  const Address::category_type& Address::
  category () const
  {
    return this->category_.get ();
  }

  Address::category_type& Address::
  category ()
  {
    return this->category_.get ();
  }

  void Address::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void Address::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const Address::category_type& Address::
  category_default_value ()
  {
    return category_default_value_;
  }

  const Address::ext_category_optional& Address::
  ext_category () const
  {
    return this->ext_category_;
  }

  Address::ext_category_optional& Address::
  ext_category ()
  {
    return this->ext_category_;
  }

  void Address::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void Address::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void Address::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }

  const Address::vlan_name_optional& Address::
  vlan_name () const
  {
    return this->vlan_name_;
  }

  Address::vlan_name_optional& Address::
  vlan_name ()
  {
    return this->vlan_name_;
  }

  void Address::
  vlan_name (const vlan_name_type& x)
  {
    this->vlan_name_.set (x);
  }

  void Address::
  vlan_name (const vlan_name_optional& x)
  {
    this->vlan_name_ = x;
  }

  void Address::
  vlan_name (::std::auto_ptr< vlan_name_type > x)
  {
    this->vlan_name_.set (x);
  }

  const Address::vlan_num_optional& Address::
  vlan_num () const
  {
    return this->vlan_num_;
  }

  Address::vlan_num_optional& Address::
  vlan_num ()
  {
    return this->vlan_num_;
  }

  void Address::
  vlan_num (const vlan_num_type& x)
  {
    this->vlan_num_.set (x);
  }

  void Address::
  vlan_num (const vlan_num_optional& x)
  {
    this->vlan_num_ = x;
  }


  // NodeRole
  // 

  const NodeRole::category_type& NodeRole::
  category () const
  {
    return this->category_.get ();
  }

  NodeRole::category_type& NodeRole::
  category ()
  {
    return this->category_.get ();
  }

  void NodeRole::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void NodeRole::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const NodeRole::ext_category_optional& NodeRole::
  ext_category () const
  {
    return this->ext_category_;
  }

  NodeRole::ext_category_optional& NodeRole::
  ext_category ()
  {
    return this->ext_category_;
  }

  void NodeRole::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void NodeRole::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void NodeRole::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }


  // Service
  // 

  const Service::Port_optional& Service::
  Port () const
  {
    return this->Port_;
  }

  Service::Port_optional& Service::
  Port ()
  {
    return this->Port_;
  }

  void Service::
  Port (const Port_type& x)
  {
    this->Port_.set (x);
  }

  void Service::
  Port (const Port_optional& x)
  {
    this->Port_ = x;
  }

  const Service::Portlist_optional& Service::
  Portlist () const
  {
    return this->Portlist_;
  }

  Service::Portlist_optional& Service::
  Portlist ()
  {
    return this->Portlist_;
  }

  void Service::
  Portlist (const Portlist_type& x)
  {
    this->Portlist_.set (x);
  }

  void Service::
  Portlist (const Portlist_optional& x)
  {
    this->Portlist_ = x;
  }

  void Service::
  Portlist (::std::auto_ptr< Portlist_type > x)
  {
    this->Portlist_.set (x);
  }

  const Service::ProtoType_optional& Service::
  ProtoType () const
  {
    return this->ProtoType_;
  }

  Service::ProtoType_optional& Service::
  ProtoType ()
  {
    return this->ProtoType_;
  }

  void Service::
  ProtoType (const ProtoType_type& x)
  {
    this->ProtoType_.set (x);
  }

  void Service::
  ProtoType (const ProtoType_optional& x)
  {
    this->ProtoType_ = x;
  }

  const Service::ProtoCode_optional& Service::
  ProtoCode () const
  {
    return this->ProtoCode_;
  }

  Service::ProtoCode_optional& Service::
  ProtoCode ()
  {
    return this->ProtoCode_;
  }

  void Service::
  ProtoCode (const ProtoCode_type& x)
  {
    this->ProtoCode_.set (x);
  }

  void Service::
  ProtoCode (const ProtoCode_optional& x)
  {
    this->ProtoCode_ = x;
  }

  const Service::ProtoField_optional& Service::
  ProtoField () const
  {
    return this->ProtoField_;
  }

  Service::ProtoField_optional& Service::
  ProtoField ()
  {
    return this->ProtoField_;
  }

  void Service::
  ProtoField (const ProtoField_type& x)
  {
    this->ProtoField_.set (x);
  }

  void Service::
  ProtoField (const ProtoField_optional& x)
  {
    this->ProtoField_ = x;
  }

  const Service::Application_optional& Service::
  Application () const
  {
    return this->Application_;
  }

  Service::Application_optional& Service::
  Application ()
  {
    return this->Application_;
  }

  void Service::
  Application (const Application_type& x)
  {
    this->Application_.set (x);
  }

  void Service::
  Application (const Application_optional& x)
  {
    this->Application_ = x;
  }

  void Service::
  Application (::std::auto_ptr< Application_type > x)
  {
    this->Application_.set (x);
  }

  const Service::ip_protocol_type& Service::
  ip_protocol () const
  {
    return this->ip_protocol_.get ();
  }

  Service::ip_protocol_type& Service::
  ip_protocol ()
  {
    return this->ip_protocol_.get ();
  }

  void Service::
  ip_protocol (const ip_protocol_type& x)
  {
    this->ip_protocol_.set (x);
  }


  // Counter
  // 

  const Counter::type_type& Counter::
  type () const
  {
    return this->type_.get ();
  }

  Counter::type_type& Counter::
  type ()
  {
    return this->type_.get ();
  }

  void Counter::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Counter::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const Counter::ext_type_optional& Counter::
  ext_type () const
  {
    return this->ext_type_;
  }

  Counter::ext_type_optional& Counter::
  ext_type ()
  {
    return this->ext_type_;
  }

  void Counter::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void Counter::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void Counter::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const Counter::meaning_optional& Counter::
  meaning () const
  {
    return this->meaning_;
  }

  Counter::meaning_optional& Counter::
  meaning ()
  {
    return this->meaning_;
  }

  void Counter::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void Counter::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void Counter::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }

  const Counter::duration_optional& Counter::
  duration () const
  {
    return this->duration_;
  }

  Counter::duration_optional& Counter::
  duration ()
  {
    return this->duration_;
  }

  void Counter::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void Counter::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void Counter::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }

  const Counter::ext_duration_optional& Counter::
  ext_duration () const
  {
    return this->ext_duration_;
  }

  Counter::ext_duration_optional& Counter::
  ext_duration ()
  {
    return this->ext_duration_;
  }

  void Counter::
  ext_duration (const ext_duration_type& x)
  {
    this->ext_duration_.set (x);
  }

  void Counter::
  ext_duration (const ext_duration_optional& x)
  {
    this->ext_duration_ = x;
  }

  void Counter::
  ext_duration (::std::auto_ptr< ext_duration_type > x)
  {
    this->ext_duration_.set (x);
  }


  // Record
  // 

  const Record::RecordData_sequence& Record::
  RecordData () const
  {
    return this->RecordData_;
  }

  Record::RecordData_sequence& Record::
  RecordData ()
  {
    return this->RecordData_;
  }

  void Record::
  RecordData (const RecordData_sequence& s)
  {
    this->RecordData_ = s;
  }

  const Record::restriction_optional& Record::
  restriction () const
  {
    return this->restriction_;
  }

  Record::restriction_optional& Record::
  restriction ()
  {
    return this->restriction_;
  }

  void Record::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Record::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Record::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // RecordData
  // 

  const RecordData::DateTime_optional& RecordData::
  DateTime () const
  {
    return this->DateTime_;
  }

  RecordData::DateTime_optional& RecordData::
  DateTime ()
  {
    return this->DateTime_;
  }

  void RecordData::
  DateTime (const DateTime_type& x)
  {
    this->DateTime_.set (x);
  }

  void RecordData::
  DateTime (const DateTime_optional& x)
  {
    this->DateTime_ = x;
  }

  void RecordData::
  DateTime (::std::auto_ptr< DateTime_type > x)
  {
    this->DateTime_.set (x);
  }

  const RecordData::Description_sequence& RecordData::
  Description () const
  {
    return this->Description_;
  }

  RecordData::Description_sequence& RecordData::
  Description ()
  {
    return this->Description_;
  }

  void RecordData::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const RecordData::Application_optional& RecordData::
  Application () const
  {
    return this->Application_;
  }

  RecordData::Application_optional& RecordData::
  Application ()
  {
    return this->Application_;
  }

  void RecordData::
  Application (const Application_type& x)
  {
    this->Application_.set (x);
  }

  void RecordData::
  Application (const Application_optional& x)
  {
    this->Application_ = x;
  }

  void RecordData::
  Application (::std::auto_ptr< Application_type > x)
  {
    this->Application_.set (x);
  }

  const RecordData::RecordPattern_sequence& RecordData::
  RecordPattern () const
  {
    return this->RecordPattern_;
  }

  RecordData::RecordPattern_sequence& RecordData::
  RecordPattern ()
  {
    return this->RecordPattern_;
  }

  void RecordData::
  RecordPattern (const RecordPattern_sequence& s)
  {
    this->RecordPattern_ = s;
  }

  const RecordData::RecordItem_sequence& RecordData::
  RecordItem () const
  {
    return this->RecordItem_;
  }

  RecordData::RecordItem_sequence& RecordData::
  RecordItem ()
  {
    return this->RecordItem_;
  }

  void RecordData::
  RecordItem (const RecordItem_sequence& s)
  {
    this->RecordItem_ = s;
  }

  const RecordData::AdditionalData_sequence& RecordData::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  RecordData::AdditionalData_sequence& RecordData::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void RecordData::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const RecordData::restriction_optional& RecordData::
  restriction () const
  {
    return this->restriction_;
  }

  RecordData::restriction_optional& RecordData::
  restriction ()
  {
    return this->restriction_;
  }

  void RecordData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void RecordData::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void RecordData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // RecordPattern
  // 

  const RecordPattern::type_type& RecordPattern::
  type () const
  {
    return this->type_.get ();
  }

  RecordPattern::type_type& RecordPattern::
  type ()
  {
    return this->type_.get ();
  }

  void RecordPattern::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void RecordPattern::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const RecordPattern::ext_type_optional& RecordPattern::
  ext_type () const
  {
    return this->ext_type_;
  }

  RecordPattern::ext_type_optional& RecordPattern::
  ext_type ()
  {
    return this->ext_type_;
  }

  void RecordPattern::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void RecordPattern::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void RecordPattern::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const RecordPattern::offset_optional& RecordPattern::
  offset () const
  {
    return this->offset_;
  }

  RecordPattern::offset_optional& RecordPattern::
  offset ()
  {
    return this->offset_;
  }

  void RecordPattern::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void RecordPattern::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  const RecordPattern::offsetunit_type& RecordPattern::
  offsetunit () const
  {
    return this->offsetunit_.get ();
  }

  RecordPattern::offsetunit_type& RecordPattern::
  offsetunit ()
  {
    return this->offsetunit_.get ();
  }

  void RecordPattern::
  offsetunit (const offsetunit_type& x)
  {
    this->offsetunit_.set (x);
  }

  void RecordPattern::
  offsetunit (::std::auto_ptr< offsetunit_type > x)
  {
    this->offsetunit_.set (x);
  }

  const RecordPattern::offsetunit_type& RecordPattern::
  offsetunit_default_value ()
  {
    return offsetunit_default_value_;
  }

  const RecordPattern::ext_offsetunit_optional& RecordPattern::
  ext_offsetunit () const
  {
    return this->ext_offsetunit_;
  }

  RecordPattern::ext_offsetunit_optional& RecordPattern::
  ext_offsetunit ()
  {
    return this->ext_offsetunit_;
  }

  void RecordPattern::
  ext_offsetunit (const ext_offsetunit_type& x)
  {
    this->ext_offsetunit_.set (x);
  }

  void RecordPattern::
  ext_offsetunit (const ext_offsetunit_optional& x)
  {
    this->ext_offsetunit_ = x;
  }

  void RecordPattern::
  ext_offsetunit (::std::auto_ptr< ext_offsetunit_type > x)
  {
    this->ext_offsetunit_.set (x);
  }

  const RecordPattern::instance_optional& RecordPattern::
  instance () const
  {
    return this->instance_;
  }

  RecordPattern::instance_optional& RecordPattern::
  instance ()
  {
    return this->instance_;
  }

  void RecordPattern::
  instance (const instance_type& x)
  {
    this->instance_.set (x);
  }

  void RecordPattern::
  instance (const instance_optional& x)
  {
    this->instance_ = x;
  }


  // purpose
  // 

  purpose::
  purpose (value v)
  : ::xml_schema::nmtoken (_xsd_purpose_literals_[v])
  {
  }

  purpose::
  purpose (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  purpose::
  purpose (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  purpose::
  purpose (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  purpose::
  purpose (const purpose& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  purpose& purpose::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_purpose_literals_[v]);

    return *this;
  }


  // role
  // 

  role::
  role (value v)
  : ::xml_schema::nmtoken (_xsd_role_literals_[v])
  {
  }

  role::
  role (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  role::
  role (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  role::
  role (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  role::
  role (const role& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  role& role::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_role_literals_[v]);

    return *this;
  }


  // type
  // 

  type::
  type (value v)
  : ::xml_schema::nmtoken (_xsd_type_literals_[v])
  {
  }

  type::
  type (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type::
  type (const type& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type& type::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type_literals_[v]);

    return *this;
  }


  // registry
  // 

  registry::
  registry (value v)
  : ::xml_schema::nmtoken (_xsd_registry_literals_[v])
  {
  }

  registry::
  registry (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  registry::
  registry (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  registry::
  registry (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  registry::
  registry (const registry& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  registry& registry::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_registry_literals_[v]);

    return *this;
  }


  // occurrence
  // 

  occurrence::
  occurrence (value v)
  : ::xml_schema::nmtoken (_xsd_occurrence_literals_[v])
  {
  }

  occurrence::
  occurrence (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  occurrence::
  occurrence (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  occurrence::
  occurrence (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  occurrence::
  occurrence (const occurrence& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  occurrence& occurrence::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_occurrence_literals_[v]);

    return *this;
  }


  // completion
  // 

  completion::
  completion (value v)
  : ::xml_schema::nmtoken (_xsd_completion_literals_[v])
  {
  }

  completion::
  completion (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  completion::
  completion (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  completion::
  completion (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  completion::
  completion (const completion& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  completion& completion::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_completion_literals_[v]);

    return *this;
  }


  // type1
  // 

  type1::
  type1 (value v)
  : ::xml_schema::nmtoken (_xsd_type1_literals_[v])
  {
  }

  type1::
  type1 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type1::
  type1 (const type1& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type1& type1::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type1_literals_[v]);

    return *this;
  }


  // metric
  // 

  metric::
  metric (value v)
  : ::xml_schema::nmtoken (_xsd_metric_literals_[v])
  {
  }

  metric::
  metric (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  metric::
  metric (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  metric::
  metric (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  metric::
  metric (const metric& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  metric& metric::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_metric_literals_[v]);

    return *this;
  }


  // rating
  // 

  rating::
  rating (value v)
  : ::xml_schema::nmtoken (_xsd_rating_literals_[v])
  {
  }

  rating::
  rating (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  rating::
  rating (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  rating::
  rating (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  rating::
  rating (const rating& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  rating& rating::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_rating_literals_[v]);

    return *this;
  }


  // category
  // 

  category::
  category (value v)
  : ::xml_schema::nmtoken (_xsd_category_literals_[v])
  {
  }

  category::
  category (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category::
  category (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category::
  category (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category::
  category (const category& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  category& category::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_category_literals_[v]);

    return *this;
  }


  // spoofed
  // 

  spoofed::
  spoofed (value v)
  : ::xml_schema::nmtoken (_xsd_spoofed_literals_[v])
  {
  }

  spoofed::
  spoofed (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  spoofed::
  spoofed (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  spoofed::
  spoofed (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  spoofed::
  spoofed (const spoofed& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  spoofed& spoofed::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_spoofed_literals_[v]);

    return *this;
  }


  // category1
  // 

  category1::
  category1 (value v)
  : ::xml_schema::nmtoken (_xsd_category1_literals_[v])
  {
  }

  category1::
  category1 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category1::
  category1 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category1::
  category1 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category1::
  category1 (const category1& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  category1& category1::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_category1_literals_[v]);

    return *this;
  }


  // category2
  // 

  category2::
  category2 (value v)
  : ::xml_schema::nmtoken (_xsd_category2_literals_[v])
  {
  }

  category2::
  category2 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category2::
  category2 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category2::
  category2 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  category2::
  category2 (const category2& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  category2& category2::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_category2_literals_[v]);

    return *this;
  }


  // type2
  // 

  type2::
  type2 (value v)
  : ::xml_schema::nmtoken (_xsd_type2_literals_[v])
  {
  }

  type2::
  type2 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type2::
  type2 (const type2& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type2& type2::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type2_literals_[v]);

    return *this;
  }


  // type3
  // 

  type3::
  type3 (value v)
  : ::xml_schema::nmtoken (_xsd_type3_literals_[v])
  {
  }

  type3::
  type3 (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  type3::
  type3 (const type3& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type3& type3::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type3_literals_[v]);

    return *this;
  }


  // offsetunit
  // 

  offsetunit::
  offsetunit (value v)
  : ::xml_schema::nmtoken (_xsd_offsetunit_literals_[v])
  {
  }

  offsetunit::
  offsetunit (const char* v)
  : ::xml_schema::nmtoken (v)
  {
  }

  offsetunit::
  offsetunit (const ::std::string& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  offsetunit::
  offsetunit (const ::xml_schema::nmtoken& v)
  : ::xml_schema::nmtoken (v)
  {
  }

  offsetunit::
  offsetunit (const offsetunit& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  offsetunit& offsetunit::
  operator= (value v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_offsetunit_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace iodef_1_0
{
  // IncidentIDType
  //

  const IncidentIDType::restriction_type IncidentIDType::restriction_default_value_ (
    "public");

  IncidentIDType::
  IncidentIDType (const name_type& name)
  : ::xml_schema::string (),
    name_ (name, ::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this)
  {
  }

  IncidentIDType::
  IncidentIDType (const char* _xsd_string_base,
                  const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, ::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this)
  {
  }

  IncidentIDType::
  IncidentIDType (const ::std::string& _xsd_string_base,
                  const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, ::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this)
  {
  }

  IncidentIDType::
  IncidentIDType (const ::xml_schema::string& _xsd_string_base,
                  const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, ::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this)
  {
  }

  IncidentIDType::
  IncidentIDType (const IncidentIDType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    name_ (x.name_, f, this),
    instance_ (x.instance_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  IncidentIDType::
  IncidentIDType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    instance_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void IncidentIDType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "instance" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< instance_type > r (
          instance_traits::create (i, f, this));

        this->instance_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }
  }

  IncidentIDType* IncidentIDType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IncidentIDType (*this, f, c);
  }

  IncidentIDType::
  ~IncidentIDType ()
  {
  }

  // ContactMeansType
  //

  ContactMeansType::
  ContactMeansType ()
  : ::xml_schema::string (),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  ContactMeansType::
  ContactMeansType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  ContactMeansType::
  ContactMeansType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  ContactMeansType::
  ContactMeansType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  ContactMeansType::
  ContactMeansType (const ContactMeansType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    meaning_ (x.meaning_, f, this)
  {
  }

  ContactMeansType::
  ContactMeansType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    meaning_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ContactMeansType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }
    }
  }

  ContactMeansType* ContactMeansType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContactMeansType (*this, f, c);
  }

  ContactMeansType::
  ~ContactMeansType ()
  {
  }

  // TimezoneType
  //

  TimezoneType::
  TimezoneType ()
  : ::xml_schema::string ()
  {
  }

  TimezoneType::
  TimezoneType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  TimezoneType::
  TimezoneType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  TimezoneType::
  TimezoneType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  TimezoneType::
  TimezoneType (const TimezoneType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  TimezoneType::
  TimezoneType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  TimezoneType::
  TimezoneType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  TimezoneType::
  TimezoneType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  TimezoneType* TimezoneType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimezoneType (*this, f, c);
  }

  TimezoneType::
  ~TimezoneType ()
  {
  }

  // PortlistType
  //

  PortlistType::
  PortlistType ()
  : ::xml_schema::string ()
  {
  }

  PortlistType::
  PortlistType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PortlistType::
  PortlistType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PortlistType::
  PortlistType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PortlistType::
  PortlistType (const PortlistType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  PortlistType::
  PortlistType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  PortlistType::
  PortlistType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  PortlistType::
  PortlistType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  PortlistType* PortlistType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PortlistType (*this, f, c);
  }

  PortlistType::
  ~PortlistType ()
  {
  }

  // SoftwareType
  //

  const SoftwareType::swid_type SoftwareType::swid_default_value_ (
    "0");

  const SoftwareType::configid_type SoftwareType::configid_default_value_ (
    "0");

  SoftwareType::
  SoftwareType ()
  : ::xml_schema::type (),
    URL_ (::xml_schema::flags (), this),
    swid_ (swid_default_value (), ::xml_schema::flags (), this),
    configid_ (configid_default_value (), ::xml_schema::flags (), this),
    vendor_ (::xml_schema::flags (), this),
    family_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this),
    patch_ (::xml_schema::flags (), this)
  {
  }

  SoftwareType::
  SoftwareType (const SoftwareType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    URL_ (x.URL_, f, this),
    swid_ (x.swid_, f, this),
    configid_ (x.configid_, f, this),
    vendor_ (x.vendor_, f, this),
    family_ (x.family_, f, this),
    name_ (x.name_, f, this),
    version_ (x.version_, f, this),
    patch_ (x.patch_, f, this)
  {
  }

  SoftwareType::
  SoftwareType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    URL_ (f, this),
    swid_ (f, this),
    configid_ (f, this),
    vendor_ (f, this),
    family_ (f, this),
    name_ (f, this),
    version_ (f, this),
    patch_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SoftwareType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        if (!this->URL_)
        {
          this->URL_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "swid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< swid_type > r (
          swid_traits::create (i, f, this));

        this->swid_.set (r);
        continue;
      }

      if (n.name () == "configid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< configid_type > r (
          configid_traits::create (i, f, this));

        this->configid_.set (r);
        continue;
      }

      if (n.name () == "vendor" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vendor_type > r (
          vendor_traits::create (i, f, this));

        this->vendor_.set (r);
        continue;
      }

      if (n.name () == "family" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< family_type > r (
          family_traits::create (i, f, this));

        this->family_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }

      if (n.name () == "patch" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< patch_type > r (
          patch_traits::create (i, f, this));

        this->patch_.set (r);
        continue;
      }
    }

    if (!swid_.present ())
    {
      this->swid_.set (swid_default_value ());
    }

    if (!configid_.present ())
    {
      this->configid_.set (configid_default_value ());
    }
  }

  SoftwareType* SoftwareType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SoftwareType (*this, f, c);
  }

  SoftwareType::
  ~SoftwareType ()
  {
  }

  // PositiveFloatType
  //

  PositiveFloatType::
  PositiveFloatType (const ::xml_schema::float_& _xsd_float__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base)
  {
  }

  PositiveFloatType::
  PositiveFloatType (const PositiveFloatType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  PositiveFloatType::
  PositiveFloatType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  PositiveFloatType::
  PositiveFloatType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  PositiveFloatType::
  PositiveFloatType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  PositiveFloatType* PositiveFloatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PositiveFloatType (*this, f, c);
  }

  PositiveFloatType::
  ~PositiveFloatType ()
  {
  }

  // MLStringType
  //

  MLStringType::
  MLStringType ()
  : ::xml_schema::string (),
    lang_ (::xml_schema::flags (), this)
  {
  }

  MLStringType::
  MLStringType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  MLStringType::
  MLStringType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  MLStringType::
  MLStringType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  MLStringType::
  MLStringType (const MLStringType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    lang_ (x.lang_, f, this)
  {
  }

  MLStringType::
  MLStringType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MLStringType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  MLStringType* MLStringType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MLStringType (*this, f, c);
  }

  MLStringType::
  ~MLStringType ()
  {
  }

  // ExtensionType
  //

  ExtensionType::
  ExtensionType (const dtype_type& dtype)
  : ::xml_schema::type (),
    dtype_ (dtype, ::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  ExtensionType::
  ExtensionType (const ExtensionType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dtype_ (x.dtype_, f, this),
    ext_dtype_ (x.ext_dtype_, f, this),
    meaning_ (x.meaning_, f, this),
    formatid_ (x.formatid_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  ExtensionType::
  ExtensionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dtype_ (f, this),
    ext_dtype_ (f, this),
    meaning_ (f, this),
    formatid_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ExtensionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dtype_type > r (
          dtype_traits::create (i, f, this));

        this->dtype_.set (r);
        continue;
      }

      if (n.name () == "ext-dtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_dtype_type > r (
          ext_dtype_traits::create (i, f, this));

        this->ext_dtype_.set (r);
        continue;
      }

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }

      if (n.name () == "formatid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatid_type > r (
          formatid_traits::create (i, f, this));

        this->formatid_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }

    if (!dtype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dtype",
        "");
    }
  }

  ExtensionType* ExtensionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ExtensionType (*this, f, c);
  }

  ExtensionType::
  ~ExtensionType ()
  {
  }

  // restriction_type
  //

  restriction_type::
  restriction_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_restriction_type_convert ();
  }

  restriction_type::
  restriction_type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_restriction_type_convert ();
  }

  restriction_type::
  restriction_type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_restriction_type_convert ();
  }

  restriction_type* restriction_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class restriction_type (*this, f, c);
  }

  restriction_type::value restriction_type::
  _xsd_restriction_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_restriction_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_restriction_type_indexes_,
                      _xsd_restriction_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_restriction_type_indexes_ + 4 || _xsd_restriction_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const restriction_type::
  _xsd_restriction_type_literals_[4] =
  {
    "default",
    "public",
    "need-to-know",
    "private"
  };

  const restriction_type::value restriction_type::
  _xsd_restriction_type_indexes_[4] =
  {
    ::iodef_1_0::restriction_type::default_,
    ::iodef_1_0::restriction_type::need_to_know,
    ::iodef_1_0::restriction_type::private_,
    ::iodef_1_0::restriction_type::public_
  };

  // severity_type
  //

  severity_type::
  severity_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_severity_type_convert ();
  }

  severity_type::
  severity_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_severity_type_convert ();
  }

  severity_type::
  severity_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_severity_type_convert ();
  }

  severity_type* severity_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class severity_type (*this, f, c);
  }

  severity_type::value severity_type::
  _xsd_severity_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_severity_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_severity_type_indexes_,
                      _xsd_severity_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_severity_type_indexes_ + 3 || _xsd_severity_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const severity_type::
  _xsd_severity_type_literals_[3] =
  {
    "low",
    "medium",
    "high"
  };

  const severity_type::value severity_type::
  _xsd_severity_type_indexes_[3] =
  {
    ::iodef_1_0::severity_type::high,
    ::iodef_1_0::severity_type::low,
    ::iodef_1_0::severity_type::medium
  };

  // duration_type
  //

  duration_type::
  duration_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_duration_type_convert ();
  }

  duration_type::
  duration_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_duration_type_convert ();
  }

  duration_type::
  duration_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_duration_type_convert ();
  }

  duration_type* duration_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class duration_type (*this, f, c);
  }

  duration_type::value duration_type::
  _xsd_duration_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_duration_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_duration_type_indexes_,
                      _xsd_duration_type_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_duration_type_indexes_ + 8 || _xsd_duration_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const duration_type::
  _xsd_duration_type_literals_[8] =
  {
    "second",
    "minute",
    "hour",
    "day",
    "month",
    "quarter",
    "year",
    "ext-value"
  };

  const duration_type::value duration_type::
  _xsd_duration_type_indexes_[8] =
  {
    ::iodef_1_0::duration_type::day,
    ::iodef_1_0::duration_type::ext_value,
    ::iodef_1_0::duration_type::hour,
    ::iodef_1_0::duration_type::minute,
    ::iodef_1_0::duration_type::month,
    ::iodef_1_0::duration_type::quarter,
    ::iodef_1_0::duration_type::second,
    ::iodef_1_0::duration_type::year
  };

  // action_type
  //

  action_type::
  action_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_action_type_convert ();
  }

  action_type::
  action_type (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_action_type_convert ();
  }

  action_type::
  action_type (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_action_type_convert ();
  }

  action_type* action_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class action_type (*this, f, c);
  }

  action_type::value action_type::
  _xsd_action_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_action_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_action_type_indexes_,
                      _xsd_action_type_indexes_ + 16,
                      *this,
                      c));

    if (i == _xsd_action_type_indexes_ + 16 || _xsd_action_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const action_type::
  _xsd_action_type_literals_[16] =
  {
    "nothing",
    "contact-source-site",
    "contact-target-site",
    "contact-sender",
    "investigate",
    "block-host",
    "block-network",
    "block-port",
    "rate-limit-host",
    "rate-limit-network",
    "rate-limit-port",
    "remediate-other",
    "status-triage",
    "status-new-info",
    "other",
    "ext-value"
  };

  const action_type::value action_type::
  _xsd_action_type_indexes_[16] =
  {
    ::iodef_1_0::action_type::block_host,
    ::iodef_1_0::action_type::block_network,
    ::iodef_1_0::action_type::block_port,
    ::iodef_1_0::action_type::contact_sender,
    ::iodef_1_0::action_type::contact_source_site,
    ::iodef_1_0::action_type::contact_target_site,
    ::iodef_1_0::action_type::ext_value,
    ::iodef_1_0::action_type::investigate,
    ::iodef_1_0::action_type::nothing,
    ::iodef_1_0::action_type::other,
    ::iodef_1_0::action_type::rate_limit_host,
    ::iodef_1_0::action_type::rate_limit_network,
    ::iodef_1_0::action_type::rate_limit_port,
    ::iodef_1_0::action_type::remediate_other,
    ::iodef_1_0::action_type::status_new_info,
    ::iodef_1_0::action_type::status_triage
  };

  // dtype_type
  //

  dtype_type::
  dtype_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_dtype_type_convert ();
  }

  dtype_type::
  dtype_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_dtype_type_convert ();
  }

  dtype_type::
  dtype_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_dtype_type_convert ();
  }

  dtype_type* dtype_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dtype_type (*this, f, c);
  }

  dtype_type::value dtype_type::
  _xsd_dtype_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dtype_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_dtype_type_indexes_,
                      _xsd_dtype_type_indexes_ + 20,
                      *this,
                      c));

    if (i == _xsd_dtype_type_indexes_ + 20 || _xsd_dtype_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const dtype_type::
  _xsd_dtype_type_literals_[20] =
  {
    "boolean",
    "byte",
    "character",
    "date-time",
    "integer",
    "ntpstamp",
    "portlist",
    "real",
    "string",
    "file",
    "path",
    "frame",
    "packet",
    "ipv4-packet",
    "ipv6-packet",
    "url",
    "csv",
    "winreg",
    "xml",
    "ext-value"
  };

  const dtype_type::value dtype_type::
  _xsd_dtype_type_indexes_[20] =
  {
    ::iodef_1_0::dtype_type::boolean,
    ::iodef_1_0::dtype_type::byte,
    ::iodef_1_0::dtype_type::character,
    ::iodef_1_0::dtype_type::csv,
    ::iodef_1_0::dtype_type::date_time,
    ::iodef_1_0::dtype_type::ext_value,
    ::iodef_1_0::dtype_type::file,
    ::iodef_1_0::dtype_type::frame,
    ::iodef_1_0::dtype_type::integer,
    ::iodef_1_0::dtype_type::ipv4_packet,
    ::iodef_1_0::dtype_type::ipv6_packet,
    ::iodef_1_0::dtype_type::ntpstamp,
    ::iodef_1_0::dtype_type::packet,
    ::iodef_1_0::dtype_type::path,
    ::iodef_1_0::dtype_type::portlist,
    ::iodef_1_0::dtype_type::real,
    ::iodef_1_0::dtype_type::string,
    ::iodef_1_0::dtype_type::url,
    ::iodef_1_0::dtype_type::winreg,
    ::iodef_1_0::dtype_type::xml
  };

  // IODEF_Document
  //

  const IODEF_Document::version_type IODEF_Document::version_default_value_ (
    "1.00");

  IODEF_Document::
  IODEF_Document (const lang_type& lang)
  : ::xml_schema::type (),
    Incident_ (::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this),
    lang_ (lang, ::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this)
  {
  }

  IODEF_Document::
  IODEF_Document (const IODEF_Document& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Incident_ (x.Incident_, f, this),
    version_ (x.version_, f, this),
    lang_ (x.lang_, f, this),
    formatid_ (x.formatid_, f, this)
  {
  }

  IODEF_Document::
  IODEF_Document (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Incident_ (f, this),
    version_ (f, this),
    lang_ (f, this),
    formatid_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void IODEF_Document::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Incident
      //
      if (n.name () == "Incident" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Incident_type > r (
          Incident_traits::create (i, f, this));

        this->Incident_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }

      if (n.name () == "formatid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatid_type > r (
          formatid_traits::create (i, f, this));

        this->formatid_.set (r);
        continue;
      }
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }

    if (!lang_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lang",
        "");
    }
  }

  IODEF_Document* IODEF_Document::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IODEF_Document (*this, f, c);
  }

  IODEF_Document::
  ~IODEF_Document ()
  {
  }

  // Incident
  //

  const Incident::restriction_type Incident::restriction_default_value_ (
    "private");

  Incident::
  Incident (const IncidentID_type& IncidentID,
            const ReportTime_type& ReportTime,
            const purpose_type& purpose)
  : ::xml_schema::type (),
    IncidentID_ (IncidentID, ::xml_schema::flags (), this),
    AlternativeID_ (::xml_schema::flags (), this),
    RelatedActivity_ (::xml_schema::flags (), this),
    DetectTime_ (::xml_schema::flags (), this),
    StartTime_ (::xml_schema::flags (), this),
    EndTime_ (::xml_schema::flags (), this),
    ReportTime_ (ReportTime, ::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    Assessment_ (::xml_schema::flags (), this),
    Method_ (::xml_schema::flags (), this),
    Contact_ (::xml_schema::flags (), this),
    EventData_ (::xml_schema::flags (), this),
    History_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    purpose_ (purpose, ::xml_schema::flags (), this),
    ext_purpose_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this)
  {
  }

  Incident::
  Incident (::std::auto_ptr< IncidentID_type >& IncidentID,
            const ReportTime_type& ReportTime,
            const purpose_type& purpose)
  : ::xml_schema::type (),
    IncidentID_ (IncidentID, ::xml_schema::flags (), this),
    AlternativeID_ (::xml_schema::flags (), this),
    RelatedActivity_ (::xml_schema::flags (), this),
    DetectTime_ (::xml_schema::flags (), this),
    StartTime_ (::xml_schema::flags (), this),
    EndTime_ (::xml_schema::flags (), this),
    ReportTime_ (ReportTime, ::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    Assessment_ (::xml_schema::flags (), this),
    Method_ (::xml_schema::flags (), this),
    Contact_ (::xml_schema::flags (), this),
    EventData_ (::xml_schema::flags (), this),
    History_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    purpose_ (purpose, ::xml_schema::flags (), this),
    ext_purpose_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this)
  {
  }

  Incident::
  Incident (const Incident& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    AlternativeID_ (x.AlternativeID_, f, this),
    RelatedActivity_ (x.RelatedActivity_, f, this),
    DetectTime_ (x.DetectTime_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    ReportTime_ (x.ReportTime_, f, this),
    Description_ (x.Description_, f, this),
    Assessment_ (x.Assessment_, f, this),
    Method_ (x.Method_, f, this),
    Contact_ (x.Contact_, f, this),
    EventData_ (x.EventData_, f, this),
    History_ (x.History_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    purpose_ (x.purpose_, f, this),
    ext_purpose_ (x.ext_purpose_, f, this),
    lang_ (x.lang_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Incident::
  Incident (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (f, this),
    AlternativeID_ (f, this),
    RelatedActivity_ (f, this),
    DetectTime_ (f, this),
    StartTime_ (f, this),
    EndTime_ (f, this),
    ReportTime_ (f, this),
    Description_ (f, this),
    Assessment_ (f, this),
    Method_ (f, this),
    Contact_ (f, this),
    EventData_ (f, this),
    History_ (f, this),
    AdditionalData_ (f, this),
    purpose_ (f, this),
    ext_purpose_ (f, this),
    lang_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Incident::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        if (!IncidentID_.present ())
        {
          this->IncidentID_.set (r);
          continue;
        }
      }

      // AlternativeID
      //
      if (n.name () == "AlternativeID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AlternativeID_type > r (
          AlternativeID_traits::create (i, f, this));

        if (!this->AlternativeID_)
        {
          this->AlternativeID_.set (r);
          continue;
        }
      }

      // RelatedActivity
      //
      if (n.name () == "RelatedActivity" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RelatedActivity_type > r (
          RelatedActivity_traits::create (i, f, this));

        if (!this->RelatedActivity_)
        {
          this->RelatedActivity_.set (r);
          continue;
        }
      }

      // DetectTime
      //
      if (n.name () == "DetectTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DetectTime_type > r (
          DetectTime_traits::create (i, f, this));

        if (!this->DetectTime_)
        {
          this->DetectTime_.set (r);
          continue;
        }
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // ReportTime
      //
      if (n.name () == "ReportTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ReportTime_type > r (
          ReportTime_traits::create (i, f, this));

        if (!ReportTime_.present ())
        {
          this->ReportTime_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // Assessment
      //
      if (n.name () == "Assessment" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Assessment_type > r (
          Assessment_traits::create (i, f, this));

        this->Assessment_.push_back (r);
        continue;
      }

      // Method
      //
      if (n.name () == "Method" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Method_type > r (
          Method_traits::create (i, f, this));

        this->Method_.push_back (r);
        continue;
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        this->Contact_.push_back (r);
        continue;
      }

      // EventData
      //
      if (n.name () == "EventData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EventData_type > r (
          EventData_traits::create (i, f, this));

        this->EventData_.push_back (r);
        continue;
      }

      // History
      //
      if (n.name () == "History" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< History_type > r (
          History_traits::create (i, f, this));

        if (!this->History_)
        {
          this->History_.set (r);
          continue;
        }
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    if (!IncidentID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IncidentID",
        "urn:ietf:params:xml:ns:iodef-1.0");
    }

    if (!ReportTime_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ReportTime",
        "urn:ietf:params:xml:ns:iodef-1.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "purpose" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        this->purpose_.set (r);
        continue;
      }

      if (n.name () == "ext-purpose" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_purpose_type > r (
          ext_purpose_traits::create (i, f, this));

        this->ext_purpose_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }

    if (!purpose_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "purpose",
        "");
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }
  }

  Incident* Incident::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Incident (*this, f, c);
  }

  Incident::
  ~Incident ()
  {
  }

  // AlternativeID
  //

  AlternativeID::
  AlternativeID ()
  : ::xml_schema::type (),
    IncidentID_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  AlternativeID::
  AlternativeID (const AlternativeID& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  AlternativeID::
  AlternativeID (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void AlternativeID::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        this->IncidentID_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  AlternativeID* AlternativeID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlternativeID (*this, f, c);
  }

  AlternativeID::
  ~AlternativeID ()
  {
  }

  // RelatedActivity
  //

  RelatedActivity::
  RelatedActivity ()
  : ::xml_schema::type (),
    IncidentID_ (::xml_schema::flags (), this),
    URL_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  RelatedActivity::
  RelatedActivity (const RelatedActivity& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    URL_ (x.URL_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  RelatedActivity::
  RelatedActivity (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (f, this),
    URL_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RelatedActivity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        this->IncidentID_.push_back (r);
        continue;
      }

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        this->URL_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  RelatedActivity* RelatedActivity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RelatedActivity (*this, f, c);
  }

  RelatedActivity::
  ~RelatedActivity ()
  {
  }

  // Contact
  //

  Contact::
  Contact (const role_type& role,
           const type_type& type)
  : ::xml_schema::type (),
    ContactName_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    RegistryHandle_ (::xml_schema::flags (), this),
    PostalAddress_ (::xml_schema::flags (), this),
    Email_ (::xml_schema::flags (), this),
    Telephone_ (::xml_schema::flags (), this),
    Fax_ (::xml_schema::flags (), this),
    Timezone_ (::xml_schema::flags (), this),
    Contact1_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    role_ (role, ::xml_schema::flags (), this),
    ext_role_ (::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Contact::
  Contact (const Contact& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ContactName_ (x.ContactName_, f, this),
    Description_ (x.Description_, f, this),
    RegistryHandle_ (x.RegistryHandle_, f, this),
    PostalAddress_ (x.PostalAddress_, f, this),
    Email_ (x.Email_, f, this),
    Telephone_ (x.Telephone_, f, this),
    Fax_ (x.Fax_, f, this),
    Timezone_ (x.Timezone_, f, this),
    Contact1_ (x.Contact1_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    role_ (x.role_, f, this),
    ext_role_ (x.ext_role_, f, this),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Contact::
  Contact (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ContactName_ (f, this),
    Description_ (f, this),
    RegistryHandle_ (f, this),
    PostalAddress_ (f, this),
    Email_ (f, this),
    Telephone_ (f, this),
    Fax_ (f, this),
    Timezone_ (f, this),
    Contact1_ (f, this),
    AdditionalData_ (f, this),
    role_ (f, this),
    ext_role_ (f, this),
    type_ (f, this),
    ext_type_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Contact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContactName
      //
      if (n.name () == "ContactName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ContactName_type > r (
          ContactName_traits::create (i, f, this));

        if (!this->ContactName_)
        {
          this->ContactName_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // RegistryHandle
      //
      if (n.name () == "RegistryHandle" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RegistryHandle_type > r (
          RegistryHandle_traits::create (i, f, this));

        this->RegistryHandle_.push_back (r);
        continue;
      }

      // PostalAddress
      //
      if (n.name () == "PostalAddress" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< PostalAddress_type > r (
          PostalAddress_traits::create (i, f, this));

        if (!this->PostalAddress_)
        {
          this->PostalAddress_.set (r);
          continue;
        }
      }

      // Email
      //
      if (n.name () == "Email" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Email_type > r (
          Email_traits::create (i, f, this));

        this->Email_.push_back (r);
        continue;
      }

      // Telephone
      //
      if (n.name () == "Telephone" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Telephone_type > r (
          Telephone_traits::create (i, f, this));

        this->Telephone_.push_back (r);
        continue;
      }

      // Fax
      //
      if (n.name () == "Fax" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Fax_type > r (
          Fax_traits::create (i, f, this));

        if (!this->Fax_)
        {
          this->Fax_.set (r);
          continue;
        }
      }

      // Timezone
      //
      if (n.name () == "Timezone" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Timezone_type > r (
          Timezone_traits::create (i, f, this));

        if (!this->Timezone_)
        {
          this->Timezone_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Contact1_type > r (
          Contact1_traits::create (i, f, this));

        this->Contact1_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "role" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< role_type > r (
          role_traits::create (i, f, this));

        this->role_.set (r);
        continue;
      }

      if (n.name () == "ext-role" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_role_type > r (
          ext_role_traits::create (i, f, this));

        this->ext_role_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_type_type > r (
          ext_type_traits::create (i, f, this));

        this->ext_type_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }

    if (!role_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "role",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  Contact* Contact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Contact (*this, f, c);
  }

  Contact::
  ~Contact ()
  {
  }

  // RegistryHandle
  //

  RegistryHandle::
  RegistryHandle ()
  : ::xml_schema::string (),
    registry_ (::xml_schema::flags (), this),
    ext_registry_ (::xml_schema::flags (), this)
  {
  }

  RegistryHandle::
  RegistryHandle (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (::xml_schema::flags (), this),
    ext_registry_ (::xml_schema::flags (), this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (::xml_schema::flags (), this),
    ext_registry_ (::xml_schema::flags (), this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (::xml_schema::flags (), this),
    ext_registry_ (::xml_schema::flags (), this)
  {
  }

  RegistryHandle::
  RegistryHandle (const RegistryHandle& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    registry_ (x.registry_, f, this),
    ext_registry_ (x.ext_registry_, f, this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    registry_ (f, this),
    ext_registry_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void RegistryHandle::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "registry" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< registry_type > r (
          registry_traits::create (i, f, this));

        this->registry_.set (r);
        continue;
      }

      if (n.name () == "ext-registry" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_registry_type > r (
          ext_registry_traits::create (i, f, this));

        this->ext_registry_.set (r);
        continue;
      }
    }
  }

  RegistryHandle* RegistryHandle::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RegistryHandle (*this, f, c);
  }

  RegistryHandle::
  ~RegistryHandle ()
  {
  }

  // PostalAddress
  //

  PostalAddress::
  PostalAddress ()
  : ::iodef_1_0::MLStringType (),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  PostalAddress::
  PostalAddress (const char* _xsd_string_base)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  PostalAddress::
  PostalAddress (const ::std::string& _xsd_string_base)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  PostalAddress::
  PostalAddress (const ::xml_schema::string& _xsd_string_base)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  PostalAddress::
  PostalAddress (const PostalAddress& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::iodef_1_0::MLStringType (x, f, c),
    meaning_ (x.meaning_, f, this)
  {
  }

  PostalAddress::
  PostalAddress (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::iodef_1_0::MLStringType (e, f | ::xml_schema::flags::base, c),
    meaning_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void PostalAddress::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::iodef_1_0::MLStringType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }
    }
  }

  PostalAddress* PostalAddress::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PostalAddress (*this, f, c);
  }

  PostalAddress::
  ~PostalAddress ()
  {
  }

  // History
  //

  const History::restriction_type History::restriction_default_value_ (
    "default");

  History::
  History ()
  : ::xml_schema::type (),
    HistoryItem_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this)
  {
  }

  History::
  History (const History& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    HistoryItem_ (x.HistoryItem_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  History::
  History (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    HistoryItem_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void History::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HistoryItem
      //
      if (n.name () == "HistoryItem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< HistoryItem_type > r (
          HistoryItem_traits::create (i, f, this));

        this->HistoryItem_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }
  }

  History* History::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class History (*this, f, c);
  }

  History::
  ~History ()
  {
  }

  // HistoryItem
  //

  HistoryItem::
  HistoryItem (const DateTime_type& DateTime,
               const action_type& action)
  : ::xml_schema::type (),
    DateTime_ (DateTime, ::xml_schema::flags (), this),
    IncidentID_ (::xml_schema::flags (), this),
    Contact_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this),
    action_ (action, ::xml_schema::flags (), this),
    ext_action_ (::xml_schema::flags (), this)
  {
  }

  HistoryItem::
  HistoryItem (const HistoryItem& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DateTime_ (x.DateTime_, f, this),
    IncidentID_ (x.IncidentID_, f, this),
    Contact_ (x.Contact_, f, this),
    Description_ (x.Description_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    action_ (x.action_, f, this),
    ext_action_ (x.ext_action_, f, this)
  {
  }

  HistoryItem::
  HistoryItem (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DateTime_ (f, this),
    IncidentID_ (f, this),
    Contact_ (f, this),
    Description_ (f, this),
    AdditionalData_ (f, this),
    restriction_ (f, this),
    action_ (f, this),
    ext_action_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void HistoryItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DateTime
      //
      if (n.name () == "DateTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DateTime_type > r (
          DateTime_traits::create (i, f, this));

        if (!DateTime_.present ())
        {
          this->DateTime_.set (r);
          continue;
        }
      }

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        if (!this->IncidentID_)
        {
          this->IncidentID_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        if (!this->Contact_)
        {
          this->Contact_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    if (!DateTime_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DateTime",
        "urn:ietf:params:xml:ns:iodef-1.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }

      if (n.name () == "action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< action_type > r (
          action_traits::create (i, f, this));

        this->action_.set (r);
        continue;
      }

      if (n.name () == "ext-action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_action_type > r (
          ext_action_traits::create (i, f, this));

        this->ext_action_.set (r);
        continue;
      }
    }

    if (!action_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "action",
        "");
    }
  }

  HistoryItem* HistoryItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HistoryItem (*this, f, c);
  }

  HistoryItem::
  ~HistoryItem ()
  {
  }

  // Expectation
  //

  const Expectation::restriction_type Expectation::restriction_default_value_ (
    "default");

  const Expectation::action_type Expectation::action_default_value_ (
    "other");

  Expectation::
  Expectation ()
  : ::xml_schema::type (),
    Description_ (::xml_schema::flags (), this),
    StartTime_ (::xml_schema::flags (), this),
    EndTime_ (::xml_schema::flags (), this),
    Contact_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this),
    severity_ (::xml_schema::flags (), this),
    action_ (action_default_value (), ::xml_schema::flags (), this),
    ext_action_ (::xml_schema::flags (), this)
  {
  }

  Expectation::
  Expectation (const Expectation& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Description_ (x.Description_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    Contact_ (x.Contact_, f, this),
    restriction_ (x.restriction_, f, this),
    severity_ (x.severity_, f, this),
    action_ (x.action_, f, this),
    ext_action_ (x.ext_action_, f, this)
  {
  }

  Expectation::
  Expectation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Description_ (f, this),
    StartTime_ (f, this),
    EndTime_ (f, this),
    Contact_ (f, this),
    restriction_ (f, this),
    severity_ (f, this),
    action_ (f, this),
    ext_action_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Expectation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        if (!this->Contact_)
        {
          this->Contact_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< severity_type > r (
          severity_traits::create (i, f, this));

        this->severity_.set (r);
        continue;
      }

      if (n.name () == "action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< action_type > r (
          action_traits::create (i, f, this));

        this->action_.set (r);
        continue;
      }

      if (n.name () == "ext-action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_action_type > r (
          ext_action_traits::create (i, f, this));

        this->ext_action_.set (r);
        continue;
      }
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }

    if (!action_.present ())
    {
      this->action_.set (action_default_value ());
    }
  }

  Expectation* Expectation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Expectation (*this, f, c);
  }

  Expectation::
  ~Expectation ()
  {
  }

  // Method
  //

  Method::
  Method ()
  : ::xml_schema::type (),
    Reference_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Method::
  Method (const Method& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Reference_ (x.Reference_, f, this),
    Description_ (x.Description_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Method::
  Method (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Reference_ (f, this),
    Description_ (f, this),
    AdditionalData_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Method::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Reference
      //
      if (n.name () == "Reference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Reference_type > r (
          Reference_traits::create (i, f, this));

        this->Reference_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  Method* Method::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Method (*this, f, c);
  }

  Method::
  ~Method ()
  {
  }

  // Reference
  //

  Reference::
  Reference (const ReferenceName_type& ReferenceName)
  : ::xml_schema::type (),
    ReferenceName_ (ReferenceName, ::xml_schema::flags (), this),
    URL_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this)
  {
  }

  Reference::
  Reference (::std::auto_ptr< ReferenceName_type >& ReferenceName)
  : ::xml_schema::type (),
    ReferenceName_ (ReferenceName, ::xml_schema::flags (), this),
    URL_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this)
  {
  }

  Reference::
  Reference (const Reference& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ReferenceName_ (x.ReferenceName_, f, this),
    URL_ (x.URL_, f, this),
    Description_ (x.Description_, f, this)
  {
  }

  Reference::
  Reference (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ReferenceName_ (f, this),
    URL_ (f, this),
    Description_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Reference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReferenceName
      //
      if (n.name () == "ReferenceName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ReferenceName_type > r (
          ReferenceName_traits::create (i, f, this));

        if (!ReferenceName_.present ())
        {
          this->ReferenceName_.set (r);
          continue;
        }
      }

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        this->URL_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      break;
    }

    if (!ReferenceName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ReferenceName",
        "urn:ietf:params:xml:ns:iodef-1.0");
    }
  }

  Reference* Reference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Reference (*this, f, c);
  }

  Reference::
  ~Reference ()
  {
  }

  // Assessment
  //

  Assessment::
  Assessment ()
  : ::xml_schema::type (),
    Impact_ (::xml_schema::flags (), this),
    TimeImpact_ (::xml_schema::flags (), this),
    MonetaryImpact_ (::xml_schema::flags (), this),
    Counter_ (::xml_schema::flags (), this),
    Confidence_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    occurrence_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Assessment::
  Assessment (const Assessment& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Impact_ (x.Impact_, f, this),
    TimeImpact_ (x.TimeImpact_, f, this),
    MonetaryImpact_ (x.MonetaryImpact_, f, this),
    Counter_ (x.Counter_, f, this),
    Confidence_ (x.Confidence_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    occurrence_ (x.occurrence_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Assessment::
  Assessment (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Impact_ (f, this),
    TimeImpact_ (f, this),
    MonetaryImpact_ (f, this),
    Counter_ (f, this),
    Confidence_ (f, this),
    AdditionalData_ (f, this),
    occurrence_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Assessment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Impact
      //
      if (n.name () == "Impact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Impact_type > r (
          Impact_traits::create (i, f, this));

        this->Impact_.push_back (r);
        continue;
      }

      // TimeImpact
      //
      if (n.name () == "TimeImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< TimeImpact_type > r (
          TimeImpact_traits::create (i, f, this));

        this->TimeImpact_.push_back (r);
        continue;
      }

      // MonetaryImpact
      //
      if (n.name () == "MonetaryImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< MonetaryImpact_type > r (
          MonetaryImpact_traits::create (i, f, this));

        this->MonetaryImpact_.push_back (r);
        continue;
      }

      // Counter
      //
      if (n.name () == "Counter" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Counter_type > r (
          Counter_traits::create (i, f, this));

        this->Counter_.push_back (r);
        continue;
      }

      // Confidence
      //
      if (n.name () == "Confidence" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Confidence_type > r (
          Confidence_traits::create (i, f, this));

        if (!this->Confidence_)
        {
          this->Confidence_.set (r);
          continue;
        }
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "occurrence" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< occurrence_type > r (
          occurrence_traits::create (i, f, this));

        this->occurrence_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  Assessment* Assessment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Assessment (*this, f, c);
  }

  Assessment::
  ~Assessment ()
  {
  }

  // Impact
  //

  const Impact::type_type Impact::type_default_value_ (
    "unknown");

  Impact::
  Impact ()
  : ::iodef_1_0::MLStringType (),
    severity_ (::xml_schema::flags (), this),
    completion_ (::xml_schema::flags (), this),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this)
  {
  }

  Impact::
  Impact (const char* _xsd_string_base)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    completion_ (::xml_schema::flags (), this),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this)
  {
  }

  Impact::
  Impact (const ::std::string& _xsd_string_base)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    completion_ (::xml_schema::flags (), this),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this)
  {
  }

  Impact::
  Impact (const ::xml_schema::string& _xsd_string_base)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    completion_ (::xml_schema::flags (), this),
    type_ (type_default_value (), ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this)
  {
  }

  Impact::
  Impact (const Impact& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::iodef_1_0::MLStringType (x, f, c),
    severity_ (x.severity_, f, this),
    completion_ (x.completion_, f, this),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this)
  {
  }

  Impact::
  Impact (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::iodef_1_0::MLStringType (e, f | ::xml_schema::flags::base, c),
    severity_ (f, this),
    completion_ (f, this),
    type_ (f, this),
    ext_type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Impact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::iodef_1_0::MLStringType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< severity_type > r (
          severity_traits::create (i, f, this));

        this->severity_.set (r);
        continue;
      }

      if (n.name () == "completion" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< completion_type > r (
          completion_traits::create (i, f, this));

        this->completion_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_type_type > r (
          ext_type_traits::create (i, f, this));

        this->ext_type_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  Impact* Impact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Impact (*this, f, c);
  }

  Impact::
  ~Impact ()
  {
  }

  // TimeImpact
  //

  TimeImpact::
  TimeImpact (const ::xml_schema::float_& _xsd_float__base,
              const metric_type& metric)
  : ::iodef_1_0::PositiveFloatType (_xsd_float__base),
    severity_ (::xml_schema::flags (), this),
    metric_ (metric, ::xml_schema::flags (), this),
    ext_metric_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  TimeImpact::
  TimeImpact (const TimeImpact& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::iodef_1_0::PositiveFloatType (x, f, c),
    severity_ (x.severity_, f, this),
    metric_ (x.metric_, f, this),
    ext_metric_ (x.ext_metric_, f, this),
    duration_ (x.duration_, f, this),
    ext_duration_ (x.ext_duration_, f, this)
  {
  }

  TimeImpact::
  TimeImpact (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::iodef_1_0::PositiveFloatType (e, f | ::xml_schema::flags::base, c),
    severity_ (f, this),
    metric_ (f, this),
    ext_metric_ (f, this),
    duration_ (f, this),
    ext_duration_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void TimeImpact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< severity_type > r (
          severity_traits::create (i, f, this));

        this->severity_.set (r);
        continue;
      }

      if (n.name () == "metric" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< metric_type > r (
          metric_traits::create (i, f, this));

        this->metric_.set (r);
        continue;
      }

      if (n.name () == "ext-metric" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_metric_type > r (
          ext_metric_traits::create (i, f, this));

        this->ext_metric_.set (r);
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        this->duration_.set (r);
        continue;
      }

      if (n.name () == "ext-duration" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_duration_type > r (
          ext_duration_traits::create (i, f, this));

        this->ext_duration_.set (r);
        continue;
      }
    }

    if (!metric_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "metric",
        "");
    }
  }

  TimeImpact* TimeImpact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimeImpact (*this, f, c);
  }

  TimeImpact::
  ~TimeImpact ()
  {
  }

  // MonetaryImpact
  //

  MonetaryImpact::
  MonetaryImpact (const ::xml_schema::float_& _xsd_float__base)
  : ::iodef_1_0::PositiveFloatType (_xsd_float__base),
    severity_ (::xml_schema::flags (), this),
    currency_ (::xml_schema::flags (), this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const MonetaryImpact& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::iodef_1_0::PositiveFloatType (x, f, c),
    severity_ (x.severity_, f, this),
    currency_ (x.currency_, f, this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::iodef_1_0::PositiveFloatType (e, f | ::xml_schema::flags::base, c),
    severity_ (f, this),
    currency_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MonetaryImpact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< severity_type > r (
          severity_traits::create (i, f, this));

        this->severity_.set (r);
        continue;
      }

      if (n.name () == "currency" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< currency_type > r (
          currency_traits::create (i, f, this));

        this->currency_.set (r);
        continue;
      }
    }
  }

  MonetaryImpact* MonetaryImpact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MonetaryImpact (*this, f, c);
  }

  MonetaryImpact::
  ~MonetaryImpact ()
  {
  }

  // Confidence
  //

  Confidence::
  Confidence (const rating_type& rating)
  : ::xml_schema::type (),
    rating_ (rating, ::xml_schema::flags (), this)
  {
  }

  Confidence::
  Confidence (const Confidence& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    rating_ (x.rating_, f, this)
  {
  }

  Confidence::
  Confidence (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    rating_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Confidence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "rating" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rating_type > r (
          rating_traits::create (i, f, this));

        this->rating_.set (r);
        continue;
      }
    }

    if (!rating_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "rating",
        "");
    }
  }

  Confidence* Confidence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Confidence (*this, f, c);
  }

  Confidence::
  ~Confidence ()
  {
  }

  // EventData
  //

  const EventData::restriction_type EventData::restriction_default_value_ (
    "default");

  EventData::
  EventData ()
  : ::xml_schema::type (),
    Description_ (::xml_schema::flags (), this),
    DetectTime_ (::xml_schema::flags (), this),
    StartTime_ (::xml_schema::flags (), this),
    EndTime_ (::xml_schema::flags (), this),
    Contact_ (::xml_schema::flags (), this),
    Assessment_ (::xml_schema::flags (), this),
    Method_ (::xml_schema::flags (), this),
    Flow_ (::xml_schema::flags (), this),
    Expectation_ (::xml_schema::flags (), this),
    Record_ (::xml_schema::flags (), this),
    EventData1_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    restriction_ (restriction_default_value (), ::xml_schema::flags (), this)
  {
  }

  EventData::
  EventData (const EventData& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Description_ (x.Description_, f, this),
    DetectTime_ (x.DetectTime_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    Contact_ (x.Contact_, f, this),
    Assessment_ (x.Assessment_, f, this),
    Method_ (x.Method_, f, this),
    Flow_ (x.Flow_, f, this),
    Expectation_ (x.Expectation_, f, this),
    Record_ (x.Record_, f, this),
    EventData1_ (x.EventData1_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  EventData::
  EventData (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Description_ (f, this),
    DetectTime_ (f, this),
    StartTime_ (f, this),
    EndTime_ (f, this),
    Contact_ (f, this),
    Assessment_ (f, this),
    Method_ (f, this),
    Flow_ (f, this),
    Expectation_ (f, this),
    Record_ (f, this),
    EventData1_ (f, this),
    AdditionalData_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void EventData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // DetectTime
      //
      if (n.name () == "DetectTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DetectTime_type > r (
          DetectTime_traits::create (i, f, this));

        if (!this->DetectTime_)
        {
          this->DetectTime_.set (r);
          continue;
        }
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        this->Contact_.push_back (r);
        continue;
      }

      // Assessment
      //
      if (n.name () == "Assessment" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Assessment_type > r (
          Assessment_traits::create (i, f, this));

        if (!this->Assessment_)
        {
          this->Assessment_.set (r);
          continue;
        }
      }

      // Method
      //
      if (n.name () == "Method" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Method_type > r (
          Method_traits::create (i, f, this));

        this->Method_.push_back (r);
        continue;
      }

      // Flow
      //
      if (n.name () == "Flow" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Flow_type > r (
          Flow_traits::create (i, f, this));

        this->Flow_.push_back (r);
        continue;
      }

      // Expectation
      //
      if (n.name () == "Expectation" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Expectation_type > r (
          Expectation_traits::create (i, f, this));

        this->Expectation_.push_back (r);
        continue;
      }

      // Record
      //
      if (n.name () == "Record" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Record_type > r (
          Record_traits::create (i, f, this));

        if (!this->Record_)
        {
          this->Record_.set (r);
          continue;
        }
      }

      // EventData
      //
      if (n.name () == "EventData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EventData1_type > r (
          EventData1_traits::create (i, f, this));

        this->EventData1_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }

    if (!restriction_.present ())
    {
      this->restriction_.set (restriction_default_value ());
    }
  }

  EventData* EventData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EventData (*this, f, c);
  }

  EventData::
  ~EventData ()
  {
  }

  // Flow
  //

  Flow::
  Flow ()
  : ::xml_schema::type (),
    System_ (::xml_schema::flags (), this)
  {
  }

  Flow::
  Flow (const Flow& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    System_ (x.System_, f, this)
  {
  }

  Flow::
  Flow (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    System_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Flow::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // System
      //
      if (n.name () == "System" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< System_type > r (
          System_traits::create (i, f, this));

        this->System_.push_back (r);
        continue;
      }

      break;
    }
  }

  Flow* Flow::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Flow (*this, f, c);
  }

  Flow::
  ~Flow ()
  {
  }

  // System
  //

  const System::spoofed_type System::spoofed_default_value_ (
    "unknown");

  System::
  System (const Node_type& Node)
  : ::xml_schema::type (),
    Node_ (Node, ::xml_schema::flags (), this),
    Service_ (::xml_schema::flags (), this),
    OperatingSystem_ (::xml_schema::flags (), this),
    Counter_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this),
    interface_ (::xml_schema::flags (), this),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    spoofed_ (spoofed_default_value (), ::xml_schema::flags (), this)
  {
  }

  System::
  System (::std::auto_ptr< Node_type >& Node)
  : ::xml_schema::type (),
    Node_ (Node, ::xml_schema::flags (), this),
    Service_ (::xml_schema::flags (), this),
    OperatingSystem_ (::xml_schema::flags (), this),
    Counter_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this),
    interface_ (::xml_schema::flags (), this),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    spoofed_ (spoofed_default_value (), ::xml_schema::flags (), this)
  {
  }

  System::
  System (const System& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Node_ (x.Node_, f, this),
    Service_ (x.Service_, f, this),
    OperatingSystem_ (x.OperatingSystem_, f, this),
    Counter_ (x.Counter_, f, this),
    Description_ (x.Description_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this),
    interface_ (x.interface_, f, this),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this),
    spoofed_ (x.spoofed_, f, this)
  {
  }

  System::
  System (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Node_ (f, this),
    Service_ (f, this),
    OperatingSystem_ (f, this),
    Counter_ (f, this),
    Description_ (f, this),
    AdditionalData_ (f, this),
    restriction_ (f, this),
    interface_ (f, this),
    category_ (f, this),
    ext_category_ (f, this),
    spoofed_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void System::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Node
      //
      if (n.name () == "Node" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Node_type > r (
          Node_traits::create (i, f, this));

        if (!Node_.present ())
        {
          this->Node_.set (r);
          continue;
        }
      }

      // Service
      //
      if (n.name () == "Service" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Service_type > r (
          Service_traits::create (i, f, this));

        this->Service_.push_back (r);
        continue;
      }

      // OperatingSystem
      //
      if (n.name () == "OperatingSystem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< OperatingSystem_type > r (
          OperatingSystem_traits::create (i, f, this));

        this->OperatingSystem_.push_back (r);
        continue;
      }

      // Counter
      //
      if (n.name () == "Counter" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Counter_type > r (
          Counter_traits::create (i, f, this));

        this->Counter_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    if (!Node_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Node",
        "urn:ietf:params:xml:ns:iodef-1.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }

      if (n.name () == "interface" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< interface_type > r (
          interface_traits::create (i, f, this));

        this->interface_.set (r);
        continue;
      }

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< category_type > r (
          category_traits::create (i, f, this));

        this->category_.set (r);
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_category_type > r (
          ext_category_traits::create (i, f, this));

        this->ext_category_.set (r);
        continue;
      }

      if (n.name () == "spoofed" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< spoofed_type > r (
          spoofed_traits::create (i, f, this));

        this->spoofed_.set (r);
        continue;
      }
    }

    if (!spoofed_.present ())
    {
      this->spoofed_.set (spoofed_default_value ());
    }
  }

  System* System::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class System (*this, f, c);
  }

  System::
  ~System ()
  {
  }

  // Node
  //

  Node::
  Node ()
  : ::xml_schema::type (),
    NodeName_ (::xml_schema::flags (), this),
    Address_ (::xml_schema::flags (), this),
    Location_ (::xml_schema::flags (), this),
    DateTime_ (::xml_schema::flags (), this),
    NodeRole_ (::xml_schema::flags (), this),
    Counter_ (::xml_schema::flags (), this)
  {
  }

  Node::
  Node (const Node& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    NodeName_ (x.NodeName_, f, this),
    Address_ (x.Address_, f, this),
    Location_ (x.Location_, f, this),
    DateTime_ (x.DateTime_, f, this),
    NodeRole_ (x.NodeRole_, f, this),
    Counter_ (x.Counter_, f, this)
  {
  }

  Node::
  Node (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    NodeName_ (f, this),
    Address_ (f, this),
    Location_ (f, this),
    DateTime_ (f, this),
    NodeRole_ (f, this),
    Counter_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Node::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // NodeName
      //
      if (n.name () == "NodeName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< NodeName_type > r (
          NodeName_traits::create (i, f, this));

        this->NodeName_.push_back (r);
        continue;
      }

      // Address
      //
      if (n.name () == "Address" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        this->Address_.push_back (r);
        continue;
      }

      // Location
      //
      if (n.name () == "Location" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Location_type > r (
          Location_traits::create (i, f, this));

        if (!this->Location_)
        {
          this->Location_.set (r);
          continue;
        }
      }

      // DateTime
      //
      if (n.name () == "DateTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DateTime_type > r (
          DateTime_traits::create (i, f, this));

        if (!this->DateTime_)
        {
          this->DateTime_.set (r);
          continue;
        }
      }

      // NodeRole
      //
      if (n.name () == "NodeRole" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< NodeRole_type > r (
          NodeRole_traits::create (i, f, this));

        this->NodeRole_.push_back (r);
        continue;
      }

      // Counter
      //
      if (n.name () == "Counter" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Counter_type > r (
          Counter_traits::create (i, f, this));

        this->Counter_.push_back (r);
        continue;
      }

      break;
    }
  }

  Node* Node::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Node (*this, f, c);
  }

  Node::
  ~Node ()
  {
  }

  // Address
  //

  const Address::category_type Address::category_default_value_ (
    "ipv4-addr");

  Address::
  Address ()
  : ::xml_schema::string (),
    category_ (category_default_value (), ::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    vlan_name_ (::xml_schema::flags (), this),
    vlan_num_ (::xml_schema::flags (), this)
  {
  }

  Address::
  Address (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (category_default_value (), ::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    vlan_name_ (::xml_schema::flags (), this),
    vlan_num_ (::xml_schema::flags (), this)
  {
  }

  Address::
  Address (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (category_default_value (), ::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    vlan_name_ (::xml_schema::flags (), this),
    vlan_num_ (::xml_schema::flags (), this)
  {
  }

  Address::
  Address (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (category_default_value (), ::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    vlan_name_ (::xml_schema::flags (), this),
    vlan_num_ (::xml_schema::flags (), this)
  {
  }

  Address::
  Address (const Address& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this),
    vlan_name_ (x.vlan_name_, f, this),
    vlan_num_ (x.vlan_num_, f, this)
  {
  }

  Address::
  Address (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    category_ (f, this),
    ext_category_ (f, this),
    vlan_name_ (f, this),
    vlan_num_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Address::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< category_type > r (
          category_traits::create (i, f, this));

        this->category_.set (r);
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_category_type > r (
          ext_category_traits::create (i, f, this));

        this->ext_category_.set (r);
        continue;
      }

      if (n.name () == "vlan-name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vlan_name_type > r (
          vlan_name_traits::create (i, f, this));

        this->vlan_name_.set (r);
        continue;
      }

      if (n.name () == "vlan-num" && n.namespace_ ().empty ())
      {
        this->vlan_num_.set (vlan_num_traits::create (i, f, this));
        continue;
      }
    }

    if (!category_.present ())
    {
      this->category_.set (category_default_value ());
    }
  }

  Address* Address::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Address (*this, f, c);
  }

  Address::
  ~Address ()
  {
  }

  // NodeRole
  //

  NodeRole::
  NodeRole (const category_type& category)
  : ::iodef_1_0::MLStringType (),
    category_ (category, ::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this)
  {
  }

  NodeRole::
  NodeRole (const char* _xsd_string_base,
            const category_type& category)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    category_ (category, ::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this)
  {
  }

  NodeRole::
  NodeRole (const ::std::string& _xsd_string_base,
            const category_type& category)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    category_ (category, ::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this)
  {
  }

  NodeRole::
  NodeRole (const ::xml_schema::string& _xsd_string_base,
            const category_type& category)
  : ::iodef_1_0::MLStringType (_xsd_string_base),
    category_ (category, ::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this)
  {
  }

  NodeRole::
  NodeRole (const NodeRole& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::iodef_1_0::MLStringType (x, f, c),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this)
  {
  }

  NodeRole::
  NodeRole (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::iodef_1_0::MLStringType (e, f | ::xml_schema::flags::base, c),
    category_ (f, this),
    ext_category_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void NodeRole::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::iodef_1_0::MLStringType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< category_type > r (
          category_traits::create (i, f, this));

        this->category_.set (r);
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_category_type > r (
          ext_category_traits::create (i, f, this));

        this->ext_category_.set (r);
        continue;
      }
    }

    if (!category_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "category",
        "");
    }
  }

  NodeRole* NodeRole::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NodeRole (*this, f, c);
  }

  NodeRole::
  ~NodeRole ()
  {
  }

  // Service
  //

  Service::
  Service (const ip_protocol_type& ip_protocol)
  : ::xml_schema::type (),
    Port_ (::xml_schema::flags (), this),
    Portlist_ (::xml_schema::flags (), this),
    ProtoType_ (::xml_schema::flags (), this),
    ProtoCode_ (::xml_schema::flags (), this),
    ProtoField_ (::xml_schema::flags (), this),
    Application_ (::xml_schema::flags (), this),
    ip_protocol_ (ip_protocol, ::xml_schema::flags (), this)
  {
  }

  Service::
  Service (const Service& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Port_ (x.Port_, f, this),
    Portlist_ (x.Portlist_, f, this),
    ProtoType_ (x.ProtoType_, f, this),
    ProtoCode_ (x.ProtoCode_, f, this),
    ProtoField_ (x.ProtoField_, f, this),
    Application_ (x.Application_, f, this),
    ip_protocol_ (x.ip_protocol_, f, this)
  {
  }

  Service::
  Service (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Port_ (f, this),
    Portlist_ (f, this),
    ProtoType_ (f, this),
    ProtoCode_ (f, this),
    ProtoField_ (f, this),
    Application_ (f, this),
    ip_protocol_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Service::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Port
      //
      if (n.name () == "Port" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        if (!this->Port_)
        {
          this->Port_.set (Port_traits::create (i, f, this));
          continue;
        }
      }

      // Portlist
      //
      if (n.name () == "Portlist" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Portlist_type > r (
          Portlist_traits::create (i, f, this));

        if (!this->Portlist_)
        {
          this->Portlist_.set (r);
          continue;
        }
      }

      // ProtoType
      //
      if (n.name () == "ProtoType" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        if (!this->ProtoType_)
        {
          this->ProtoType_.set (ProtoType_traits::create (i, f, this));
          continue;
        }
      }

      // ProtoCode
      //
      if (n.name () == "ProtoCode" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        if (!this->ProtoCode_)
        {
          this->ProtoCode_.set (ProtoCode_traits::create (i, f, this));
          continue;
        }
      }

      // ProtoField
      //
      if (n.name () == "ProtoField" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        if (!this->ProtoField_)
        {
          this->ProtoField_.set (ProtoField_traits::create (i, f, this));
          continue;
        }
      }

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        if (!this->Application_)
        {
          this->Application_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ip_protocol" && n.namespace_ ().empty ())
      {
        this->ip_protocol_.set (ip_protocol_traits::create (i, f, this));
        continue;
      }
    }

    if (!ip_protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ip_protocol",
        "");
    }
  }

  Service* Service::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Service (*this, f, c);
  }

  Service::
  ~Service ()
  {
  }

  // Counter
  //

  Counter::
  Counter (const ::xml_schema::double_& _xsd_double__base,
           const type_type& type)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
    type_ (type, ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  Counter::
  Counter (const Counter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    meaning_ (x.meaning_, f, this),
    duration_ (x.duration_, f, this),
    ext_duration_ (x.ext_duration_, f, this)
  {
  }

  Counter::
  Counter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    ext_type_ (f, this),
    meaning_ (f, this),
    duration_ (f, this),
    ext_duration_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Counter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_type_type > r (
          ext_type_traits::create (i, f, this));

        this->ext_type_.set (r);
        continue;
      }

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        this->duration_.set (r);
        continue;
      }

      if (n.name () == "ext-duration" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_duration_type > r (
          ext_duration_traits::create (i, f, this));

        this->ext_duration_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  Counter* Counter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Counter (*this, f, c);
  }

  Counter::
  ~Counter ()
  {
  }

  // Record
  //

  Record::
  Record ()
  : ::xml_schema::type (),
    RecordData_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Record::
  Record (const Record& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    RecordData_ (x.RecordData_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Record::
  Record (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    RecordData_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Record::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RecordData
      //
      if (n.name () == "RecordData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RecordData_type > r (
          RecordData_traits::create (i, f, this));

        this->RecordData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  Record* Record::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Record (*this, f, c);
  }

  Record::
  ~Record ()
  {
  }

  // RecordData
  //

  RecordData::
  RecordData ()
  : ::xml_schema::type (),
    DateTime_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    Application_ (::xml_schema::flags (), this),
    RecordPattern_ (::xml_schema::flags (), this),
    RecordItem_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  RecordData::
  RecordData (const RecordData& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DateTime_ (x.DateTime_, f, this),
    Description_ (x.Description_, f, this),
    Application_ (x.Application_, f, this),
    RecordPattern_ (x.RecordPattern_, f, this),
    RecordItem_ (x.RecordItem_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  RecordData::
  RecordData (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DateTime_ (f, this),
    Description_ (f, this),
    Application_ (f, this),
    RecordPattern_ (f, this),
    RecordItem_ (f, this),
    AdditionalData_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RecordData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DateTime
      //
      if (n.name () == "DateTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DateTime_type > r (
          DateTime_traits::create (i, f, this));

        if (!this->DateTime_)
        {
          this->DateTime_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        if (!this->Application_)
        {
          this->Application_.set (r);
          continue;
        }
      }

      // RecordPattern
      //
      if (n.name () == "RecordPattern" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RecordPattern_type > r (
          RecordPattern_traits::create (i, f, this));

        this->RecordPattern_.push_back (r);
        continue;
      }

      // RecordItem
      //
      if (n.name () == "RecordItem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RecordItem_type > r (
          RecordItem_traits::create (i, f, this));

        this->RecordItem_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  RecordData* RecordData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordData (*this, f, c);
  }

  RecordData::
  ~RecordData ()
  {
  }

  // RecordPattern
  //

  const RecordPattern::offsetunit_type RecordPattern::offsetunit_default_value_ (
    "line");

  RecordPattern::
  RecordPattern (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    offset_ (::xml_schema::flags (), this),
    offsetunit_ (offsetunit_default_value (), ::xml_schema::flags (), this),
    ext_offsetunit_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this)
  {
  }

  RecordPattern::
  RecordPattern (const char* _xsd_string_base,
                 const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    offset_ (::xml_schema::flags (), this),
    offsetunit_ (offsetunit_default_value (), ::xml_schema::flags (), this),
    ext_offsetunit_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this)
  {
  }

  RecordPattern::
  RecordPattern (const ::std::string& _xsd_string_base,
                 const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    offset_ (::xml_schema::flags (), this),
    offsetunit_ (offsetunit_default_value (), ::xml_schema::flags (), this),
    ext_offsetunit_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this)
  {
  }

  RecordPattern::
  RecordPattern (const ::xml_schema::string& _xsd_string_base,
                 const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, ::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    offset_ (::xml_schema::flags (), this),
    offsetunit_ (offsetunit_default_value (), ::xml_schema::flags (), this),
    ext_offsetunit_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this)
  {
  }

  RecordPattern::
  RecordPattern (const RecordPattern& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    offset_ (x.offset_, f, this),
    offsetunit_ (x.offsetunit_, f, this),
    ext_offsetunit_ (x.ext_offsetunit_, f, this),
    instance_ (x.instance_, f, this)
  {
  }

  RecordPattern::
  RecordPattern (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    ext_type_ (f, this),
    offset_ (f, this),
    offsetunit_ (f, this),
    ext_offsetunit_ (f, this),
    instance_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void RecordPattern::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_type_type > r (
          ext_type_traits::create (i, f, this));

        this->ext_type_.set (r);
        continue;
      }

      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        this->offset_.set (offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "offsetunit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< offsetunit_type > r (
          offsetunit_traits::create (i, f, this));

        this->offsetunit_.set (r);
        continue;
      }

      if (n.name () == "ext-offsetunit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_offsetunit_type > r (
          ext_offsetunit_traits::create (i, f, this));

        this->ext_offsetunit_.set (r);
        continue;
      }

      if (n.name () == "instance" && n.namespace_ ().empty ())
      {
        this->instance_.set (instance_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!offsetunit_.present ())
    {
      this->offsetunit_.set (offsetunit_default_value ());
    }
  }

  RecordPattern* RecordPattern::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordPattern (*this, f, c);
  }

  RecordPattern::
  ~RecordPattern ()
  {
  }

  // purpose
  //

  purpose::
  purpose (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_purpose_convert ();
  }

  purpose::
  purpose (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_purpose_convert ();
  }

  purpose::
  purpose (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_purpose_convert ();
  }

  purpose* purpose::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class purpose (*this, f, c);
  }

  purpose::value purpose::
  _xsd_purpose_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_purpose_literals_);
    const value* i (::std::lower_bound (
                      _xsd_purpose_indexes_,
                      _xsd_purpose_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_purpose_indexes_ + 5 || _xsd_purpose_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const purpose::
  _xsd_purpose_literals_[5] =
  {
    "traceback",
    "mitigation",
    "reporting",
    "other",
    "ext-value"
  };

  const purpose::value purpose::
  _xsd_purpose_indexes_[5] =
  {
    ::iodef_1_0::purpose::ext_value,
    ::iodef_1_0::purpose::mitigation,
    ::iodef_1_0::purpose::other,
    ::iodef_1_0::purpose::reporting,
    ::iodef_1_0::purpose::traceback
  };

  // role
  //

  role::
  role (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_role_convert ();
  }

  role::
  role (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_role_convert ();
  }

  role::
  role (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_role_convert ();
  }

  role* role::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class role (*this, f, c);
  }

  role::value role::
  _xsd_role_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_role_literals_);
    const value* i (::std::lower_bound (
                      _xsd_role_indexes_,
                      _xsd_role_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_role_indexes_ + 6 || _xsd_role_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const role::
  _xsd_role_literals_[6] =
  {
    "creator",
    "admin",
    "tech",
    "irt",
    "cc",
    "ext-value"
  };

  const role::value role::
  _xsd_role_indexes_[6] =
  {
    ::iodef_1_0::role::admin,
    ::iodef_1_0::role::cc,
    ::iodef_1_0::role::creator,
    ::iodef_1_0::role::ext_value,
    ::iodef_1_0::role::irt,
    ::iodef_1_0::role::tech
  };

  // type
  //

  type::
  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type_convert ();
  }

  type* type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type (*this, f, c);
  }

  type::value type::
  _xsd_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type_indexes_,
                      _xsd_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_type_indexes_ + 3 || _xsd_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type::
  _xsd_type_literals_[3] =
  {
    "person",
    "organization",
    "ext-value"
  };

  const type::value type::
  _xsd_type_indexes_[3] =
  {
    ::iodef_1_0::type::ext_value,
    ::iodef_1_0::type::organization,
    ::iodef_1_0::type::person
  };

  // registry
  //

  registry::
  registry (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_registry_convert ();
  }

  registry::
  registry (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_registry_convert ();
  }

  registry::
  registry (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_registry_convert ();
  }

  registry* registry::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class registry (*this, f, c);
  }

  registry::value registry::
  _xsd_registry_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_registry_literals_);
    const value* i (::std::lower_bound (
                      _xsd_registry_indexes_,
                      _xsd_registry_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_registry_indexes_ + 8 || _xsd_registry_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const registry::
  _xsd_registry_literals_[8] =
  {
    "internic",
    "apnic",
    "arin",
    "lacnic",
    "ripe",
    "afrinic",
    "local",
    "ext-value"
  };

  const registry::value registry::
  _xsd_registry_indexes_[8] =
  {
    ::iodef_1_0::registry::afrinic,
    ::iodef_1_0::registry::apnic,
    ::iodef_1_0::registry::arin,
    ::iodef_1_0::registry::ext_value,
    ::iodef_1_0::registry::internic,
    ::iodef_1_0::registry::lacnic,
    ::iodef_1_0::registry::local,
    ::iodef_1_0::registry::ripe
  };

  // occurrence
  //

  occurrence::
  occurrence (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_occurrence_convert ();
  }

  occurrence::
  occurrence (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_occurrence_convert ();
  }

  occurrence::
  occurrence (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_occurrence_convert ();
  }

  occurrence* occurrence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class occurrence (*this, f, c);
  }

  occurrence::value occurrence::
  _xsd_occurrence_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_occurrence_literals_);
    const value* i (::std::lower_bound (
                      _xsd_occurrence_indexes_,
                      _xsd_occurrence_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_occurrence_indexes_ + 2 || _xsd_occurrence_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const occurrence::
  _xsd_occurrence_literals_[2] =
  {
    "actual",
    "potential"
  };

  const occurrence::value occurrence::
  _xsd_occurrence_indexes_[2] =
  {
    ::iodef_1_0::occurrence::actual,
    ::iodef_1_0::occurrence::potential
  };

  // completion
  //

  completion::
  completion (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_completion_convert ();
  }

  completion::
  completion (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_completion_convert ();
  }

  completion::
  completion (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_completion_convert ();
  }

  completion* completion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class completion (*this, f, c);
  }

  completion::value completion::
  _xsd_completion_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_completion_literals_);
    const value* i (::std::lower_bound (
                      _xsd_completion_indexes_,
                      _xsd_completion_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_completion_indexes_ + 2 || _xsd_completion_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const completion::
  _xsd_completion_literals_[2] =
  {
    "failed",
    "succeeded"
  };

  const completion::value completion::
  _xsd_completion_indexes_[2] =
  {
    ::iodef_1_0::completion::failed,
    ::iodef_1_0::completion::succeeded
  };

  // type1
  //

  type1::
  type1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type1_convert ();
  }

  type1::
  type1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type1_convert ();
  }

  type1::
  type1 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type1_convert ();
  }

  type1* type1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type1 (*this, f, c);
  }

  type1::value type1::
  _xsd_type1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type1_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type1_indexes_,
                      _xsd_type1_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_type1_indexes_ + 12 || _xsd_type1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type1::
  _xsd_type1_literals_[12] =
  {
    "admin",
    "dos",
    "extortion",
    "file",
    "info-leak",
    "misconfiguration",
    "recon",
    "policy",
    "social-engineering",
    "user",
    "unknown",
    "ext-value"
  };

  const type1::value type1::
  _xsd_type1_indexes_[12] =
  {
    ::iodef_1_0::type1::admin,
    ::iodef_1_0::type1::dos,
    ::iodef_1_0::type1::ext_value,
    ::iodef_1_0::type1::extortion,
    ::iodef_1_0::type1::file,
    ::iodef_1_0::type1::info_leak,
    ::iodef_1_0::type1::misconfiguration,
    ::iodef_1_0::type1::policy,
    ::iodef_1_0::type1::recon,
    ::iodef_1_0::type1::social_engineering,
    ::iodef_1_0::type1::unknown,
    ::iodef_1_0::type1::user
  };

  // metric
  //

  metric::
  metric (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_metric_convert ();
  }

  metric::
  metric (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_metric_convert ();
  }

  metric::
  metric (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_metric_convert ();
  }

  metric* metric::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metric (*this, f, c);
  }

  metric::value metric::
  _xsd_metric_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_metric_literals_);
    const value* i (::std::lower_bound (
                      _xsd_metric_indexes_,
                      _xsd_metric_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_metric_indexes_ + 4 || _xsd_metric_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const metric::
  _xsd_metric_literals_[4] =
  {
    "labor",
    "elapsed",
    "downtime",
    "ext-value"
  };

  const metric::value metric::
  _xsd_metric_indexes_[4] =
  {
    ::iodef_1_0::metric::downtime,
    ::iodef_1_0::metric::elapsed,
    ::iodef_1_0::metric::ext_value,
    ::iodef_1_0::metric::labor
  };

  // rating
  //

  rating::
  rating (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_rating_convert ();
  }

  rating::
  rating (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_rating_convert ();
  }

  rating::
  rating (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_rating_convert ();
  }

  rating* rating::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class rating (*this, f, c);
  }

  rating::value rating::
  _xsd_rating_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_rating_literals_);
    const value* i (::std::lower_bound (
                      _xsd_rating_indexes_,
                      _xsd_rating_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_rating_indexes_ + 5 || _xsd_rating_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const rating::
  _xsd_rating_literals_[5] =
  {
    "low",
    "medium",
    "high",
    "numeric",
    "unknown"
  };

  const rating::value rating::
  _xsd_rating_indexes_[5] =
  {
    ::iodef_1_0::rating::high,
    ::iodef_1_0::rating::low,
    ::iodef_1_0::rating::medium,
    ::iodef_1_0::rating::numeric,
    ::iodef_1_0::rating::unknown
  };

  // category
  //

  category::
  category (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_category_convert ();
  }

  category::
  category (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_category_convert ();
  }

  category::
  category (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_category_convert ();
  }

  category* category::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class category (*this, f, c);
  }

  category::value category::
  _xsd_category_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_category_literals_);
    const value* i (::std::lower_bound (
                      _xsd_category_indexes_,
                      _xsd_category_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_category_indexes_ + 6 || _xsd_category_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const category::
  _xsd_category_literals_[6] =
  {
    "source",
    "target",
    "intermediate",
    "sensor",
    "infrastructure",
    "ext-value"
  };

  const category::value category::
  _xsd_category_indexes_[6] =
  {
    ::iodef_1_0::category::ext_value,
    ::iodef_1_0::category::infrastructure,
    ::iodef_1_0::category::intermediate,
    ::iodef_1_0::category::sensor,
    ::iodef_1_0::category::source,
    ::iodef_1_0::category::target
  };

  // spoofed
  //

  spoofed::
  spoofed (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_spoofed_convert ();
  }

  spoofed::
  spoofed (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_spoofed_convert ();
  }

  spoofed::
  spoofed (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_spoofed_convert ();
  }

  spoofed* spoofed::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class spoofed (*this, f, c);
  }

  spoofed::value spoofed::
  _xsd_spoofed_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_spoofed_literals_);
    const value* i (::std::lower_bound (
                      _xsd_spoofed_indexes_,
                      _xsd_spoofed_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_spoofed_indexes_ + 3 || _xsd_spoofed_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const spoofed::
  _xsd_spoofed_literals_[3] =
  {
    "unknown",
    "yes",
    "no"
  };

  const spoofed::value spoofed::
  _xsd_spoofed_indexes_[3] =
  {
    ::iodef_1_0::spoofed::no,
    ::iodef_1_0::spoofed::unknown,
    ::iodef_1_0::spoofed::yes
  };

  // category1
  //

  category1::
  category1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_category1_convert ();
  }

  category1::
  category1 (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_category1_convert ();
  }

  category1::
  category1 (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_category1_convert ();
  }

  category1* category1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class category1 (*this, f, c);
  }

  category1::value category1::
  _xsd_category1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_category1_literals_);
    const value* i (::std::lower_bound (
                      _xsd_category1_indexes_,
                      _xsd_category1_indexes_ + 11,
                      *this,
                      c));

    if (i == _xsd_category1_indexes_ + 11 || _xsd_category1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const category1::
  _xsd_category1_literals_[11] =
  {
    "asn",
    "atm",
    "e-mail",
    "mac",
    "ipv4-addr",
    "ipv4-net",
    "ipv4-net-mask",
    "ipv6-addr",
    "ipv6-net",
    "ipv6-net-mask",
    "ext-value"
  };

  const category1::value category1::
  _xsd_category1_indexes_[11] =
  {
    ::iodef_1_0::category1::asn,
    ::iodef_1_0::category1::atm,
    ::iodef_1_0::category1::e_mail,
    ::iodef_1_0::category1::ext_value,
    ::iodef_1_0::category1::ipv4_addr,
    ::iodef_1_0::category1::ipv4_net,
    ::iodef_1_0::category1::ipv4_net_mask,
    ::iodef_1_0::category1::ipv6_addr,
    ::iodef_1_0::category1::ipv6_net,
    ::iodef_1_0::category1::ipv6_net_mask,
    ::iodef_1_0::category1::mac
  };

  // category2
  //

  category2::
  category2 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_category2_convert ();
  }

  category2::
  category2 (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_category2_convert ();
  }

  category2::
  category2 (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_category2_convert ();
  }

  category2* category2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class category2 (*this, f, c);
  }

  category2::value category2::
  _xsd_category2_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_category2_literals_);
    const value* i (::std::lower_bound (
                      _xsd_category2_indexes_,
                      _xsd_category2_indexes_ + 20,
                      *this,
                      c));

    if (i == _xsd_category2_indexes_ + 20 || _xsd_category2_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const category2::
  _xsd_category2_literals_[20] =
  {
    "client",
    "server-internal",
    "server-public",
    "www",
    "mail",
    "messaging",
    "streaming",
    "voice",
    "file",
    "ftp",
    "p2p",
    "name",
    "directory",
    "credential",
    "print",
    "application",
    "database",
    "infra",
    "log",
    "ext-value"
  };

  const category2::value category2::
  _xsd_category2_indexes_[20] =
  {
    ::iodef_1_0::category2::application,
    ::iodef_1_0::category2::client,
    ::iodef_1_0::category2::credential,
    ::iodef_1_0::category2::database,
    ::iodef_1_0::category2::directory,
    ::iodef_1_0::category2::ext_value,
    ::iodef_1_0::category2::file,
    ::iodef_1_0::category2::ftp,
    ::iodef_1_0::category2::infra,
    ::iodef_1_0::category2::log,
    ::iodef_1_0::category2::mail,
    ::iodef_1_0::category2::messaging,
    ::iodef_1_0::category2::name,
    ::iodef_1_0::category2::p2p,
    ::iodef_1_0::category2::print,
    ::iodef_1_0::category2::server_internal,
    ::iodef_1_0::category2::server_public,
    ::iodef_1_0::category2::streaming,
    ::iodef_1_0::category2::voice,
    ::iodef_1_0::category2::www
  };

  // type2
  //

  type2::
  type2 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type2_convert ();
  }

  type2::
  type2 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type2_convert ();
  }

  type2::
  type2 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type2_convert ();
  }

  type2* type2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type2 (*this, f, c);
  }

  type2::value type2::
  _xsd_type2_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type2_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type2_indexes_,
                      _xsd_type2_indexes_ + 11,
                      *this,
                      c));

    if (i == _xsd_type2_indexes_ + 11 || _xsd_type2_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type2::
  _xsd_type2_literals_[11] =
  {
    "byte",
    "packet",
    "flow",
    "session",
    "event",
    "alert",
    "message",
    "host",
    "site",
    "organization",
    "ext-value"
  };

  const type2::value type2::
  _xsd_type2_indexes_[11] =
  {
    ::iodef_1_0::type2::alert,
    ::iodef_1_0::type2::byte,
    ::iodef_1_0::type2::event,
    ::iodef_1_0::type2::ext_value,
    ::iodef_1_0::type2::flow,
    ::iodef_1_0::type2::host,
    ::iodef_1_0::type2::message,
    ::iodef_1_0::type2::organization,
    ::iodef_1_0::type2::packet,
    ::iodef_1_0::type2::session,
    ::iodef_1_0::type2::site
  };

  // type3
  //

  type3::
  type3 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type3_convert ();
  }

  type3::
  type3 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type3_convert ();
  }

  type3::
  type3 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type3_convert ();
  }

  type3* type3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type3 (*this, f, c);
  }

  type3::value type3::
  _xsd_type3_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type3_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type3_indexes_,
                      _xsd_type3_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_type3_indexes_ + 4 || _xsd_type3_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type3::
  _xsd_type3_literals_[4] =
  {
    "regex",
    "binary",
    "xpath",
    "ext-value"
  };

  const type3::value type3::
  _xsd_type3_indexes_[4] =
  {
    ::iodef_1_0::type3::binary,
    ::iodef_1_0::type3::ext_value,
    ::iodef_1_0::type3::regex,
    ::iodef_1_0::type3::xpath
  };

  // offsetunit
  //

  offsetunit::
  offsetunit (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_offsetunit_convert ();
  }

  offsetunit::
  offsetunit (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_offsetunit_convert ();
  }

  offsetunit::
  offsetunit (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_offsetunit_convert ();
  }

  offsetunit* offsetunit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class offsetunit (*this, f, c);
  }

  offsetunit::value offsetunit::
  _xsd_offsetunit_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_offsetunit_literals_);
    const value* i (::std::lower_bound (
                      _xsd_offsetunit_indexes_,
                      _xsd_offsetunit_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_offsetunit_indexes_ + 3 || _xsd_offsetunit_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const offsetunit::
  _xsd_offsetunit_literals_[3] =
  {
    "line",
    "byte",
    "ext-value"
  };

  const offsetunit::value offsetunit::
  _xsd_offsetunit_indexes_[3] =
  {
    ::iodef_1_0::offsetunit::byte,
    ::iodef_1_0::offsetunit::ext_value,
    ::iodef_1_0::offsetunit::line
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace iodef_1_0
{
  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IODEF_Document_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IODEF_Document_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
        ::iodef_1_0::IODEF_Document_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IODEF-Document" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::IODEF_Document, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IODEF-Document",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IODEF-Document" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::IODEF_Document, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IODEF-Document",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Incident > r (
      ::iodef_1_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Incident > r (
      ::iodef_1_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Incident > r (
      ::iodef_1_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Incident_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Incident_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Incident_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Incident_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Incident_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Incident_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Incident > r (
      ::iodef_1_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Incident > r (
      ::iodef_1_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Incident > r (
      ::iodef_1_0::Incident_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Incident > r (
        ::iodef_1_0::Incident_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Incident" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Incident > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Incident, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Incident",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Incident >
  Incident_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Incident" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Incident > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Incident, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Incident",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
      ::iodef_1_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
      ::iodef_1_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
      ::iodef_1_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IncidentID (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IncidentID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IncidentID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IncidentID (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IncidentID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IncidentID (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
      ::iodef_1_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
      ::iodef_1_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
      ::iodef_1_0::IncidentID (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
        ::iodef_1_0::IncidentID (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IncidentID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::IncidentIDType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IncidentID",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentIDType >
  IncidentID (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IncidentID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::IncidentIDType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::IncidentIDType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IncidentID",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
      ::iodef_1_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
      ::iodef_1_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
      ::iodef_1_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::AlternativeID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::AlternativeID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::AlternativeID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::AlternativeID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::AlternativeID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::AlternativeID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
      ::iodef_1_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
      ::iodef_1_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
      ::iodef_1_0::AlternativeID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
        ::iodef_1_0::AlternativeID_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "AlternativeID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::AlternativeID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AlternativeID",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::AlternativeID >
  AlternativeID_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "AlternativeID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::AlternativeID > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::AlternativeID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AlternativeID",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
      ::iodef_1_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
      ::iodef_1_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
      ::iodef_1_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RelatedActivity_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RelatedActivity_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RelatedActivity_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RelatedActivity_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RelatedActivity_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RelatedActivity_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
      ::iodef_1_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
      ::iodef_1_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
      ::iodef_1_0::RelatedActivity_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
        ::iodef_1_0::RelatedActivity_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RelatedActivity" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::RelatedActivity, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RelatedActivity",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::RelatedActivity >
  RelatedActivity_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RelatedActivity" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::RelatedActivity > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::RelatedActivity, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RelatedActivity",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::AdditionalData (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::AdditionalData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::AdditionalData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::AdditionalData (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::AdditionalData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::AdditionalData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::AdditionalData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
        ::iodef_1_0::AdditionalData (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "AdditionalData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AdditionalData",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  AdditionalData (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "AdditionalData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AdditionalData",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Contact > r (
      ::iodef_1_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Contact > r (
      ::iodef_1_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Contact > r (
      ::iodef_1_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Contact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Contact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Contact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Contact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Contact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Contact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Contact > r (
      ::iodef_1_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Contact > r (
      ::iodef_1_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Contact > r (
      ::iodef_1_0::Contact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Contact > r (
        ::iodef_1_0::Contact_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Contact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Contact > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Contact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Contact",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Contact >
  Contact_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Contact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Contact > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Contact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Contact",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::ContactName (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::ContactName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::ContactName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::ContactName (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::ContactName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::ContactName (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::ContactName (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::iodef_1_0::ContactName (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ContactName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ContactName",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  ContactName (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ContactName" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ContactName",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
      ::iodef_1_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
      ::iodef_1_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
      ::iodef_1_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RegistryHandle_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RegistryHandle_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RegistryHandle_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RegistryHandle_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RegistryHandle_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RegistryHandle_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
      ::iodef_1_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
      ::iodef_1_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
      ::iodef_1_0::RegistryHandle_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
        ::iodef_1_0::RegistryHandle_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RegistryHandle" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::RegistryHandle, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RegistryHandle",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::RegistryHandle >
  RegistryHandle_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RegistryHandle" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::RegistryHandle > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::RegistryHandle, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RegistryHandle",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
      ::iodef_1_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
      ::iodef_1_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
      ::iodef_1_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::PostalAddress_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::PostalAddress_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::PostalAddress_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::PostalAddress_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::PostalAddress_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::PostalAddress_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
      ::iodef_1_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
      ::iodef_1_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
      ::iodef_1_0::PostalAddress_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
        ::iodef_1_0::PostalAddress_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PostalAddress" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::PostalAddress, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PostalAddress",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::PostalAddress >
  PostalAddress_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PostalAddress" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::PostalAddress > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::PostalAddress, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PostalAddress",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Email (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Email (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Email (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Email (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Email (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Email (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Email (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::iodef_1_0::Email (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Email" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Email",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Email (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Email" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Email",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Telephone (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Telephone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Telephone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Telephone (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Telephone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Telephone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Telephone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::iodef_1_0::Telephone (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Telephone" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Telephone",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Telephone (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Telephone" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Telephone",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Fax (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Fax (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Fax (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Fax (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Fax (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Fax (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
      ::iodef_1_0::Fax (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::iodef_1_0::Fax (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Fax" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Fax",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ContactMeansType >
  Fax (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Fax" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ContactMeansType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ContactMeansType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Fax",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::DateTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::DateTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::DateTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::DateTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::DateTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::DateTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DateTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::iodef_1_0::DateTime (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DateTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DateTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DateTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DateTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DateTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::ReportTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::ReportTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::ReportTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::ReportTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::ReportTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::ReportTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::ReportTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::iodef_1_0::ReportTime (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ReportTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ReportTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  ReportTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ReportTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ReportTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::DetectTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::DetectTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::DetectTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::DetectTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::DetectTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::DetectTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::DetectTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::iodef_1_0::DetectTime (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DetectTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DetectTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  DetectTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DetectTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DetectTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::StartTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::StartTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::StartTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::StartTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::StartTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::StartTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::StartTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::iodef_1_0::StartTime (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "StartTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "StartTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  StartTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "StartTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "StartTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::EndTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::EndTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::EndTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::EndTime (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::EndTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::EndTime (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::date_time > r (
      ::iodef_1_0::EndTime (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::iodef_1_0::EndTime (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EndTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EndTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::date_time >
  EndTime (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EndTime" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::date_time > r (
        ::xsd::cxx::tree::traits< ::xml_schema::date_time, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EndTime",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
      ::iodef_1_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
      ::iodef_1_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
      ::iodef_1_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Timezone (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Timezone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Timezone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Timezone (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Timezone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Timezone (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
      ::iodef_1_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
      ::iodef_1_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
      ::iodef_1_0::Timezone (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
        ::iodef_1_0::Timezone (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Timezone" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::TimezoneType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Timezone",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::TimezoneType >
  Timezone (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Timezone" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::TimezoneType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::TimezoneType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Timezone",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::History > r (
      ::iodef_1_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::History > r (
      ::iodef_1_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::History > r (
      ::iodef_1_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::History_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::History_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::History_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::History_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::History_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::History_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::History > r (
      ::iodef_1_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::History > r (
      ::iodef_1_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::History > r (
      ::iodef_1_0::History_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::History > r (
        ::iodef_1_0::History_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "History" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::History > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::History, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "History",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::History >
  History_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "History" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::History > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::History, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "History",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
      ::iodef_1_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
      ::iodef_1_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
      ::iodef_1_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::HistoryItem_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::HistoryItem_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::HistoryItem_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::HistoryItem_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::HistoryItem_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::HistoryItem_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
      ::iodef_1_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
      ::iodef_1_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
      ::iodef_1_0::HistoryItem_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
        ::iodef_1_0::HistoryItem_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "HistoryItem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::HistoryItem, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "HistoryItem",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::HistoryItem >
  HistoryItem_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "HistoryItem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::HistoryItem > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::HistoryItem, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "HistoryItem",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Expectation > r (
      ::iodef_1_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Expectation > r (
      ::iodef_1_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Expectation > r (
      ::iodef_1_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Expectation_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Expectation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Expectation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Expectation_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Expectation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Expectation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Expectation > r (
      ::iodef_1_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Expectation > r (
      ::iodef_1_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Expectation > r (
      ::iodef_1_0::Expectation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Expectation > r (
        ::iodef_1_0::Expectation_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Expectation" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Expectation > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Expectation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Expectation",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Expectation >
  Expectation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Expectation" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Expectation > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Expectation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Expectation",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Method > r (
      ::iodef_1_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Method > r (
      ::iodef_1_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Method > r (
      ::iodef_1_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Method_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Method_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Method_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Method_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Method_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Method_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Method > r (
      ::iodef_1_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Method > r (
      ::iodef_1_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Method > r (
      ::iodef_1_0::Method_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Method > r (
        ::iodef_1_0::Method_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Method" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Method > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Method, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Method",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Method >
  Method_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Method" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Method > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Method, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Method",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Reference > r (
      ::iodef_1_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Reference > r (
      ::iodef_1_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Reference > r (
      ::iodef_1_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Reference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Reference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Reference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Reference_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Reference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Reference_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Reference > r (
      ::iodef_1_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Reference > r (
      ::iodef_1_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Reference > r (
      ::iodef_1_0::Reference_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Reference > r (
        ::iodef_1_0::Reference_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Reference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Reference > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Reference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Reference",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Reference >
  Reference_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Reference" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Reference > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Reference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Reference",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Assessment > r (
      ::iodef_1_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Assessment > r (
      ::iodef_1_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Assessment > r (
      ::iodef_1_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Assessment_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Assessment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Assessment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Assessment_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Assessment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Assessment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Assessment > r (
      ::iodef_1_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Assessment > r (
      ::iodef_1_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Assessment > r (
      ::iodef_1_0::Assessment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Assessment > r (
        ::iodef_1_0::Assessment_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Assessment" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Assessment > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Assessment, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Assessment",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Assessment >
  Assessment_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Assessment" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Assessment > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Assessment, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Assessment",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Impact > r (
      ::iodef_1_0::Impact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Impact > r (
      ::iodef_1_0::Impact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Impact > r (
      ::iodef_1_0::Impact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Impact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Impact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Impact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Impact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Impact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Impact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Impact > r (
      ::iodef_1_0::Impact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Impact > r (
      ::iodef_1_0::Impact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Impact > r (
      ::iodef_1_0::Impact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Impact > r (
        ::iodef_1_0::Impact_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Impact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Impact > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Impact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Impact",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Impact >
  Impact_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Impact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Impact > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Impact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Impact",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
      ::iodef_1_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
      ::iodef_1_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
      ::iodef_1_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::TimeImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::TimeImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::TimeImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::TimeImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::TimeImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::TimeImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
      ::iodef_1_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
      ::iodef_1_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
      ::iodef_1_0::TimeImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
        ::iodef_1_0::TimeImpact_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "TimeImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::TimeImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "TimeImpact",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::TimeImpact >
  TimeImpact_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "TimeImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::TimeImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::TimeImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "TimeImpact",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
      ::iodef_1_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
      ::iodef_1_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
      ::iodef_1_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::MonetaryImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::MonetaryImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::MonetaryImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::MonetaryImpact_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::MonetaryImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::MonetaryImpact_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
      ::iodef_1_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
      ::iodef_1_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
      ::iodef_1_0::MonetaryImpact_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
        ::iodef_1_0::MonetaryImpact_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MonetaryImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::MonetaryImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MonetaryImpact",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::MonetaryImpact >
  MonetaryImpact_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "MonetaryImpact" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::MonetaryImpact > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::MonetaryImpact, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MonetaryImpact",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Confidence > r (
      ::iodef_1_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Confidence > r (
      ::iodef_1_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Confidence > r (
      ::iodef_1_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Confidence_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Confidence_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Confidence_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Confidence_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Confidence_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Confidence_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Confidence > r (
      ::iodef_1_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Confidence > r (
      ::iodef_1_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Confidence > r (
      ::iodef_1_0::Confidence_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Confidence > r (
        ::iodef_1_0::Confidence_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Confidence" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Confidence > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Confidence, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Confidence",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Confidence >
  Confidence_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Confidence" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Confidence > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Confidence, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Confidence",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::EventData > r (
      ::iodef_1_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::EventData > r (
      ::iodef_1_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::EventData > r (
      ::iodef_1_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::EventData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::EventData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::EventData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::EventData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::EventData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::EventData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::EventData > r (
      ::iodef_1_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::EventData > r (
      ::iodef_1_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::EventData > r (
      ::iodef_1_0::EventData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::EventData > r (
        ::iodef_1_0::EventData_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EventData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::EventData > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::EventData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EventData",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::EventData >
  EventData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EventData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::EventData > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::EventData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EventData",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Flow > r (
      ::iodef_1_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Flow > r (
      ::iodef_1_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Flow > r (
      ::iodef_1_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Flow_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Flow_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Flow_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Flow_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Flow_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Flow_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Flow > r (
      ::iodef_1_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Flow > r (
      ::iodef_1_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Flow > r (
      ::iodef_1_0::Flow_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Flow > r (
        ::iodef_1_0::Flow_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Flow" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Flow > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Flow, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Flow",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Flow >
  Flow_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Flow" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Flow > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Flow, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Flow",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::System > r (
      ::iodef_1_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::System > r (
      ::iodef_1_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::System > r (
      ::iodef_1_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::System_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::System_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::System_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::System_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::System_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::System_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::System > r (
      ::iodef_1_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::System > r (
      ::iodef_1_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::System > r (
      ::iodef_1_0::System_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::System > r (
        ::iodef_1_0::System_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "System" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::System > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::System, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "System",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::System >
  System_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "System" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::System > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::System, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "System",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Node > r (
      ::iodef_1_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Node > r (
      ::iodef_1_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Node > r (
      ::iodef_1_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Node_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Node_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Node_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Node_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Node_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Node_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Node > r (
      ::iodef_1_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Node > r (
      ::iodef_1_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Node > r (
      ::iodef_1_0::Node_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Node > r (
        ::iodef_1_0::Node_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Node" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Node > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Node, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Node",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Node >
  Node_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Node" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Node > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Node, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Node",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Address > r (
      ::iodef_1_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Address > r (
      ::iodef_1_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Address > r (
      ::iodef_1_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Address_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Address_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Address_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Address_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Address_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Address_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Address > r (
      ::iodef_1_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Address > r (
      ::iodef_1_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Address > r (
      ::iodef_1_0::Address_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Address > r (
        ::iodef_1_0::Address_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Address" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Address > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Address, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Address",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Address >
  Address_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Address" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Address > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Address, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Address",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Location (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Location (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Location (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Location (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Location (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Location (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Location (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::iodef_1_0::Location (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Location" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Location",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Location (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Location" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Location",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
      ::iodef_1_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
      ::iodef_1_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
      ::iodef_1_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::NodeRole_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::NodeRole_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::NodeRole_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::NodeRole_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::NodeRole_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::NodeRole_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
      ::iodef_1_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
      ::iodef_1_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
      ::iodef_1_0::NodeRole_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
        ::iodef_1_0::NodeRole_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "NodeRole" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::NodeRole, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "NodeRole",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::NodeRole >
  NodeRole_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "NodeRole" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::NodeRole > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::NodeRole, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "NodeRole",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Service > r (
      ::iodef_1_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Service > r (
      ::iodef_1_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Service > r (
      ::iodef_1_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Service_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Service_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Service_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Service_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Service_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Service_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Service > r (
      ::iodef_1_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Service > r (
      ::iodef_1_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Service > r (
      ::iodef_1_0::Service_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Service > r (
        ::iodef_1_0::Service_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Service" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Service > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Service, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Service",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Service >
  Service_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Service" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Service > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Service, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Service",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Counter > r (
      ::iodef_1_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Counter > r (
      ::iodef_1_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Counter > r (
      ::iodef_1_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Counter_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Counter_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Counter_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Counter_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Counter_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Counter_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Counter > r (
      ::iodef_1_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Counter > r (
      ::iodef_1_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Counter > r (
      ::iodef_1_0::Counter_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Counter > r (
        ::iodef_1_0::Counter_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Counter" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Counter > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Counter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Counter",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Counter >
  Counter_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Counter" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Counter > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Counter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Counter",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Record > r (
      ::iodef_1_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Record > r (
      ::iodef_1_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Record > r (
      ::iodef_1_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Record_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Record_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Record_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Record_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Record_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Record_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Record > r (
      ::iodef_1_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Record > r (
      ::iodef_1_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Record > r (
      ::iodef_1_0::Record_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Record > r (
        ::iodef_1_0::Record_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Record" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Record > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Record, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Record",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Record >
  Record_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Record" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Record > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Record, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Record",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::RecordData > r (
      ::iodef_1_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RecordData > r (
      ::iodef_1_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RecordData > r (
      ::iodef_1_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordData_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordData_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::RecordData > r (
      ::iodef_1_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RecordData > r (
      ::iodef_1_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RecordData > r (
      ::iodef_1_0::RecordData_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::RecordData > r (
        ::iodef_1_0::RecordData_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RecordData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::RecordData > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::RecordData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordData",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::RecordData >
  RecordData_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RecordData" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::RecordData > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::RecordData, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordData",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
      ::iodef_1_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
      ::iodef_1_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
      ::iodef_1_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordPattern_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordPattern_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordPattern_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
      ::iodef_1_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
      ::iodef_1_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
      ::iodef_1_0::RecordPattern_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
        ::iodef_1_0::RecordPattern_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RecordPattern" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::RecordPattern, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordPattern",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::RecordPattern >
  RecordPattern_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RecordPattern" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::RecordPattern > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::RecordPattern, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordPattern",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordItem (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordItem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::RecordItem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordItem (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordItem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::RecordItem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
      ::iodef_1_0::RecordItem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
        ::iodef_1_0::RecordItem (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RecordItem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordItem",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::ExtensionType >
  RecordItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RecordItem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::ExtensionType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::ExtensionType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RecordItem",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Application (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Application (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Application (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Application (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Application (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Application (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::Application (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
        ::iodef_1_0::Application (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Application" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::SoftwareType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Application",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  Application (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Application" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::SoftwareType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Application",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::OperatingSystem (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::OperatingSystem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::OperatingSystem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::OperatingSystem (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::OperatingSystem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::OperatingSystem (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
      ::iodef_1_0::OperatingSystem (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
        ::iodef_1_0::OperatingSystem (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "OperatingSystem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::SoftwareType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OperatingSystem",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::SoftwareType >
  OperatingSystem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "OperatingSystem" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::SoftwareType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::SoftwareType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OperatingSystem",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Description (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Description (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Description (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Description (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Description (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Description (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
      ::iodef_1_0::Description (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::iodef_1_0::Description (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Description" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Description",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::MLStringType >
  Description (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Description" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::MLStringType > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::MLStringType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Description",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::uri > r (
      ::iodef_1_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::uri > r (
      ::iodef_1_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::uri > r (
      ::iodef_1_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::URL (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::URL (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::URL (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::URL (isrc, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::URL (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::URL (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xml_schema::uri > r (
      ::iodef_1_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::uri > r (
      ::iodef_1_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xml_schema::uri > r (
      ::iodef_1_0::URL (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::iodef_1_0::URL (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "URL" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::uri > r (
        ::xsd::cxx::tree::traits< ::xml_schema::uri, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "URL",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::xml_schema::uri >
  URL (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "URL" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::xml_schema::uri > r (
        ::xsd::cxx::tree::traits< ::xml_schema::uri, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "URL",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

