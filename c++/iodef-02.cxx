// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "iodef-02.hxx"

namespace iodef_1_0
{
  // IncidentID
  // 

  const IncidentID::name_optional& IncidentID::
  name () const
  {
    return this->name_;
  }

  IncidentID::name_optional& IncidentID::
  name ()
  {
    return this->name_;
  }

  void IncidentID::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void IncidentID::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void IncidentID::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const IncidentID::instance_optional& IncidentID::
  instance () const
  {
    return this->instance_;
  }

  IncidentID::instance_optional& IncidentID::
  instance ()
  {
    return this->instance_;
  }

  void IncidentID::
  instance (const instance_type& x)
  {
    this->instance_.set (x);
  }

  void IncidentID::
  instance (const instance_optional& x)
  {
    this->instance_ = x;
  }

  void IncidentID::
  instance (::std::auto_ptr< instance_type > x)
  {
    this->instance_.set (x);
  }

  const IncidentID::restriction_optional& IncidentID::
  restriction () const
  {
    return this->restriction_;
  }

  IncidentID::restriction_optional& IncidentID::
  restriction ()
  {
    return this->restriction_;
  }

  void IncidentID::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void IncidentID::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void IncidentID::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Description
  // 

  const Description::lang_optional& Description::
  lang () const
  {
    return this->lang_;
  }

  Description::lang_optional& Description::
  lang ()
  {
    return this->lang_;
  }

  void Description::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void Description::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void Description::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // iodef_sci
  // 

  const iodef_sci::lang_optional& iodef_sci::
  lang () const
  {
    return this->lang_;
  }

  iodef_sci::lang_optional& iodef_sci::
  lang ()
  {
    return this->lang_;
  }

  void iodef_sci::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void iodef_sci::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void iodef_sci::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // IODEF_Document
  // 

  const IODEF_Document::Incident_sequence& IODEF_Document::
  Incident () const
  {
    return this->Incident_;
  }

  IODEF_Document::Incident_sequence& IODEF_Document::
  Incident ()
  {
    return this->Incident_;
  }

  void IODEF_Document::
  Incident (const Incident_sequence& s)
  {
    this->Incident_ = s;
  }

  const IODEF_Document::version_optional& IODEF_Document::
  version () const
  {
    return this->version_;
  }

  IODEF_Document::version_optional& IODEF_Document::
  version ()
  {
    return this->version_;
  }

  void IODEF_Document::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void IODEF_Document::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void IODEF_Document::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const IODEF_Document::lang_optional& IODEF_Document::
  lang () const
  {
    return this->lang_;
  }

  IODEF_Document::lang_optional& IODEF_Document::
  lang ()
  {
    return this->lang_;
  }

  void IODEF_Document::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void IODEF_Document::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void IODEF_Document::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const IODEF_Document::formatid_optional& IODEF_Document::
  formatid () const
  {
    return this->formatid_;
  }

  IODEF_Document::formatid_optional& IODEF_Document::
  formatid ()
  {
    return this->formatid_;
  }

  void IODEF_Document::
  formatid (const formatid_type& x)
  {
    this->formatid_.set (x);
  }

  void IODEF_Document::
  formatid (const formatid_optional& x)
  {
    this->formatid_ = x;
  }

  void IODEF_Document::
  formatid (::std::auto_ptr< formatid_type > x)
  {
    this->formatid_.set (x);
  }


  // NewDataSet
  // 

  const NewDataSet::IncidentID_sequence& NewDataSet::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  NewDataSet::IncidentID_sequence& NewDataSet::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void NewDataSet::
  IncidentID (const IncidentID_sequence& s)
  {
    this->IncidentID_ = s;
  }

  const NewDataSet::Description_sequence& NewDataSet::
  Description () const
  {
    return this->Description_;
  }

  NewDataSet::Description_sequence& NewDataSet::
  Description ()
  {
    return this->Description_;
  }

  void NewDataSet::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const NewDataSet::IODEF_Document_sequence& NewDataSet::
  IODEF_Document () const
  {
    return this->IODEF_Document_;
  }

  NewDataSet::IODEF_Document_sequence& NewDataSet::
  IODEF_Document ()
  {
    return this->IODEF_Document_;
  }

  void NewDataSet::
  IODEF_Document (const IODEF_Document_sequence& s)
  {
    this->IODEF_Document_ = s;
  }


  // Incident
  // 

  const Incident::DetectTime_optional& Incident::
  DetectTime () const
  {
    return this->DetectTime_;
  }

  Incident::DetectTime_optional& Incident::
  DetectTime ()
  {
    return this->DetectTime_;
  }

  void Incident::
  DetectTime (const DetectTime_type& x)
  {
    this->DetectTime_.set (x);
  }

  void Incident::
  DetectTime (const DetectTime_optional& x)
  {
    this->DetectTime_ = x;
  }

  void Incident::
  DetectTime (::std::auto_ptr< DetectTime_type > x)
  {
    this->DetectTime_.set (x);
  }

  const Incident::StartTime_optional& Incident::
  StartTime () const
  {
    return this->StartTime_;
  }

  Incident::StartTime_optional& Incident::
  StartTime ()
  {
    return this->StartTime_;
  }

  void Incident::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void Incident::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void Incident::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const Incident::EndTime_optional& Incident::
  EndTime () const
  {
    return this->EndTime_;
  }

  Incident::EndTime_optional& Incident::
  EndTime ()
  {
    return this->EndTime_;
  }

  void Incident::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void Incident::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void Incident::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const Incident::ReportTime_optional& Incident::
  ReportTime () const
  {
    return this->ReportTime_;
  }

  Incident::ReportTime_optional& Incident::
  ReportTime ()
  {
    return this->ReportTime_;
  }

  void Incident::
  ReportTime (const ReportTime_type& x)
  {
    this->ReportTime_.set (x);
  }

  void Incident::
  ReportTime (const ReportTime_optional& x)
  {
    this->ReportTime_ = x;
  }

  void Incident::
  ReportTime (::std::auto_ptr< ReportTime_type > x)
  {
    this->ReportTime_.set (x);
  }

  const Incident::IncidentID_sequence& Incident::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  Incident::IncidentID_sequence& Incident::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void Incident::
  IncidentID (const IncidentID_sequence& s)
  {
    this->IncidentID_ = s;
  }

  const Incident::AlternativeID_sequence& Incident::
  AlternativeID () const
  {
    return this->AlternativeID_;
  }

  Incident::AlternativeID_sequence& Incident::
  AlternativeID ()
  {
    return this->AlternativeID_;
  }

  void Incident::
  AlternativeID (const AlternativeID_sequence& s)
  {
    this->AlternativeID_ = s;
  }

  const Incident::RelatedActivity_sequence& Incident::
  RelatedActivity () const
  {
    return this->RelatedActivity_;
  }

  Incident::RelatedActivity_sequence& Incident::
  RelatedActivity ()
  {
    return this->RelatedActivity_;
  }

  void Incident::
  RelatedActivity (const RelatedActivity_sequence& s)
  {
    this->RelatedActivity_ = s;
  }

  const Incident::Description_sequence& Incident::
  Description () const
  {
    return this->Description_;
  }

  Incident::Description_sequence& Incident::
  Description ()
  {
    return this->Description_;
  }

  void Incident::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Incident::Assessment_sequence& Incident::
  Assessment () const
  {
    return this->Assessment_;
  }

  Incident::Assessment_sequence& Incident::
  Assessment ()
  {
    return this->Assessment_;
  }

  void Incident::
  Assessment (const Assessment_sequence& s)
  {
    this->Assessment_ = s;
  }

  const Incident::Method_sequence& Incident::
  Method () const
  {
    return this->Method_;
  }

  Incident::Method_sequence& Incident::
  Method ()
  {
    return this->Method_;
  }

  void Incident::
  Method (const Method_sequence& s)
  {
    this->Method_ = s;
  }

  const Incident::Contact_sequence& Incident::
  Contact () const
  {
    return this->Contact_;
  }

  Incident::Contact_sequence& Incident::
  Contact ()
  {
    return this->Contact_;
  }

  void Incident::
  Contact (const Contact_sequence& s)
  {
    this->Contact_ = s;
  }

  const Incident::EventData_sequence& Incident::
  EventData () const
  {
    return this->EventData_;
  }

  Incident::EventData_sequence& Incident::
  EventData ()
  {
    return this->EventData_;
  }

  void Incident::
  EventData (const EventData_sequence& s)
  {
    this->EventData_ = s;
  }

  const Incident::History_sequence& Incident::
  History () const
  {
    return this->History_;
  }

  Incident::History_sequence& Incident::
  History ()
  {
    return this->History_;
  }

  void Incident::
  History (const History_sequence& s)
  {
    this->History_ = s;
  }

  const Incident::purpose_optional& Incident::
  purpose () const
  {
    return this->purpose_;
  }

  Incident::purpose_optional& Incident::
  purpose ()
  {
    return this->purpose_;
  }

  void Incident::
  purpose (const purpose_type& x)
  {
    this->purpose_.set (x);
  }

  void Incident::
  purpose (const purpose_optional& x)
  {
    this->purpose_ = x;
  }

  void Incident::
  purpose (::std::auto_ptr< purpose_type > x)
  {
    this->purpose_.set (x);
  }

  const Incident::ext_purpose_optional& Incident::
  ext_purpose () const
  {
    return this->ext_purpose_;
  }

  Incident::ext_purpose_optional& Incident::
  ext_purpose ()
  {
    return this->ext_purpose_;
  }

  void Incident::
  ext_purpose (const ext_purpose_type& x)
  {
    this->ext_purpose_.set (x);
  }

  void Incident::
  ext_purpose (const ext_purpose_optional& x)
  {
    this->ext_purpose_ = x;
  }

  void Incident::
  ext_purpose (::std::auto_ptr< ext_purpose_type > x)
  {
    this->ext_purpose_.set (x);
  }

  const Incident::lang_optional& Incident::
  lang () const
  {
    return this->lang_;
  }

  Incident::lang_optional& Incident::
  lang ()
  {
    return this->lang_;
  }

  void Incident::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void Incident::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void Incident::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const Incident::restriction_optional& Incident::
  restriction () const
  {
    return this->restriction_;
  }

  Incident::restriction_optional& Incident::
  restriction ()
  {
    return this->restriction_;
  }

  void Incident::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Incident::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Incident::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // AlternativeID
  // 

  const AlternativeID::IncidentID_sequence& AlternativeID::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  AlternativeID::IncidentID_sequence& AlternativeID::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void AlternativeID::
  IncidentID (const IncidentID_sequence& s)
  {
    this->IncidentID_ = s;
  }

  const AlternativeID::restriction_optional& AlternativeID::
  restriction () const
  {
    return this->restriction_;
  }

  AlternativeID::restriction_optional& AlternativeID::
  restriction ()
  {
    return this->restriction_;
  }

  void AlternativeID::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void AlternativeID::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void AlternativeID::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // RelatedActivity
  // 

  const RelatedActivity::IncidentID_sequence& RelatedActivity::
  IncidentID () const
  {
    return this->IncidentID_;
  }

  RelatedActivity::IncidentID_sequence& RelatedActivity::
  IncidentID ()
  {
    return this->IncidentID_;
  }

  void RelatedActivity::
  IncidentID (const IncidentID_sequence& s)
  {
    this->IncidentID_ = s;
  }

  const RelatedActivity::restriction_optional& RelatedActivity::
  restriction () const
  {
    return this->restriction_;
  }

  RelatedActivity::restriction_optional& RelatedActivity::
  restriction ()
  {
    return this->restriction_;
  }

  void RelatedActivity::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void RelatedActivity::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void RelatedActivity::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Assessment
  // 

  const Assessment::Impact_sequence& Assessment::
  Impact () const
  {
    return this->Impact_;
  }

  Assessment::Impact_sequence& Assessment::
  Impact ()
  {
    return this->Impact_;
  }

  void Assessment::
  Impact (const Impact_sequence& s)
  {
    this->Impact_ = s;
  }

  const Assessment::TimeImpact_sequence& Assessment::
  TimeImpact () const
  {
    return this->TimeImpact_;
  }

  Assessment::TimeImpact_sequence& Assessment::
  TimeImpact ()
  {
    return this->TimeImpact_;
  }

  void Assessment::
  TimeImpact (const TimeImpact_sequence& s)
  {
    this->TimeImpact_ = s;
  }

  const Assessment::MonetaryImpact_sequence& Assessment::
  MonetaryImpact () const
  {
    return this->MonetaryImpact_;
  }

  Assessment::MonetaryImpact_sequence& Assessment::
  MonetaryImpact ()
  {
    return this->MonetaryImpact_;
  }

  void Assessment::
  MonetaryImpact (const MonetaryImpact_sequence& s)
  {
    this->MonetaryImpact_ = s;
  }

  const Assessment::Counter_sequence& Assessment::
  Counter () const
  {
    return this->Counter_;
  }

  Assessment::Counter_sequence& Assessment::
  Counter ()
  {
    return this->Counter_;
  }

  void Assessment::
  Counter (const Counter_sequence& s)
  {
    this->Counter_ = s;
  }

  const Assessment::Confidence_sequence& Assessment::
  Confidence () const
  {
    return this->Confidence_;
  }

  Assessment::Confidence_sequence& Assessment::
  Confidence ()
  {
    return this->Confidence_;
  }

  void Assessment::
  Confidence (const Confidence_sequence& s)
  {
    this->Confidence_ = s;
  }

  const Assessment::AdditionalData_sequence& Assessment::
  AdditionalData () const
  {
    return this->AdditionalData_;
  }

  Assessment::AdditionalData_sequence& Assessment::
  AdditionalData ()
  {
    return this->AdditionalData_;
  }

  void Assessment::
  AdditionalData (const AdditionalData_sequence& s)
  {
    this->AdditionalData_ = s;
  }

  const Assessment::occurrence_optional& Assessment::
  occurrence () const
  {
    return this->occurrence_;
  }

  Assessment::occurrence_optional& Assessment::
  occurrence ()
  {
    return this->occurrence_;
  }

  void Assessment::
  occurrence (const occurrence_type& x)
  {
    this->occurrence_.set (x);
  }

  void Assessment::
  occurrence (const occurrence_optional& x)
  {
    this->occurrence_ = x;
  }

  void Assessment::
  occurrence (::std::auto_ptr< occurrence_type > x)
  {
    this->occurrence_.set (x);
  }

  const Assessment::restriction_optional& Assessment::
  restriction () const
  {
    return this->restriction_;
  }

  Assessment::restriction_optional& Assessment::
  restriction ()
  {
    return this->restriction_;
  }

  void Assessment::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Assessment::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Assessment::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Method
  // 

  const Method::Reference_sequence& Method::
  Reference () const
  {
    return this->Reference_;
  }

  Method::Reference_sequence& Method::
  Reference ()
  {
    return this->Reference_;
  }

  void Method::
  Reference (const Reference_sequence& s)
  {
    this->Reference_ = s;
  }

  const Method::Description_sequence& Method::
  Description () const
  {
    return this->Description_;
  }

  Method::Description_sequence& Method::
  Description ()
  {
    return this->Description_;
  }

  void Method::
  Description (const Description_sequence& s)
  {
    this->Description_ = s;
  }

  const Method::restriction_optional& Method::
  restriction () const
  {
    return this->restriction_;
  }

  Method::restriction_optional& Method::
  restriction ()
  {
    return this->restriction_;
  }

  void Method::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Method::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Method::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Contact
  // 

  const Contact::Timezone_optional& Contact::
  Timezone () const
  {
    return this->Timezone_;
  }

  Contact::Timezone_optional& Contact::
  Timezone ()
  {
    return this->Timezone_;
  }

  void Contact::
  Timezone (const Timezone_type& x)
  {
    this->Timezone_.set (x);
  }

  void Contact::
  Timezone (const Timezone_optional& x)
  {
    this->Timezone_ = x;
  }

  void Contact::
  Timezone (::std::auto_ptr< Timezone_type > x)
  {
    this->Timezone_.set (x);
  }

  const Contact::ContactName_sequence& Contact::
  ContactName () const
  {
    return this->ContactName_;
  }

  Contact::ContactName_sequence& Contact::
  ContactName ()
  {
    return this->ContactName_;
  }

  void Contact::
  ContactName (const ContactName_sequence& s)
  {
    this->ContactName_ = s;
  }

  const Contact::RegistryHandle_sequence& Contact::
  RegistryHandle () const
  {
    return this->RegistryHandle_;
  }

  Contact::RegistryHandle_sequence& Contact::
  RegistryHandle ()
  {
    return this->RegistryHandle_;
  }

  void Contact::
  RegistryHandle (const RegistryHandle_sequence& s)
  {
    this->RegistryHandle_ = s;
  }

  const Contact::PostalAddress_sequence& Contact::
  PostalAddress () const
  {
    return this->PostalAddress_;
  }

  Contact::PostalAddress_sequence& Contact::
  PostalAddress ()
  {
    return this->PostalAddress_;
  }

  void Contact::
  PostalAddress (const PostalAddress_sequence& s)
  {
    this->PostalAddress_ = s;
  }

  const Contact::Email_sequence& Contact::
  Email () const
  {
    return this->Email_;
  }

  Contact::Email_sequence& Contact::
  Email ()
  {
    return this->Email_;
  }

  void Contact::
  Email (const Email_sequence& s)
  {
    this->Email_ = s;
  }

  const Contact::Telephone_sequence& Contact::
  Telephone () const
  {
    return this->Telephone_;
  }

  Contact::Telephone_sequence& Contact::
  Telephone ()
  {
    return this->Telephone_;
  }

  void Contact::
  Telephone (const Telephone_sequence& s)
  {
    this->Telephone_ = s;
  }

  const Contact::Fax_sequence& Contact::
  Fax () const
  {
    return this->Fax_;
  }

  Contact::Fax_sequence& Contact::
  Fax ()
  {
    return this->Fax_;
  }

  void Contact::
  Fax (const Fax_sequence& s)
  {
    this->Fax_ = s;
  }

  const Contact::role_optional& Contact::
  role () const
  {
    return this->role_;
  }

  Contact::role_optional& Contact::
  role ()
  {
    return this->role_;
  }

  void Contact::
  role (const role_type& x)
  {
    this->role_.set (x);
  }

  void Contact::
  role (const role_optional& x)
  {
    this->role_ = x;
  }

  void Contact::
  role (::std::auto_ptr< role_type > x)
  {
    this->role_.set (x);
  }

  const Contact::ext_role_optional& Contact::
  ext_role () const
  {
    return this->ext_role_;
  }

  Contact::ext_role_optional& Contact::
  ext_role ()
  {
    return this->ext_role_;
  }

  void Contact::
  ext_role (const ext_role_type& x)
  {
    this->ext_role_.set (x);
  }

  void Contact::
  ext_role (const ext_role_optional& x)
  {
    this->ext_role_ = x;
  }

  void Contact::
  ext_role (::std::auto_ptr< ext_role_type > x)
  {
    this->ext_role_.set (x);
  }

  const Contact::type_optional& Contact::
  type () const
  {
    return this->type_;
  }

  Contact::type_optional& Contact::
  type ()
  {
    return this->type_;
  }

  void Contact::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Contact::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void Contact::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const Contact::ext_type_optional& Contact::
  ext_type () const
  {
    return this->ext_type_;
  }

  Contact::ext_type_optional& Contact::
  ext_type ()
  {
    return this->ext_type_;
  }

  void Contact::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void Contact::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void Contact::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const Contact::restriction_optional& Contact::
  restriction () const
  {
    return this->restriction_;
  }

  Contact::restriction_optional& Contact::
  restriction ()
  {
    return this->restriction_;
  }

  void Contact::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Contact::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Contact::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // EventData
  // 

  const EventData::DetectTime_optional& EventData::
  DetectTime () const
  {
    return this->DetectTime_;
  }

  EventData::DetectTime_optional& EventData::
  DetectTime ()
  {
    return this->DetectTime_;
  }

  void EventData::
  DetectTime (const DetectTime_type& x)
  {
    this->DetectTime_.set (x);
  }

  void EventData::
  DetectTime (const DetectTime_optional& x)
  {
    this->DetectTime_ = x;
  }

  void EventData::
  DetectTime (::std::auto_ptr< DetectTime_type > x)
  {
    this->DetectTime_.set (x);
  }

  const EventData::StartTime_optional& EventData::
  StartTime () const
  {
    return this->StartTime_;
  }

  EventData::StartTime_optional& EventData::
  StartTime ()
  {
    return this->StartTime_;
  }

  void EventData::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void EventData::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void EventData::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const EventData::EndTime_optional& EventData::
  EndTime () const
  {
    return this->EndTime_;
  }

  EventData::EndTime_optional& EventData::
  EndTime ()
  {
    return this->EndTime_;
  }

  void EventData::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void EventData::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void EventData::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const EventData::Flow_sequence& EventData::
  Flow () const
  {
    return this->Flow_;
  }

  EventData::Flow_sequence& EventData::
  Flow ()
  {
    return this->Flow_;
  }

  void EventData::
  Flow (const Flow_sequence& s)
  {
    this->Flow_ = s;
  }

  const EventData::Expectation_sequence& EventData::
  Expectation () const
  {
    return this->Expectation_;
  }

  EventData::Expectation_sequence& EventData::
  Expectation ()
  {
    return this->Expectation_;
  }

  void EventData::
  Expectation (const Expectation_sequence& s)
  {
    this->Expectation_ = s;
  }

  const EventData::Record_sequence& EventData::
  Record () const
  {
    return this->Record_;
  }

  EventData::Record_sequence& EventData::
  Record ()
  {
    return this->Record_;
  }

  void EventData::
  Record (const Record_sequence& s)
  {
    this->Record_ = s;
  }

  const EventData::restriction_optional& EventData::
  restriction () const
  {
    return this->restriction_;
  }

  EventData::restriction_optional& EventData::
  restriction ()
  {
    return this->restriction_;
  }

  void EventData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void EventData::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void EventData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // History
  // 

  const History::HistoryItem_sequence& History::
  HistoryItem () const
  {
    return this->HistoryItem_;
  }

  History::HistoryItem_sequence& History::
  HistoryItem ()
  {
    return this->HistoryItem_;
  }

  void History::
  HistoryItem (const HistoryItem_sequence& s)
  {
    this->HistoryItem_ = s;
  }

  const History::restriction_optional& History::
  restriction () const
  {
    return this->restriction_;
  }

  History::restriction_optional& History::
  restriction ()
  {
    return this->restriction_;
  }

  void History::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void History::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void History::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Impact
  // 

  const Impact::severity_optional& Impact::
  severity () const
  {
    return this->severity_;
  }

  Impact::severity_optional& Impact::
  severity ()
  {
    return this->severity_;
  }

  void Impact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void Impact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void Impact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const Impact::completion_optional& Impact::
  completion () const
  {
    return this->completion_;
  }

  Impact::completion_optional& Impact::
  completion ()
  {
    return this->completion_;
  }

  void Impact::
  completion (const completion_type& x)
  {
    this->completion_.set (x);
  }

  void Impact::
  completion (const completion_optional& x)
  {
    this->completion_ = x;
  }

  void Impact::
  completion (::std::auto_ptr< completion_type > x)
  {
    this->completion_.set (x);
  }

  const Impact::type_optional& Impact::
  type () const
  {
    return this->type_;
  }

  Impact::type_optional& Impact::
  type ()
  {
    return this->type_;
  }

  void Impact::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Impact::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void Impact::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const Impact::ext_type_optional& Impact::
  ext_type () const
  {
    return this->ext_type_;
  }

  Impact::ext_type_optional& Impact::
  ext_type ()
  {
    return this->ext_type_;
  }

  void Impact::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void Impact::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void Impact::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const Impact::lang_optional& Impact::
  lang () const
  {
    return this->lang_;
  }

  Impact::lang_optional& Impact::
  lang ()
  {
    return this->lang_;
  }

  void Impact::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void Impact::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void Impact::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // TimeImpact
  // 

  const TimeImpact::severity_optional& TimeImpact::
  severity () const
  {
    return this->severity_;
  }

  TimeImpact::severity_optional& TimeImpact::
  severity ()
  {
    return this->severity_;
  }

  void TimeImpact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void TimeImpact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void TimeImpact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const TimeImpact::metric_optional& TimeImpact::
  metric () const
  {
    return this->metric_;
  }

  TimeImpact::metric_optional& TimeImpact::
  metric ()
  {
    return this->metric_;
  }

  void TimeImpact::
  metric (const metric_type& x)
  {
    this->metric_.set (x);
  }

  void TimeImpact::
  metric (const metric_optional& x)
  {
    this->metric_ = x;
  }

  void TimeImpact::
  metric (::std::auto_ptr< metric_type > x)
  {
    this->metric_.set (x);
  }

  const TimeImpact::ext_metric_optional& TimeImpact::
  ext_metric () const
  {
    return this->ext_metric_;
  }

  TimeImpact::ext_metric_optional& TimeImpact::
  ext_metric ()
  {
    return this->ext_metric_;
  }

  void TimeImpact::
  ext_metric (const ext_metric_type& x)
  {
    this->ext_metric_.set (x);
  }

  void TimeImpact::
  ext_metric (const ext_metric_optional& x)
  {
    this->ext_metric_ = x;
  }

  void TimeImpact::
  ext_metric (::std::auto_ptr< ext_metric_type > x)
  {
    this->ext_metric_.set (x);
  }

  const TimeImpact::duration_optional& TimeImpact::
  duration () const
  {
    return this->duration_;
  }

  TimeImpact::duration_optional& TimeImpact::
  duration ()
  {
    return this->duration_;
  }

  void TimeImpact::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void TimeImpact::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void TimeImpact::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }

  const TimeImpact::ext_duration_optional& TimeImpact::
  ext_duration () const
  {
    return this->ext_duration_;
  }

  TimeImpact::ext_duration_optional& TimeImpact::
  ext_duration ()
  {
    return this->ext_duration_;
  }

  void TimeImpact::
  ext_duration (const ext_duration_type& x)
  {
    this->ext_duration_.set (x);
  }

  void TimeImpact::
  ext_duration (const ext_duration_optional& x)
  {
    this->ext_duration_ = x;
  }

  void TimeImpact::
  ext_duration (::std::auto_ptr< ext_duration_type > x)
  {
    this->ext_duration_.set (x);
  }


  // MonetaryImpact
  // 

  const MonetaryImpact::severity_optional& MonetaryImpact::
  severity () const
  {
    return this->severity_;
  }

  MonetaryImpact::severity_optional& MonetaryImpact::
  severity ()
  {
    return this->severity_;
  }

  void MonetaryImpact::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void MonetaryImpact::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void MonetaryImpact::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const MonetaryImpact::currency_optional& MonetaryImpact::
  currency () const
  {
    return this->currency_;
  }

  MonetaryImpact::currency_optional& MonetaryImpact::
  currency ()
  {
    return this->currency_;
  }

  void MonetaryImpact::
  currency (const currency_type& x)
  {
    this->currency_.set (x);
  }

  void MonetaryImpact::
  currency (const currency_optional& x)
  {
    this->currency_ = x;
  }

  void MonetaryImpact::
  currency (::std::auto_ptr< currency_type > x)
  {
    this->currency_.set (x);
  }


  // Counter
  // 

  const Counter::type_optional& Counter::
  type () const
  {
    return this->type_;
  }

  Counter::type_optional& Counter::
  type ()
  {
    return this->type_;
  }

  void Counter::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void Counter::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void Counter::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const Counter::ext_type_optional& Counter::
  ext_type () const
  {
    return this->ext_type_;
  }

  Counter::ext_type_optional& Counter::
  ext_type ()
  {
    return this->ext_type_;
  }

  void Counter::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void Counter::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void Counter::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const Counter::meaning_optional& Counter::
  meaning () const
  {
    return this->meaning_;
  }

  Counter::meaning_optional& Counter::
  meaning ()
  {
    return this->meaning_;
  }

  void Counter::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void Counter::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void Counter::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }

  const Counter::duration_optional& Counter::
  duration () const
  {
    return this->duration_;
  }

  Counter::duration_optional& Counter::
  duration ()
  {
    return this->duration_;
  }

  void Counter::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void Counter::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void Counter::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }

  const Counter::ext_duration_optional& Counter::
  ext_duration () const
  {
    return this->ext_duration_;
  }

  Counter::ext_duration_optional& Counter::
  ext_duration ()
  {
    return this->ext_duration_;
  }

  void Counter::
  ext_duration (const ext_duration_type& x)
  {
    this->ext_duration_.set (x);
  }

  void Counter::
  ext_duration (const ext_duration_optional& x)
  {
    this->ext_duration_ = x;
  }

  void Counter::
  ext_duration (::std::auto_ptr< ext_duration_type > x)
  {
    this->ext_duration_.set (x);
  }


  // Confidence
  // 

  const Confidence::rating_optional& Confidence::
  rating () const
  {
    return this->rating_;
  }

  Confidence::rating_optional& Confidence::
  rating ()
  {
    return this->rating_;
  }

  void Confidence::
  rating (const rating_type& x)
  {
    this->rating_.set (x);
  }

  void Confidence::
  rating (const rating_optional& x)
  {
    this->rating_ = x;
  }

  void Confidence::
  rating (::std::auto_ptr< rating_type > x)
  {
    this->rating_.set (x);
  }


  // AdditionalData
  // 

  const AdditionalData::dtype_optional& AdditionalData::
  dtype () const
  {
    return this->dtype_;
  }

  AdditionalData::dtype_optional& AdditionalData::
  dtype ()
  {
    return this->dtype_;
  }

  void AdditionalData::
  dtype (const dtype_type& x)
  {
    this->dtype_.set (x);
  }

  void AdditionalData::
  dtype (const dtype_optional& x)
  {
    this->dtype_ = x;
  }

  void AdditionalData::
  dtype (::std::auto_ptr< dtype_type > x)
  {
    this->dtype_.set (x);
  }

  const AdditionalData::ext_dtype_optional& AdditionalData::
  ext_dtype () const
  {
    return this->ext_dtype_;
  }

  AdditionalData::ext_dtype_optional& AdditionalData::
  ext_dtype ()
  {
    return this->ext_dtype_;
  }

  void AdditionalData::
  ext_dtype (const ext_dtype_type& x)
  {
    this->ext_dtype_.set (x);
  }

  void AdditionalData::
  ext_dtype (const ext_dtype_optional& x)
  {
    this->ext_dtype_ = x;
  }

  void AdditionalData::
  ext_dtype (::std::auto_ptr< ext_dtype_type > x)
  {
    this->ext_dtype_.set (x);
  }

  const AdditionalData::meaning_optional& AdditionalData::
  meaning () const
  {
    return this->meaning_;
  }

  AdditionalData::meaning_optional& AdditionalData::
  meaning ()
  {
    return this->meaning_;
  }

  void AdditionalData::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void AdditionalData::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void AdditionalData::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }

  const AdditionalData::formatid_optional& AdditionalData::
  formatid () const
  {
    return this->formatid_;
  }

  AdditionalData::formatid_optional& AdditionalData::
  formatid ()
  {
    return this->formatid_;
  }

  void AdditionalData::
  formatid (const formatid_type& x)
  {
    this->formatid_.set (x);
  }

  void AdditionalData::
  formatid (const formatid_optional& x)
  {
    this->formatid_ = x;
  }

  void AdditionalData::
  formatid (::std::auto_ptr< formatid_type > x)
  {
    this->formatid_.set (x);
  }

  const AdditionalData::restriction_optional& AdditionalData::
  restriction () const
  {
    return this->restriction_;
  }

  AdditionalData::restriction_optional& AdditionalData::
  restriction ()
  {
    return this->restriction_;
  }

  void AdditionalData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void AdditionalData::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void AdditionalData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Reference
  // 

  const Reference::ReferenceName_sequence& Reference::
  ReferenceName () const
  {
    return this->ReferenceName_;
  }

  Reference::ReferenceName_sequence& Reference::
  ReferenceName ()
  {
    return this->ReferenceName_;
  }

  void Reference::
  ReferenceName (const ReferenceName_sequence& s)
  {
    this->ReferenceName_ = s;
  }

  const Reference::URL_sequence& Reference::
  URL () const
  {
    return this->URL_;
  }

  Reference::URL_sequence& Reference::
  URL ()
  {
    return this->URL_;
  }

  void Reference::
  URL (const URL_sequence& s)
  {
    this->URL_ = s;
  }


  // ContactName
  // 

  const ContactName::lang_optional& ContactName::
  lang () const
  {
    return this->lang_;
  }

  ContactName::lang_optional& ContactName::
  lang ()
  {
    return this->lang_;
  }

  void ContactName::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void ContactName::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void ContactName::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // RegistryHandle
  // 

  const RegistryHandle::registry_optional& RegistryHandle::
  registry () const
  {
    return this->registry_;
  }

  RegistryHandle::registry_optional& RegistryHandle::
  registry ()
  {
    return this->registry_;
  }

  void RegistryHandle::
  registry (const registry_type& x)
  {
    this->registry_.set (x);
  }

  void RegistryHandle::
  registry (const registry_optional& x)
  {
    this->registry_ = x;
  }

  void RegistryHandle::
  registry (::std::auto_ptr< registry_type > x)
  {
    this->registry_.set (x);
  }

  const RegistryHandle::ext_registry_optional& RegistryHandle::
  ext_registry () const
  {
    return this->ext_registry_;
  }

  RegistryHandle::ext_registry_optional& RegistryHandle::
  ext_registry ()
  {
    return this->ext_registry_;
  }

  void RegistryHandle::
  ext_registry (const ext_registry_type& x)
  {
    this->ext_registry_.set (x);
  }

  void RegistryHandle::
  ext_registry (const ext_registry_optional& x)
  {
    this->ext_registry_ = x;
  }

  void RegistryHandle::
  ext_registry (::std::auto_ptr< ext_registry_type > x)
  {
    this->ext_registry_.set (x);
  }


  // PostalAddress
  // 

  const PostalAddress::meaning_optional& PostalAddress::
  meaning () const
  {
    return this->meaning_;
  }

  PostalAddress::meaning_optional& PostalAddress::
  meaning ()
  {
    return this->meaning_;
  }

  void PostalAddress::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void PostalAddress::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void PostalAddress::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }

  const PostalAddress::lang_optional& PostalAddress::
  lang () const
  {
    return this->lang_;
  }

  PostalAddress::lang_optional& PostalAddress::
  lang ()
  {
    return this->lang_;
  }

  void PostalAddress::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void PostalAddress::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void PostalAddress::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // Email
  // 

  const Email::meaning_optional& Email::
  meaning () const
  {
    return this->meaning_;
  }

  Email::meaning_optional& Email::
  meaning ()
  {
    return this->meaning_;
  }

  void Email::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void Email::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void Email::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }


  // Telephone
  // 

  const Telephone::meaning_optional& Telephone::
  meaning () const
  {
    return this->meaning_;
  }

  Telephone::meaning_optional& Telephone::
  meaning ()
  {
    return this->meaning_;
  }

  void Telephone::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void Telephone::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void Telephone::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }


  // Fax
  // 

  const Fax::meaning_optional& Fax::
  meaning () const
  {
    return this->meaning_;
  }

  Fax::meaning_optional& Fax::
  meaning ()
  {
    return this->meaning_;
  }

  void Fax::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void Fax::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void Fax::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }


  // Flow
  // 

  const Flow::System_sequence& Flow::
  System () const
  {
    return this->System_;
  }

  Flow::System_sequence& Flow::
  System ()
  {
    return this->System_;
  }

  void Flow::
  System (const System_sequence& s)
  {
    this->System_ = s;
  }


  // Expectation
  // 

  const Expectation::StartTime_optional& Expectation::
  StartTime () const
  {
    return this->StartTime_;
  }

  Expectation::StartTime_optional& Expectation::
  StartTime ()
  {
    return this->StartTime_;
  }

  void Expectation::
  StartTime (const StartTime_type& x)
  {
    this->StartTime_.set (x);
  }

  void Expectation::
  StartTime (const StartTime_optional& x)
  {
    this->StartTime_ = x;
  }

  void Expectation::
  StartTime (::std::auto_ptr< StartTime_type > x)
  {
    this->StartTime_.set (x);
  }

  const Expectation::EndTime_optional& Expectation::
  EndTime () const
  {
    return this->EndTime_;
  }

  Expectation::EndTime_optional& Expectation::
  EndTime ()
  {
    return this->EndTime_;
  }

  void Expectation::
  EndTime (const EndTime_type& x)
  {
    this->EndTime_.set (x);
  }

  void Expectation::
  EndTime (const EndTime_optional& x)
  {
    this->EndTime_ = x;
  }

  void Expectation::
  EndTime (::std::auto_ptr< EndTime_type > x)
  {
    this->EndTime_.set (x);
  }

  const Expectation::restriction_optional& Expectation::
  restriction () const
  {
    return this->restriction_;
  }

  Expectation::restriction_optional& Expectation::
  restriction ()
  {
    return this->restriction_;
  }

  void Expectation::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Expectation::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Expectation::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const Expectation::severity_optional& Expectation::
  severity () const
  {
    return this->severity_;
  }

  Expectation::severity_optional& Expectation::
  severity ()
  {
    return this->severity_;
  }

  void Expectation::
  severity (const severity_type& x)
  {
    this->severity_.set (x);
  }

  void Expectation::
  severity (const severity_optional& x)
  {
    this->severity_ = x;
  }

  void Expectation::
  severity (::std::auto_ptr< severity_type > x)
  {
    this->severity_.set (x);
  }

  const Expectation::action_optional& Expectation::
  action () const
  {
    return this->action_;
  }

  Expectation::action_optional& Expectation::
  action ()
  {
    return this->action_;
  }

  void Expectation::
  action (const action_type& x)
  {
    this->action_.set (x);
  }

  void Expectation::
  action (const action_optional& x)
  {
    this->action_ = x;
  }

  void Expectation::
  action (::std::auto_ptr< action_type > x)
  {
    this->action_.set (x);
  }

  const Expectation::ext_action_optional& Expectation::
  ext_action () const
  {
    return this->ext_action_;
  }

  Expectation::ext_action_optional& Expectation::
  ext_action ()
  {
    return this->ext_action_;
  }

  void Expectation::
  ext_action (const ext_action_type& x)
  {
    this->ext_action_.set (x);
  }

  void Expectation::
  ext_action (const ext_action_optional& x)
  {
    this->ext_action_ = x;
  }

  void Expectation::
  ext_action (::std::auto_ptr< ext_action_type > x)
  {
    this->ext_action_.set (x);
  }


  // Record
  // 

  const Record::RecordData_sequence& Record::
  RecordData () const
  {
    return this->RecordData_;
  }

  Record::RecordData_sequence& Record::
  RecordData ()
  {
    return this->RecordData_;
  }

  void Record::
  RecordData (const RecordData_sequence& s)
  {
    this->RecordData_ = s;
  }

  const Record::restriction_optional& Record::
  restriction () const
  {
    return this->restriction_;
  }

  Record::restriction_optional& Record::
  restriction ()
  {
    return this->restriction_;
  }

  void Record::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void Record::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void Record::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // HistoryItem
  // 

  const HistoryItem::DateTime_optional& HistoryItem::
  DateTime () const
  {
    return this->DateTime_;
  }

  HistoryItem::DateTime_optional& HistoryItem::
  DateTime ()
  {
    return this->DateTime_;
  }

  void HistoryItem::
  DateTime (const DateTime_type& x)
  {
    this->DateTime_.set (x);
  }

  void HistoryItem::
  DateTime (const DateTime_optional& x)
  {
    this->DateTime_ = x;
  }

  void HistoryItem::
  DateTime (::std::auto_ptr< DateTime_type > x)
  {
    this->DateTime_.set (x);
  }

  const HistoryItem::restriction_optional& HistoryItem::
  restriction () const
  {
    return this->restriction_;
  }

  HistoryItem::restriction_optional& HistoryItem::
  restriction ()
  {
    return this->restriction_;
  }

  void HistoryItem::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void HistoryItem::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void HistoryItem::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const HistoryItem::action_optional& HistoryItem::
  action () const
  {
    return this->action_;
  }

  HistoryItem::action_optional& HistoryItem::
  action ()
  {
    return this->action_;
  }

  void HistoryItem::
  action (const action_type& x)
  {
    this->action_.set (x);
  }

  void HistoryItem::
  action (const action_optional& x)
  {
    this->action_ = x;
  }

  void HistoryItem::
  action (::std::auto_ptr< action_type > x)
  {
    this->action_.set (x);
  }

  const HistoryItem::ext_action_optional& HistoryItem::
  ext_action () const
  {
    return this->ext_action_;
  }

  HistoryItem::ext_action_optional& HistoryItem::
  ext_action ()
  {
    return this->ext_action_;
  }

  void HistoryItem::
  ext_action (const ext_action_type& x)
  {
    this->ext_action_.set (x);
  }

  void HistoryItem::
  ext_action (const ext_action_optional& x)
  {
    this->ext_action_ = x;
  }

  void HistoryItem::
  ext_action (::std::auto_ptr< ext_action_type > x)
  {
    this->ext_action_.set (x);
  }


  // ReferenceName
  // 

  const ReferenceName::lang_optional& ReferenceName::
  lang () const
  {
    return this->lang_;
  }

  ReferenceName::lang_optional& ReferenceName::
  lang ()
  {
    return this->lang_;
  }

  void ReferenceName::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void ReferenceName::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void ReferenceName::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // URL
  // 


  // System
  // 

  const System::Node_sequence& System::
  Node () const
  {
    return this->Node_;
  }

  System::Node_sequence& System::
  Node ()
  {
    return this->Node_;
  }

  void System::
  Node (const Node_sequence& s)
  {
    this->Node_ = s;
  }

  const System::Service_sequence& System::
  Service () const
  {
    return this->Service_;
  }

  System::Service_sequence& System::
  Service ()
  {
    return this->Service_;
  }

  void System::
  Service (const Service_sequence& s)
  {
    this->Service_ = s;
  }

  const System::OperatingSystem_sequence& System::
  OperatingSystem () const
  {
    return this->OperatingSystem_;
  }

  System::OperatingSystem_sequence& System::
  OperatingSystem ()
  {
    return this->OperatingSystem_;
  }

  void System::
  OperatingSystem (const OperatingSystem_sequence& s)
  {
    this->OperatingSystem_ = s;
  }

  const System::restriction_optional& System::
  restriction () const
  {
    return this->restriction_;
  }

  System::restriction_optional& System::
  restriction ()
  {
    return this->restriction_;
  }

  void System::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void System::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void System::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }

  const System::interface_optional& System::
  interface () const
  {
    return this->interface_;
  }

  System::interface_optional& System::
  interface ()
  {
    return this->interface_;
  }

  void System::
  interface (const interface_type& x)
  {
    this->interface_.set (x);
  }

  void System::
  interface (const interface_optional& x)
  {
    this->interface_ = x;
  }

  void System::
  interface (::std::auto_ptr< interface_type > x)
  {
    this->interface_.set (x);
  }

  const System::category_optional& System::
  category () const
  {
    return this->category_;
  }

  System::category_optional& System::
  category ()
  {
    return this->category_;
  }

  void System::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void System::
  category (const category_optional& x)
  {
    this->category_ = x;
  }

  void System::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const System::ext_category_optional& System::
  ext_category () const
  {
    return this->ext_category_;
  }

  System::ext_category_optional& System::
  ext_category ()
  {
    return this->ext_category_;
  }

  void System::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void System::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void System::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }

  const System::spoofed_optional& System::
  spoofed () const
  {
    return this->spoofed_;
  }

  System::spoofed_optional& System::
  spoofed ()
  {
    return this->spoofed_;
  }

  void System::
  spoofed (const spoofed_type& x)
  {
    this->spoofed_.set (x);
  }

  void System::
  spoofed (const spoofed_optional& x)
  {
    this->spoofed_ = x;
  }

  void System::
  spoofed (::std::auto_ptr< spoofed_type > x)
  {
    this->spoofed_.set (x);
  }


  // RecordData
  // 

  const RecordData::DateTime_optional& RecordData::
  DateTime () const
  {
    return this->DateTime_;
  }

  RecordData::DateTime_optional& RecordData::
  DateTime ()
  {
    return this->DateTime_;
  }

  void RecordData::
  DateTime (const DateTime_type& x)
  {
    this->DateTime_.set (x);
  }

  void RecordData::
  DateTime (const DateTime_optional& x)
  {
    this->DateTime_ = x;
  }

  void RecordData::
  DateTime (::std::auto_ptr< DateTime_type > x)
  {
    this->DateTime_.set (x);
  }

  const RecordData::RecordPattern_sequence& RecordData::
  RecordPattern () const
  {
    return this->RecordPattern_;
  }

  RecordData::RecordPattern_sequence& RecordData::
  RecordPattern ()
  {
    return this->RecordPattern_;
  }

  void RecordData::
  RecordPattern (const RecordPattern_sequence& s)
  {
    this->RecordPattern_ = s;
  }

  const RecordData::RecordItem_sequence& RecordData::
  RecordItem () const
  {
    return this->RecordItem_;
  }

  RecordData::RecordItem_sequence& RecordData::
  RecordItem ()
  {
    return this->RecordItem_;
  }

  void RecordData::
  RecordItem (const RecordItem_sequence& s)
  {
    this->RecordItem_ = s;
  }

  const RecordData::restriction_optional& RecordData::
  restriction () const
  {
    return this->restriction_;
  }

  RecordData::restriction_optional& RecordData::
  restriction ()
  {
    return this->restriction_;
  }

  void RecordData::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void RecordData::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void RecordData::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // Node
  // 

  const Node::Counter_optional& Node::
  Counter () const
  {
    return this->Counter_;
  }

  Node::Counter_optional& Node::
  Counter ()
  {
    return this->Counter_;
  }

  void Node::
  Counter (const Counter_type& x)
  {
    this->Counter_.set (x);
  }

  void Node::
  Counter (const Counter_optional& x)
  {
    this->Counter_ = x;
  }

  void Node::
  Counter (::std::auto_ptr< Counter_type > x)
  {
    this->Counter_.set (x);
  }

  const Node::DateTime_optional& Node::
  DateTime () const
  {
    return this->DateTime_;
  }

  Node::DateTime_optional& Node::
  DateTime ()
  {
    return this->DateTime_;
  }

  void Node::
  DateTime (const DateTime_type& x)
  {
    this->DateTime_.set (x);
  }

  void Node::
  DateTime (const DateTime_optional& x)
  {
    this->DateTime_ = x;
  }

  void Node::
  DateTime (::std::auto_ptr< DateTime_type > x)
  {
    this->DateTime_.set (x);
  }

  const Node::NodeName_sequence& Node::
  NodeName () const
  {
    return this->NodeName_;
  }

  Node::NodeName_sequence& Node::
  NodeName ()
  {
    return this->NodeName_;
  }

  void Node::
  NodeName (const NodeName_sequence& s)
  {
    this->NodeName_ = s;
  }

  const Node::Address_sequence& Node::
  Address () const
  {
    return this->Address_;
  }

  Node::Address_sequence& Node::
  Address ()
  {
    return this->Address_;
  }

  void Node::
  Address (const Address_sequence& s)
  {
    this->Address_ = s;
  }

  const Node::Location_sequence& Node::
  Location () const
  {
    return this->Location_;
  }

  Node::Location_sequence& Node::
  Location ()
  {
    return this->Location_;
  }

  void Node::
  Location (const Location_sequence& s)
  {
    this->Location_ = s;
  }

  const Node::NodeRole_sequence& Node::
  NodeRole () const
  {
    return this->NodeRole_;
  }

  Node::NodeRole_sequence& Node::
  NodeRole ()
  {
    return this->NodeRole_;
  }

  void Node::
  NodeRole (const NodeRole_sequence& s)
  {
    this->NodeRole_ = s;
  }


  // Service
  // 

  const Service::Port_optional& Service::
  Port () const
  {
    return this->Port_;
  }

  Service::Port_optional& Service::
  Port ()
  {
    return this->Port_;
  }

  void Service::
  Port (const Port_type& x)
  {
    this->Port_.set (x);
  }

  void Service::
  Port (const Port_optional& x)
  {
    this->Port_ = x;
  }

  void Service::
  Port (::std::auto_ptr< Port_type > x)
  {
    this->Port_.set (x);
  }

  const Service::Portlist_optional& Service::
  Portlist () const
  {
    return this->Portlist_;
  }

  Service::Portlist_optional& Service::
  Portlist ()
  {
    return this->Portlist_;
  }

  void Service::
  Portlist (const Portlist_type& x)
  {
    this->Portlist_.set (x);
  }

  void Service::
  Portlist (const Portlist_optional& x)
  {
    this->Portlist_ = x;
  }

  void Service::
  Portlist (::std::auto_ptr< Portlist_type > x)
  {
    this->Portlist_.set (x);
  }

  const Service::ProtoType_optional& Service::
  ProtoType () const
  {
    return this->ProtoType_;
  }

  Service::ProtoType_optional& Service::
  ProtoType ()
  {
    return this->ProtoType_;
  }

  void Service::
  ProtoType (const ProtoType_type& x)
  {
    this->ProtoType_.set (x);
  }

  void Service::
  ProtoType (const ProtoType_optional& x)
  {
    this->ProtoType_ = x;
  }

  void Service::
  ProtoType (::std::auto_ptr< ProtoType_type > x)
  {
    this->ProtoType_.set (x);
  }

  const Service::ProtoCode_optional& Service::
  ProtoCode () const
  {
    return this->ProtoCode_;
  }

  Service::ProtoCode_optional& Service::
  ProtoCode ()
  {
    return this->ProtoCode_;
  }

  void Service::
  ProtoCode (const ProtoCode_type& x)
  {
    this->ProtoCode_.set (x);
  }

  void Service::
  ProtoCode (const ProtoCode_optional& x)
  {
    this->ProtoCode_ = x;
  }

  void Service::
  ProtoCode (::std::auto_ptr< ProtoCode_type > x)
  {
    this->ProtoCode_.set (x);
  }

  const Service::ProtoField_optional& Service::
  ProtoField () const
  {
    return this->ProtoField_;
  }

  Service::ProtoField_optional& Service::
  ProtoField ()
  {
    return this->ProtoField_;
  }

  void Service::
  ProtoField (const ProtoField_type& x)
  {
    this->ProtoField_.set (x);
  }

  void Service::
  ProtoField (const ProtoField_optional& x)
  {
    this->ProtoField_ = x;
  }

  void Service::
  ProtoField (::std::auto_ptr< ProtoField_type > x)
  {
    this->ProtoField_.set (x);
  }

  const Service::Application_sequence& Service::
  Application () const
  {
    return this->Application_;
  }

  Service::Application_sequence& Service::
  Application ()
  {
    return this->Application_;
  }

  void Service::
  Application (const Application_sequence& s)
  {
    this->Application_ = s;
  }

  const Service::ip_protocol_optional& Service::
  ip_protocol () const
  {
    return this->ip_protocol_;
  }

  Service::ip_protocol_optional& Service::
  ip_protocol ()
  {
    return this->ip_protocol_;
  }

  void Service::
  ip_protocol (const ip_protocol_type& x)
  {
    this->ip_protocol_.set (x);
  }

  void Service::
  ip_protocol (const ip_protocol_optional& x)
  {
    this->ip_protocol_ = x;
  }

  void Service::
  ip_protocol (::std::auto_ptr< ip_protocol_type > x)
  {
    this->ip_protocol_.set (x);
  }


  // OperatingSystem
  // 

  const OperatingSystem::URL_optional& OperatingSystem::
  URL () const
  {
    return this->URL_;
  }

  OperatingSystem::URL_optional& OperatingSystem::
  URL ()
  {
    return this->URL_;
  }

  void OperatingSystem::
  URL (const URL_type& x)
  {
    this->URL_.set (x);
  }

  void OperatingSystem::
  URL (const URL_optional& x)
  {
    this->URL_ = x;
  }

  void OperatingSystem::
  URL (::std::auto_ptr< URL_type > x)
  {
    this->URL_.set (x);
  }

  const OperatingSystem::swid_optional& OperatingSystem::
  swid () const
  {
    return this->swid_;
  }

  OperatingSystem::swid_optional& OperatingSystem::
  swid ()
  {
    return this->swid_;
  }

  void OperatingSystem::
  swid (const swid_type& x)
  {
    this->swid_.set (x);
  }

  void OperatingSystem::
  swid (const swid_optional& x)
  {
    this->swid_ = x;
  }

  void OperatingSystem::
  swid (::std::auto_ptr< swid_type > x)
  {
    this->swid_.set (x);
  }

  const OperatingSystem::configid_optional& OperatingSystem::
  configid () const
  {
    return this->configid_;
  }

  OperatingSystem::configid_optional& OperatingSystem::
  configid ()
  {
    return this->configid_;
  }

  void OperatingSystem::
  configid (const configid_type& x)
  {
    this->configid_.set (x);
  }

  void OperatingSystem::
  configid (const configid_optional& x)
  {
    this->configid_ = x;
  }

  void OperatingSystem::
  configid (::std::auto_ptr< configid_type > x)
  {
    this->configid_.set (x);
  }

  const OperatingSystem::vendor_optional& OperatingSystem::
  vendor () const
  {
    return this->vendor_;
  }

  OperatingSystem::vendor_optional& OperatingSystem::
  vendor ()
  {
    return this->vendor_;
  }

  void OperatingSystem::
  vendor (const vendor_type& x)
  {
    this->vendor_.set (x);
  }

  void OperatingSystem::
  vendor (const vendor_optional& x)
  {
    this->vendor_ = x;
  }

  void OperatingSystem::
  vendor (::std::auto_ptr< vendor_type > x)
  {
    this->vendor_.set (x);
  }

  const OperatingSystem::family_optional& OperatingSystem::
  family () const
  {
    return this->family_;
  }

  OperatingSystem::family_optional& OperatingSystem::
  family ()
  {
    return this->family_;
  }

  void OperatingSystem::
  family (const family_type& x)
  {
    this->family_.set (x);
  }

  void OperatingSystem::
  family (const family_optional& x)
  {
    this->family_ = x;
  }

  void OperatingSystem::
  family (::std::auto_ptr< family_type > x)
  {
    this->family_.set (x);
  }

  const OperatingSystem::name_optional& OperatingSystem::
  name () const
  {
    return this->name_;
  }

  OperatingSystem::name_optional& OperatingSystem::
  name ()
  {
    return this->name_;
  }

  void OperatingSystem::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void OperatingSystem::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void OperatingSystem::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const OperatingSystem::version_optional& OperatingSystem::
  version () const
  {
    return this->version_;
  }

  OperatingSystem::version_optional& OperatingSystem::
  version ()
  {
    return this->version_;
  }

  void OperatingSystem::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void OperatingSystem::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void OperatingSystem::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const OperatingSystem::patch_optional& OperatingSystem::
  patch () const
  {
    return this->patch_;
  }

  OperatingSystem::patch_optional& OperatingSystem::
  patch ()
  {
    return this->patch_;
  }

  void OperatingSystem::
  patch (const patch_type& x)
  {
    this->patch_.set (x);
  }

  void OperatingSystem::
  patch (const patch_optional& x)
  {
    this->patch_ = x;
  }

  void OperatingSystem::
  patch (::std::auto_ptr< patch_type > x)
  {
    this->patch_.set (x);
  }


  // RecordPattern
  // 

  const RecordPattern::type_optional& RecordPattern::
  type () const
  {
    return this->type_;
  }

  RecordPattern::type_optional& RecordPattern::
  type ()
  {
    return this->type_;
  }

  void RecordPattern::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void RecordPattern::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void RecordPattern::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const RecordPattern::ext_type_optional& RecordPattern::
  ext_type () const
  {
    return this->ext_type_;
  }

  RecordPattern::ext_type_optional& RecordPattern::
  ext_type ()
  {
    return this->ext_type_;
  }

  void RecordPattern::
  ext_type (const ext_type_type& x)
  {
    this->ext_type_.set (x);
  }

  void RecordPattern::
  ext_type (const ext_type_optional& x)
  {
    this->ext_type_ = x;
  }

  void RecordPattern::
  ext_type (::std::auto_ptr< ext_type_type > x)
  {
    this->ext_type_.set (x);
  }

  const RecordPattern::offset_optional& RecordPattern::
  offset () const
  {
    return this->offset_;
  }

  RecordPattern::offset_optional& RecordPattern::
  offset ()
  {
    return this->offset_;
  }

  void RecordPattern::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void RecordPattern::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  void RecordPattern::
  offset (::std::auto_ptr< offset_type > x)
  {
    this->offset_.set (x);
  }

  const RecordPattern::offsetunit_optional& RecordPattern::
  offsetunit () const
  {
    return this->offsetunit_;
  }

  RecordPattern::offsetunit_optional& RecordPattern::
  offsetunit ()
  {
    return this->offsetunit_;
  }

  void RecordPattern::
  offsetunit (const offsetunit_type& x)
  {
    this->offsetunit_.set (x);
  }

  void RecordPattern::
  offsetunit (const offsetunit_optional& x)
  {
    this->offsetunit_ = x;
  }

  void RecordPattern::
  offsetunit (::std::auto_ptr< offsetunit_type > x)
  {
    this->offsetunit_.set (x);
  }

  const RecordPattern::ext_offsetunit_optional& RecordPattern::
  ext_offsetunit () const
  {
    return this->ext_offsetunit_;
  }

  RecordPattern::ext_offsetunit_optional& RecordPattern::
  ext_offsetunit ()
  {
    return this->ext_offsetunit_;
  }

  void RecordPattern::
  ext_offsetunit (const ext_offsetunit_type& x)
  {
    this->ext_offsetunit_.set (x);
  }

  void RecordPattern::
  ext_offsetunit (const ext_offsetunit_optional& x)
  {
    this->ext_offsetunit_ = x;
  }

  void RecordPattern::
  ext_offsetunit (::std::auto_ptr< ext_offsetunit_type > x)
  {
    this->ext_offsetunit_.set (x);
  }

  const RecordPattern::instance_optional& RecordPattern::
  instance () const
  {
    return this->instance_;
  }

  RecordPattern::instance_optional& RecordPattern::
  instance ()
  {
    return this->instance_;
  }

  void RecordPattern::
  instance (const instance_type& x)
  {
    this->instance_.set (x);
  }

  void RecordPattern::
  instance (const instance_optional& x)
  {
    this->instance_ = x;
  }

  void RecordPattern::
  instance (::std::auto_ptr< instance_type > x)
  {
    this->instance_.set (x);
  }


  // RecordItem
  // 

  const RecordItem::dtype_optional& RecordItem::
  dtype () const
  {
    return this->dtype_;
  }

  RecordItem::dtype_optional& RecordItem::
  dtype ()
  {
    return this->dtype_;
  }

  void RecordItem::
  dtype (const dtype_type& x)
  {
    this->dtype_.set (x);
  }

  void RecordItem::
  dtype (const dtype_optional& x)
  {
    this->dtype_ = x;
  }

  void RecordItem::
  dtype (::std::auto_ptr< dtype_type > x)
  {
    this->dtype_.set (x);
  }

  const RecordItem::ext_dtype_optional& RecordItem::
  ext_dtype () const
  {
    return this->ext_dtype_;
  }

  RecordItem::ext_dtype_optional& RecordItem::
  ext_dtype ()
  {
    return this->ext_dtype_;
  }

  void RecordItem::
  ext_dtype (const ext_dtype_type& x)
  {
    this->ext_dtype_.set (x);
  }

  void RecordItem::
  ext_dtype (const ext_dtype_optional& x)
  {
    this->ext_dtype_ = x;
  }

  void RecordItem::
  ext_dtype (::std::auto_ptr< ext_dtype_type > x)
  {
    this->ext_dtype_.set (x);
  }

  const RecordItem::meaning_optional& RecordItem::
  meaning () const
  {
    return this->meaning_;
  }

  RecordItem::meaning_optional& RecordItem::
  meaning ()
  {
    return this->meaning_;
  }

  void RecordItem::
  meaning (const meaning_type& x)
  {
    this->meaning_.set (x);
  }

  void RecordItem::
  meaning (const meaning_optional& x)
  {
    this->meaning_ = x;
  }

  void RecordItem::
  meaning (::std::auto_ptr< meaning_type > x)
  {
    this->meaning_.set (x);
  }

  const RecordItem::formatid_optional& RecordItem::
  formatid () const
  {
    return this->formatid_;
  }

  RecordItem::formatid_optional& RecordItem::
  formatid ()
  {
    return this->formatid_;
  }

  void RecordItem::
  formatid (const formatid_type& x)
  {
    this->formatid_.set (x);
  }

  void RecordItem::
  formatid (const formatid_optional& x)
  {
    this->formatid_ = x;
  }

  void RecordItem::
  formatid (::std::auto_ptr< formatid_type > x)
  {
    this->formatid_.set (x);
  }

  const RecordItem::restriction_optional& RecordItem::
  restriction () const
  {
    return this->restriction_;
  }

  RecordItem::restriction_optional& RecordItem::
  restriction ()
  {
    return this->restriction_;
  }

  void RecordItem::
  restriction (const restriction_type& x)
  {
    this->restriction_.set (x);
  }

  void RecordItem::
  restriction (const restriction_optional& x)
  {
    this->restriction_ = x;
  }

  void RecordItem::
  restriction (::std::auto_ptr< restriction_type > x)
  {
    this->restriction_.set (x);
  }


  // NodeName
  // 

  const NodeName::lang_optional& NodeName::
  lang () const
  {
    return this->lang_;
  }

  NodeName::lang_optional& NodeName::
  lang ()
  {
    return this->lang_;
  }

  void NodeName::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void NodeName::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void NodeName::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // Address
  // 

  const Address::category_optional& Address::
  category () const
  {
    return this->category_;
  }

  Address::category_optional& Address::
  category ()
  {
    return this->category_;
  }

  void Address::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void Address::
  category (const category_optional& x)
  {
    this->category_ = x;
  }

  void Address::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const Address::ext_category_optional& Address::
  ext_category () const
  {
    return this->ext_category_;
  }

  Address::ext_category_optional& Address::
  ext_category ()
  {
    return this->ext_category_;
  }

  void Address::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void Address::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void Address::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }

  const Address::vlan_name_optional& Address::
  vlan_name () const
  {
    return this->vlan_name_;
  }

  Address::vlan_name_optional& Address::
  vlan_name ()
  {
    return this->vlan_name_;
  }

  void Address::
  vlan_name (const vlan_name_type& x)
  {
    this->vlan_name_.set (x);
  }

  void Address::
  vlan_name (const vlan_name_optional& x)
  {
    this->vlan_name_ = x;
  }

  void Address::
  vlan_name (::std::auto_ptr< vlan_name_type > x)
  {
    this->vlan_name_.set (x);
  }

  const Address::vlan_num_optional& Address::
  vlan_num () const
  {
    return this->vlan_num_;
  }

  Address::vlan_num_optional& Address::
  vlan_num ()
  {
    return this->vlan_num_;
  }

  void Address::
  vlan_num (const vlan_num_type& x)
  {
    this->vlan_num_.set (x);
  }

  void Address::
  vlan_num (const vlan_num_optional& x)
  {
    this->vlan_num_ = x;
  }

  void Address::
  vlan_num (::std::auto_ptr< vlan_num_type > x)
  {
    this->vlan_num_.set (x);
  }


  // Location
  // 

  const Location::lang_optional& Location::
  lang () const
  {
    return this->lang_;
  }

  Location::lang_optional& Location::
  lang ()
  {
    return this->lang_;
  }

  void Location::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void Location::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void Location::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // NodeRole
  // 

  const NodeRole::category_optional& NodeRole::
  category () const
  {
    return this->category_;
  }

  NodeRole::category_optional& NodeRole::
  category ()
  {
    return this->category_;
  }

  void NodeRole::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void NodeRole::
  category (const category_optional& x)
  {
    this->category_ = x;
  }

  void NodeRole::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }

  const NodeRole::ext_category_optional& NodeRole::
  ext_category () const
  {
    return this->ext_category_;
  }

  NodeRole::ext_category_optional& NodeRole::
  ext_category ()
  {
    return this->ext_category_;
  }

  void NodeRole::
  ext_category (const ext_category_type& x)
  {
    this->ext_category_.set (x);
  }

  void NodeRole::
  ext_category (const ext_category_optional& x)
  {
    this->ext_category_ = x;
  }

  void NodeRole::
  ext_category (::std::auto_ptr< ext_category_type > x)
  {
    this->ext_category_.set (x);
  }

  const NodeRole::lang_optional& NodeRole::
  lang () const
  {
    return this->lang_;
  }

  NodeRole::lang_optional& NodeRole::
  lang ()
  {
    return this->lang_;
  }

  void NodeRole::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void NodeRole::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void NodeRole::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // Application
  // 

  const Application::URL_optional& Application::
  URL () const
  {
    return this->URL_;
  }

  Application::URL_optional& Application::
  URL ()
  {
    return this->URL_;
  }

  void Application::
  URL (const URL_type& x)
  {
    this->URL_.set (x);
  }

  void Application::
  URL (const URL_optional& x)
  {
    this->URL_ = x;
  }

  void Application::
  URL (::std::auto_ptr< URL_type > x)
  {
    this->URL_.set (x);
  }

  const Application::swid_optional& Application::
  swid () const
  {
    return this->swid_;
  }

  Application::swid_optional& Application::
  swid ()
  {
    return this->swid_;
  }

  void Application::
  swid (const swid_type& x)
  {
    this->swid_.set (x);
  }

  void Application::
  swid (const swid_optional& x)
  {
    this->swid_ = x;
  }

  void Application::
  swid (::std::auto_ptr< swid_type > x)
  {
    this->swid_.set (x);
  }

  const Application::configid_optional& Application::
  configid () const
  {
    return this->configid_;
  }

  Application::configid_optional& Application::
  configid ()
  {
    return this->configid_;
  }

  void Application::
  configid (const configid_type& x)
  {
    this->configid_.set (x);
  }

  void Application::
  configid (const configid_optional& x)
  {
    this->configid_ = x;
  }

  void Application::
  configid (::std::auto_ptr< configid_type > x)
  {
    this->configid_.set (x);
  }

  const Application::vendor_optional& Application::
  vendor () const
  {
    return this->vendor_;
  }

  Application::vendor_optional& Application::
  vendor ()
  {
    return this->vendor_;
  }

  void Application::
  vendor (const vendor_type& x)
  {
    this->vendor_.set (x);
  }

  void Application::
  vendor (const vendor_optional& x)
  {
    this->vendor_ = x;
  }

  void Application::
  vendor (::std::auto_ptr< vendor_type > x)
  {
    this->vendor_.set (x);
  }

  const Application::family_optional& Application::
  family () const
  {
    return this->family_;
  }

  Application::family_optional& Application::
  family ()
  {
    return this->family_;
  }

  void Application::
  family (const family_type& x)
  {
    this->family_.set (x);
  }

  void Application::
  family (const family_optional& x)
  {
    this->family_ = x;
  }

  void Application::
  family (::std::auto_ptr< family_type > x)
  {
    this->family_.set (x);
  }

  const Application::name_optional& Application::
  name () const
  {
    return this->name_;
  }

  Application::name_optional& Application::
  name ()
  {
    return this->name_;
  }

  void Application::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Application::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void Application::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Application::version_optional& Application::
  version () const
  {
    return this->version_;
  }

  Application::version_optional& Application::
  version ()
  {
    return this->version_;
  }

  void Application::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void Application::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void Application::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const Application::patch_optional& Application::
  patch () const
  {
    return this->patch_;
  }

  Application::patch_optional& Application::
  patch ()
  {
    return this->patch_;
  }

  void Application::
  patch (const patch_type& x)
  {
    this->patch_.set (x);
  }

  void Application::
  patch (const patch_optional& x)
  {
    this->patch_ = x;
  }

  void Application::
  patch (::std::auto_ptr< patch_type > x)
  {
    this->patch_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace iodef_1_0
{
  // IncidentID
  //

  IncidentID::
  IncidentID ()
  : ::xml_schema::string (),
    name_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  IncidentID::
  IncidentID (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    name_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  IncidentID::
  IncidentID (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    name_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  IncidentID::
  IncidentID (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    name_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  IncidentID::
  IncidentID (const IncidentID& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    name_ (x.name_, f, this),
    instance_ (x.instance_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  IncidentID::
  IncidentID (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    instance_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void IncidentID::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "instance" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< instance_type > r (
          instance_traits::create (i, f, this));

        this->instance_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  IncidentID* IncidentID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IncidentID (*this, f, c);
  }

  IncidentID::
  ~IncidentID ()
  {
  }

  // Description
  //

  Description::
  Description ()
  : ::xml_schema::string (),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Description::
  Description (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Description::
  Description (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Description::
  Description (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Description::
  Description (const Description& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    lang_ (x.lang_, f, this)
  {
  }

  Description::
  Description (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Description::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  Description* Description::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Description (*this, f, c);
  }

  Description::
  ~Description ()
  {
  }

  // iodef_sci
  //

  iodef_sci::
  iodef_sci ()
  : ::xml_schema::string (),
    lang_ (::xml_schema::flags (), this)
  {
  }

  iodef_sci::
  iodef_sci (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  iodef_sci::
  iodef_sci (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  iodef_sci::
  iodef_sci (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  iodef_sci::
  iodef_sci (const iodef_sci& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    lang_ (x.lang_, f, this)
  {
  }

  iodef_sci::
  iodef_sci (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void iodef_sci::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  iodef_sci* iodef_sci::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class iodef_sci (*this, f, c);
  }

  iodef_sci::
  ~iodef_sci ()
  {
  }

  // IODEF_Document
  //

  IODEF_Document::
  IODEF_Document ()
  : ::xml_schema::type (),
    Incident_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this)
  {
  }

  IODEF_Document::
  IODEF_Document (const IODEF_Document& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Incident_ (x.Incident_, f, this),
    version_ (x.version_, f, this),
    lang_ (x.lang_, f, this),
    formatid_ (x.formatid_, f, this)
  {
  }

  IODEF_Document::
  IODEF_Document (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Incident_ (f, this),
    version_ (f, this),
    lang_ (f, this),
    formatid_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void IODEF_Document::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Incident
      //
      if (n.name () == "Incident" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Incident_type > r (
          Incident_traits::create (i, f, this));

        this->Incident_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }

      if (n.name () == "formatid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatid_type > r (
          formatid_traits::create (i, f, this));

        this->formatid_.set (r);
        continue;
      }
    }
  }

  IODEF_Document* IODEF_Document::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IODEF_Document (*this, f, c);
  }

  IODEF_Document::
  ~IODEF_Document ()
  {
  }

  // NewDataSet
  //

  NewDataSet::
  NewDataSet ()
  : ::xml_schema::type (),
    IncidentID_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    IODEF_Document_ (::xml_schema::flags (), this)
  {
  }

  NewDataSet::
  NewDataSet (const NewDataSet& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    Description_ (x.Description_, f, this),
    IODEF_Document_ (x.IODEF_Document_, f, this)
  {
  }

  NewDataSet::
  NewDataSet (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (f, this),
    Description_ (f, this),
    IODEF_Document_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void NewDataSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        this->IncidentID_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // IODEF-Document
      //
      if (n.name () == "IODEF-Document" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IODEF_Document_type > r (
          IODEF_Document_traits::create (i, f, this));

        this->IODEF_Document_.push_back (r);
        continue;
      }

      break;
    }
  }

  NewDataSet* NewDataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NewDataSet (*this, f, c);
  }

  NewDataSet::
  ~NewDataSet ()
  {
  }

  // Incident
  //

  Incident::
  Incident ()
  : ::xml_schema::type (),
    DetectTime_ (::xml_schema::flags (), this),
    StartTime_ (::xml_schema::flags (), this),
    EndTime_ (::xml_schema::flags (), this),
    ReportTime_ (::xml_schema::flags (), this),
    IncidentID_ (::xml_schema::flags (), this),
    AlternativeID_ (::xml_schema::flags (), this),
    RelatedActivity_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    Assessment_ (::xml_schema::flags (), this),
    Method_ (::xml_schema::flags (), this),
    Contact_ (::xml_schema::flags (), this),
    EventData_ (::xml_schema::flags (), this),
    History_ (::xml_schema::flags (), this),
    purpose_ (::xml_schema::flags (), this),
    ext_purpose_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Incident::
  Incident (const Incident& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DetectTime_ (x.DetectTime_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    ReportTime_ (x.ReportTime_, f, this),
    IncidentID_ (x.IncidentID_, f, this),
    AlternativeID_ (x.AlternativeID_, f, this),
    RelatedActivity_ (x.RelatedActivity_, f, this),
    Description_ (x.Description_, f, this),
    Assessment_ (x.Assessment_, f, this),
    Method_ (x.Method_, f, this),
    Contact_ (x.Contact_, f, this),
    EventData_ (x.EventData_, f, this),
    History_ (x.History_, f, this),
    purpose_ (x.purpose_, f, this),
    ext_purpose_ (x.ext_purpose_, f, this),
    lang_ (x.lang_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Incident::
  Incident (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DetectTime_ (f, this),
    StartTime_ (f, this),
    EndTime_ (f, this),
    ReportTime_ (f, this),
    IncidentID_ (f, this),
    AlternativeID_ (f, this),
    RelatedActivity_ (f, this),
    Description_ (f, this),
    Assessment_ (f, this),
    Method_ (f, this),
    Contact_ (f, this),
    EventData_ (f, this),
    History_ (f, this),
    purpose_ (f, this),
    ext_purpose_ (f, this),
    lang_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Incident::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DetectTime
      //
      if (n.name () == "DetectTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DetectTime_type > r (
          DetectTime_traits::create (i, f, this));

        if (!this->DetectTime_)
        {
          this->DetectTime_.set (r);
          continue;
        }
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // ReportTime
      //
      if (n.name () == "ReportTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ReportTime_type > r (
          ReportTime_traits::create (i, f, this));

        if (!this->ReportTime_)
        {
          this->ReportTime_.set (r);
          continue;
        }
      }

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        this->IncidentID_.push_back (r);
        continue;
      }

      // AlternativeID
      //
      if (n.name () == "AlternativeID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AlternativeID_type > r (
          AlternativeID_traits::create (i, f, this));

        this->AlternativeID_.push_back (r);
        continue;
      }

      // RelatedActivity
      //
      if (n.name () == "RelatedActivity" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RelatedActivity_type > r (
          RelatedActivity_traits::create (i, f, this));

        this->RelatedActivity_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      // Assessment
      //
      if (n.name () == "Assessment" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Assessment_type > r (
          Assessment_traits::create (i, f, this));

        this->Assessment_.push_back (r);
        continue;
      }

      // Method
      //
      if (n.name () == "Method" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Method_type > r (
          Method_traits::create (i, f, this));

        this->Method_.push_back (r);
        continue;
      }

      // Contact
      //
      if (n.name () == "Contact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Contact_type > r (
          Contact_traits::create (i, f, this));

        this->Contact_.push_back (r);
        continue;
      }

      // EventData
      //
      if (n.name () == "EventData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EventData_type > r (
          EventData_traits::create (i, f, this));

        this->EventData_.push_back (r);
        continue;
      }

      // History
      //
      if (n.name () == "History" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< History_type > r (
          History_traits::create (i, f, this));

        this->History_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "purpose" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< purpose_type > r (
          purpose_traits::create (i, f, this));

        this->purpose_.set (r);
        continue;
      }

      if (n.name () == "ext-purpose" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_purpose_type > r (
          ext_purpose_traits::create (i, f, this));

        this->ext_purpose_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  Incident* Incident::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Incident (*this, f, c);
  }

  Incident::
  ~Incident ()
  {
  }

  // AlternativeID
  //

  AlternativeID::
  AlternativeID ()
  : ::xml_schema::type (),
    IncidentID_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  AlternativeID::
  AlternativeID (const AlternativeID& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  AlternativeID::
  AlternativeID (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void AlternativeID::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        this->IncidentID_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  AlternativeID* AlternativeID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlternativeID (*this, f, c);
  }

  AlternativeID::
  ~AlternativeID ()
  {
  }

  // RelatedActivity
  //

  RelatedActivity::
  RelatedActivity ()
  : ::xml_schema::type (),
    IncidentID_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  RelatedActivity::
  RelatedActivity (const RelatedActivity& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    IncidentID_ (x.IncidentID_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  RelatedActivity::
  RelatedActivity (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    IncidentID_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RelatedActivity::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IncidentID
      //
      if (n.name () == "IncidentID" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< IncidentID_type > r (
          IncidentID_traits::create (i, f, this));

        this->IncidentID_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  RelatedActivity* RelatedActivity::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RelatedActivity (*this, f, c);
  }

  RelatedActivity::
  ~RelatedActivity ()
  {
  }

  // Assessment
  //

  Assessment::
  Assessment ()
  : ::xml_schema::type (),
    Impact_ (::xml_schema::flags (), this),
    TimeImpact_ (::xml_schema::flags (), this),
    MonetaryImpact_ (::xml_schema::flags (), this),
    Counter_ (::xml_schema::flags (), this),
    Confidence_ (::xml_schema::flags (), this),
    AdditionalData_ (::xml_schema::flags (), this),
    occurrence_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Assessment::
  Assessment (const Assessment& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Impact_ (x.Impact_, f, this),
    TimeImpact_ (x.TimeImpact_, f, this),
    MonetaryImpact_ (x.MonetaryImpact_, f, this),
    Counter_ (x.Counter_, f, this),
    Confidence_ (x.Confidence_, f, this),
    AdditionalData_ (x.AdditionalData_, f, this),
    occurrence_ (x.occurrence_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Assessment::
  Assessment (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Impact_ (f, this),
    TimeImpact_ (f, this),
    MonetaryImpact_ (f, this),
    Counter_ (f, this),
    Confidence_ (f, this),
    AdditionalData_ (f, this),
    occurrence_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Assessment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Impact
      //
      if (n.name () == "Impact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Impact_type > r (
          Impact_traits::create (i, f, this));

        this->Impact_.push_back (r);
        continue;
      }

      // TimeImpact
      //
      if (n.name () == "TimeImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< TimeImpact_type > r (
          TimeImpact_traits::create (i, f, this));

        this->TimeImpact_.push_back (r);
        continue;
      }

      // MonetaryImpact
      //
      if (n.name () == "MonetaryImpact" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< MonetaryImpact_type > r (
          MonetaryImpact_traits::create (i, f, this));

        this->MonetaryImpact_.push_back (r);
        continue;
      }

      // Counter
      //
      if (n.name () == "Counter" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Counter_type > r (
          Counter_traits::create (i, f, this));

        this->Counter_.push_back (r);
        continue;
      }

      // Confidence
      //
      if (n.name () == "Confidence" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Confidence_type > r (
          Confidence_traits::create (i, f, this));

        this->Confidence_.push_back (r);
        continue;
      }

      // AdditionalData
      //
      if (n.name () == "AdditionalData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< AdditionalData_type > r (
          AdditionalData_traits::create (i, f, this));

        this->AdditionalData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "occurrence" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< occurrence_type > r (
          occurrence_traits::create (i, f, this));

        this->occurrence_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  Assessment* Assessment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Assessment (*this, f, c);
  }

  Assessment::
  ~Assessment ()
  {
  }

  // Method
  //

  Method::
  Method ()
  : ::xml_schema::type (),
    Reference_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Method::
  Method (const Method& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Reference_ (x.Reference_, f, this),
    Description_ (x.Description_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Method::
  Method (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Reference_ (f, this),
    Description_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Method::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Reference
      //
      if (n.name () == "Reference" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Reference_type > r (
          Reference_traits::create (i, f, this));

        this->Reference_.push_back (r);
        continue;
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        this->Description_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  Method* Method::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Method (*this, f, c);
  }

  Method::
  ~Method ()
  {
  }

  // Contact
  //

  Contact::
  Contact ()
  : ::xml_schema::type (),
    Timezone_ (::xml_schema::flags (), this),
    ContactName_ (::xml_schema::flags (), this),
    RegistryHandle_ (::xml_schema::flags (), this),
    PostalAddress_ (::xml_schema::flags (), this),
    Email_ (::xml_schema::flags (), this),
    Telephone_ (::xml_schema::flags (), this),
    Fax_ (::xml_schema::flags (), this),
    role_ (::xml_schema::flags (), this),
    ext_role_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Contact::
  Contact (const Contact& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Timezone_ (x.Timezone_, f, this),
    ContactName_ (x.ContactName_, f, this),
    RegistryHandle_ (x.RegistryHandle_, f, this),
    PostalAddress_ (x.PostalAddress_, f, this),
    Email_ (x.Email_, f, this),
    Telephone_ (x.Telephone_, f, this),
    Fax_ (x.Fax_, f, this),
    role_ (x.role_, f, this),
    ext_role_ (x.ext_role_, f, this),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Contact::
  Contact (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Timezone_ (f, this),
    ContactName_ (f, this),
    RegistryHandle_ (f, this),
    PostalAddress_ (f, this),
    Email_ (f, this),
    Telephone_ (f, this),
    Fax_ (f, this),
    role_ (f, this),
    ext_role_ (f, this),
    type_ (f, this),
    ext_type_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Contact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Timezone
      //
      if (n.name () == "Timezone" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Timezone_type > r (
          Timezone_traits::create (i, f, this));

        if (!this->Timezone_)
        {
          this->Timezone_.set (r);
          continue;
        }
      }

      // ContactName
      //
      if (n.name () == "ContactName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ContactName_type > r (
          ContactName_traits::create (i, f, this));

        this->ContactName_.push_back (r);
        continue;
      }

      // RegistryHandle
      //
      if (n.name () == "RegistryHandle" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RegistryHandle_type > r (
          RegistryHandle_traits::create (i, f, this));

        this->RegistryHandle_.push_back (r);
        continue;
      }

      // PostalAddress
      //
      if (n.name () == "PostalAddress" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< PostalAddress_type > r (
          PostalAddress_traits::create (i, f, this));

        this->PostalAddress_.push_back (r);
        continue;
      }

      // Email
      //
      if (n.name () == "Email" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Email_type > r (
          Email_traits::create (i, f, this));

        this->Email_.push_back (r);
        continue;
      }

      // Telephone
      //
      if (n.name () == "Telephone" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Telephone_type > r (
          Telephone_traits::create (i, f, this));

        this->Telephone_.push_back (r);
        continue;
      }

      // Fax
      //
      if (n.name () == "Fax" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Fax_type > r (
          Fax_traits::create (i, f, this));

        this->Fax_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "role" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< role_type > r (
          role_traits::create (i, f, this));

        this->role_.set (r);
        continue;
      }

      if (n.name () == "ext-role" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_role_type > r (
          ext_role_traits::create (i, f, this));

        this->ext_role_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_type_type > r (
          ext_type_traits::create (i, f, this));

        this->ext_type_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  Contact* Contact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Contact (*this, f, c);
  }

  Contact::
  ~Contact ()
  {
  }

  // EventData
  //

  EventData::
  EventData ()
  : ::xml_schema::type (),
    DetectTime_ (::xml_schema::flags (), this),
    StartTime_ (::xml_schema::flags (), this),
    EndTime_ (::xml_schema::flags (), this),
    Flow_ (::xml_schema::flags (), this),
    Expectation_ (::xml_schema::flags (), this),
    Record_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  EventData::
  EventData (const EventData& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DetectTime_ (x.DetectTime_, f, this),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    Flow_ (x.Flow_, f, this),
    Expectation_ (x.Expectation_, f, this),
    Record_ (x.Record_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  EventData::
  EventData (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DetectTime_ (f, this),
    StartTime_ (f, this),
    EndTime_ (f, this),
    Flow_ (f, this),
    Expectation_ (f, this),
    Record_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void EventData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DetectTime
      //
      if (n.name () == "DetectTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DetectTime_type > r (
          DetectTime_traits::create (i, f, this));

        if (!this->DetectTime_)
        {
          this->DetectTime_.set (r);
          continue;
        }
      }

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      // Flow
      //
      if (n.name () == "Flow" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Flow_type > r (
          Flow_traits::create (i, f, this));

        this->Flow_.push_back (r);
        continue;
      }

      // Expectation
      //
      if (n.name () == "Expectation" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Expectation_type > r (
          Expectation_traits::create (i, f, this));

        this->Expectation_.push_back (r);
        continue;
      }

      // Record
      //
      if (n.name () == "Record" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Record_type > r (
          Record_traits::create (i, f, this));

        this->Record_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  EventData* EventData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EventData (*this, f, c);
  }

  EventData::
  ~EventData ()
  {
  }

  // History
  //

  History::
  History ()
  : ::xml_schema::type (),
    HistoryItem_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  History::
  History (const History& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    HistoryItem_ (x.HistoryItem_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  History::
  History (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    HistoryItem_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void History::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HistoryItem
      //
      if (n.name () == "HistoryItem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< HistoryItem_type > r (
          HistoryItem_traits::create (i, f, this));

        this->HistoryItem_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  History* History::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class History (*this, f, c);
  }

  History::
  ~History ()
  {
  }

  // Impact
  //

  Impact::
  Impact ()
  : ::xml_schema::string (),
    severity_ (::xml_schema::flags (), this),
    completion_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Impact::
  Impact (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    completion_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Impact::
  Impact (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    completion_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Impact::
  Impact (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    completion_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Impact::
  Impact (const Impact& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    severity_ (x.severity_, f, this),
    completion_ (x.completion_, f, this),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  Impact::
  Impact (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    severity_ (f, this),
    completion_ (f, this),
    type_ (f, this),
    ext_type_ (f, this),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Impact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< severity_type > r (
          severity_traits::create (i, f, this));

        this->severity_.set (r);
        continue;
      }

      if (n.name () == "completion" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< completion_type > r (
          completion_traits::create (i, f, this));

        this->completion_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_type_type > r (
          ext_type_traits::create (i, f, this));

        this->ext_type_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  Impact* Impact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Impact (*this, f, c);
  }

  Impact::
  ~Impact ()
  {
  }

  // TimeImpact
  //

  TimeImpact::
  TimeImpact ()
  : ::xml_schema::string (),
    severity_ (::xml_schema::flags (), this),
    metric_ (::xml_schema::flags (), this),
    ext_metric_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  TimeImpact::
  TimeImpact (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    metric_ (::xml_schema::flags (), this),
    ext_metric_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  TimeImpact::
  TimeImpact (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    metric_ (::xml_schema::flags (), this),
    ext_metric_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  TimeImpact::
  TimeImpact (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    metric_ (::xml_schema::flags (), this),
    ext_metric_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  TimeImpact::
  TimeImpact (const TimeImpact& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    severity_ (x.severity_, f, this),
    metric_ (x.metric_, f, this),
    ext_metric_ (x.ext_metric_, f, this),
    duration_ (x.duration_, f, this),
    ext_duration_ (x.ext_duration_, f, this)
  {
  }

  TimeImpact::
  TimeImpact (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    severity_ (f, this),
    metric_ (f, this),
    ext_metric_ (f, this),
    duration_ (f, this),
    ext_duration_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void TimeImpact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< severity_type > r (
          severity_traits::create (i, f, this));

        this->severity_.set (r);
        continue;
      }

      if (n.name () == "metric" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< metric_type > r (
          metric_traits::create (i, f, this));

        this->metric_.set (r);
        continue;
      }

      if (n.name () == "ext-metric" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_metric_type > r (
          ext_metric_traits::create (i, f, this));

        this->ext_metric_.set (r);
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        this->duration_.set (r);
        continue;
      }

      if (n.name () == "ext-duration" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_duration_type > r (
          ext_duration_traits::create (i, f, this));

        this->ext_duration_.set (r);
        continue;
      }
    }
  }

  TimeImpact* TimeImpact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TimeImpact (*this, f, c);
  }

  TimeImpact::
  ~TimeImpact ()
  {
  }

  // MonetaryImpact
  //

  MonetaryImpact::
  MonetaryImpact ()
  : ::xml_schema::string (),
    severity_ (::xml_schema::flags (), this),
    currency_ (::xml_schema::flags (), this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    currency_ (::xml_schema::flags (), this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    currency_ (::xml_schema::flags (), this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    severity_ (::xml_schema::flags (), this),
    currency_ (::xml_schema::flags (), this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const MonetaryImpact& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    severity_ (x.severity_, f, this),
    currency_ (x.currency_, f, this)
  {
  }

  MonetaryImpact::
  MonetaryImpact (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    severity_ (f, this),
    currency_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MonetaryImpact::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< severity_type > r (
          severity_traits::create (i, f, this));

        this->severity_.set (r);
        continue;
      }

      if (n.name () == "currency" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< currency_type > r (
          currency_traits::create (i, f, this));

        this->currency_.set (r);
        continue;
      }
    }
  }

  MonetaryImpact* MonetaryImpact::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MonetaryImpact (*this, f, c);
  }

  MonetaryImpact::
  ~MonetaryImpact ()
  {
  }

  // Counter
  //

  Counter::
  Counter ()
  : ::xml_schema::string (),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  Counter::
  Counter (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  Counter::
  Counter (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  Counter::
  Counter (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    ext_duration_ (::xml_schema::flags (), this)
  {
  }

  Counter::
  Counter (const Counter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    meaning_ (x.meaning_, f, this),
    duration_ (x.duration_, f, this),
    ext_duration_ (x.ext_duration_, f, this)
  {
  }

  Counter::
  Counter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    ext_type_ (f, this),
    meaning_ (f, this),
    duration_ (f, this),
    ext_duration_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Counter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_type_type > r (
          ext_type_traits::create (i, f, this));

        this->ext_type_.set (r);
        continue;
      }

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        this->duration_.set (r);
        continue;
      }

      if (n.name () == "ext-duration" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_duration_type > r (
          ext_duration_traits::create (i, f, this));

        this->ext_duration_.set (r);
        continue;
      }
    }
  }

  Counter* Counter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Counter (*this, f, c);
  }

  Counter::
  ~Counter ()
  {
  }

  // Confidence
  //

  Confidence::
  Confidence ()
  : ::xml_schema::string (),
    rating_ (::xml_schema::flags (), this)
  {
  }

  Confidence::
  Confidence (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    rating_ (::xml_schema::flags (), this)
  {
  }

  Confidence::
  Confidence (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    rating_ (::xml_schema::flags (), this)
  {
  }

  Confidence::
  Confidence (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    rating_ (::xml_schema::flags (), this)
  {
  }

  Confidence::
  Confidence (const Confidence& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    rating_ (x.rating_, f, this)
  {
  }

  Confidence::
  Confidence (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    rating_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Confidence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "rating" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rating_type > r (
          rating_traits::create (i, f, this));

        this->rating_.set (r);
        continue;
      }
    }
  }

  Confidence* Confidence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Confidence (*this, f, c);
  }

  Confidence::
  ~Confidence ()
  {
  }

  // AdditionalData
  //

  AdditionalData::
  AdditionalData ()
  : ::xml_schema::string (),
    dtype_ (::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  AdditionalData::
  AdditionalData (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    dtype_ (::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  AdditionalData::
  AdditionalData (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    dtype_ (::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  AdditionalData::
  AdditionalData (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    dtype_ (::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  AdditionalData::
  AdditionalData (const AdditionalData& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    dtype_ (x.dtype_, f, this),
    ext_dtype_ (x.ext_dtype_, f, this),
    meaning_ (x.meaning_, f, this),
    formatid_ (x.formatid_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  AdditionalData::
  AdditionalData (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    dtype_ (f, this),
    ext_dtype_ (f, this),
    meaning_ (f, this),
    formatid_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void AdditionalData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dtype_type > r (
          dtype_traits::create (i, f, this));

        this->dtype_.set (r);
        continue;
      }

      if (n.name () == "ext-dtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_dtype_type > r (
          ext_dtype_traits::create (i, f, this));

        this->ext_dtype_.set (r);
        continue;
      }

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }

      if (n.name () == "formatid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatid_type > r (
          formatid_traits::create (i, f, this));

        this->formatid_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  AdditionalData* AdditionalData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AdditionalData (*this, f, c);
  }

  AdditionalData::
  ~AdditionalData ()
  {
  }

  // Reference
  //

  Reference::
  Reference ()
  : ::xml_schema::type (),
    ReferenceName_ (::xml_schema::flags (), this),
    URL_ (::xml_schema::flags (), this)
  {
  }

  Reference::
  Reference (const Reference& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ReferenceName_ (x.ReferenceName_, f, this),
    URL_ (x.URL_, f, this)
  {
  }

  Reference::
  Reference (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ReferenceName_ (f, this),
    URL_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Reference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReferenceName
      //
      if (n.name () == "ReferenceName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ReferenceName_type > r (
          ReferenceName_traits::create (i, f, this));

        this->ReferenceName_.push_back (r);
        continue;
      }

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        this->URL_.push_back (r);
        continue;
      }

      break;
    }
  }

  Reference* Reference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Reference (*this, f, c);
  }

  Reference::
  ~Reference ()
  {
  }

  // ContactName
  //

  ContactName::
  ContactName ()
  : ::xml_schema::string (),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ContactName::
  ContactName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ContactName::
  ContactName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ContactName::
  ContactName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ContactName::
  ContactName (const ContactName& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    lang_ (x.lang_, f, this)
  {
  }

  ContactName::
  ContactName (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ContactName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  ContactName* ContactName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ContactName (*this, f, c);
  }

  ContactName::
  ~ContactName ()
  {
  }

  // RegistryHandle
  //

  RegistryHandle::
  RegistryHandle ()
  : ::xml_schema::string (),
    registry_ (::xml_schema::flags (), this),
    ext_registry_ (::xml_schema::flags (), this)
  {
  }

  RegistryHandle::
  RegistryHandle (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (::xml_schema::flags (), this),
    ext_registry_ (::xml_schema::flags (), this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (::xml_schema::flags (), this),
    ext_registry_ (::xml_schema::flags (), this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    registry_ (::xml_schema::flags (), this),
    ext_registry_ (::xml_schema::flags (), this)
  {
  }

  RegistryHandle::
  RegistryHandle (const RegistryHandle& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    registry_ (x.registry_, f, this),
    ext_registry_ (x.ext_registry_, f, this)
  {
  }

  RegistryHandle::
  RegistryHandle (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    registry_ (f, this),
    ext_registry_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void RegistryHandle::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "registry" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< registry_type > r (
          registry_traits::create (i, f, this));

        this->registry_.set (r);
        continue;
      }

      if (n.name () == "ext-registry" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_registry_type > r (
          ext_registry_traits::create (i, f, this));

        this->ext_registry_.set (r);
        continue;
      }
    }
  }

  RegistryHandle* RegistryHandle::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RegistryHandle (*this, f, c);
  }

  RegistryHandle::
  ~RegistryHandle ()
  {
  }

  // PostalAddress
  //

  PostalAddress::
  PostalAddress ()
  : ::xml_schema::string (),
    meaning_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  PostalAddress::
  PostalAddress (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  PostalAddress::
  PostalAddress (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  PostalAddress::
  PostalAddress (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  PostalAddress::
  PostalAddress (const PostalAddress& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    meaning_ (x.meaning_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  PostalAddress::
  PostalAddress (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    meaning_ (f, this),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void PostalAddress::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  PostalAddress* PostalAddress::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PostalAddress (*this, f, c);
  }

  PostalAddress::
  ~PostalAddress ()
  {
  }

  // Email
  //

  Email::
  Email ()
  : ::xml_schema::string (),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Email::
  Email (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Email::
  Email (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Email::
  Email (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Email::
  Email (const Email& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    meaning_ (x.meaning_, f, this)
  {
  }

  Email::
  Email (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    meaning_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Email::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }
    }
  }

  Email* Email::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Email (*this, f, c);
  }

  Email::
  ~Email ()
  {
  }

  // Telephone
  //

  Telephone::
  Telephone ()
  : ::xml_schema::string (),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Telephone::
  Telephone (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Telephone::
  Telephone (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Telephone::
  Telephone (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Telephone::
  Telephone (const Telephone& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    meaning_ (x.meaning_, f, this)
  {
  }

  Telephone::
  Telephone (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    meaning_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Telephone::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }
    }
  }

  Telephone* Telephone::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Telephone (*this, f, c);
  }

  Telephone::
  ~Telephone ()
  {
  }

  // Fax
  //

  Fax::
  Fax ()
  : ::xml_schema::string (),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Fax::
  Fax (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Fax::
  Fax (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Fax::
  Fax (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    meaning_ (::xml_schema::flags (), this)
  {
  }

  Fax::
  Fax (const Fax& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    meaning_ (x.meaning_, f, this)
  {
  }

  Fax::
  Fax (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    meaning_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Fax::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }
    }
  }

  Fax* Fax::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Fax (*this, f, c);
  }

  Fax::
  ~Fax ()
  {
  }

  // Flow
  //

  Flow::
  Flow ()
  : ::xml_schema::type (),
    System_ (::xml_schema::flags (), this)
  {
  }

  Flow::
  Flow (const Flow& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    System_ (x.System_, f, this)
  {
  }

  Flow::
  Flow (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    System_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Flow::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // System
      //
      if (n.name () == "System" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< System_type > r (
          System_traits::create (i, f, this));

        this->System_.push_back (r);
        continue;
      }

      break;
    }
  }

  Flow* Flow::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Flow (*this, f, c);
  }

  Flow::
  ~Flow ()
  {
  }

  // Expectation
  //

  Expectation::
  Expectation ()
  : ::xml_schema::type (),
    StartTime_ (::xml_schema::flags (), this),
    EndTime_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this),
    severity_ (::xml_schema::flags (), this),
    action_ (::xml_schema::flags (), this),
    ext_action_ (::xml_schema::flags (), this)
  {
  }

  Expectation::
  Expectation (const Expectation& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    StartTime_ (x.StartTime_, f, this),
    EndTime_ (x.EndTime_, f, this),
    restriction_ (x.restriction_, f, this),
    severity_ (x.severity_, f, this),
    action_ (x.action_, f, this),
    ext_action_ (x.ext_action_, f, this)
  {
  }

  Expectation::
  Expectation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    StartTime_ (f, this),
    EndTime_ (f, this),
    restriction_ (f, this),
    severity_ (f, this),
    action_ (f, this),
    ext_action_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Expectation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StartTime
      //
      if (n.name () == "StartTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< StartTime_type > r (
          StartTime_traits::create (i, f, this));

        if (!this->StartTime_)
        {
          this->StartTime_.set (r);
          continue;
        }
      }

      // EndTime
      //
      if (n.name () == "EndTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< EndTime_type > r (
          EndTime_traits::create (i, f, this));

        if (!this->EndTime_)
        {
          this->EndTime_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }

      if (n.name () == "severity" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< severity_type > r (
          severity_traits::create (i, f, this));

        this->severity_.set (r);
        continue;
      }

      if (n.name () == "action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< action_type > r (
          action_traits::create (i, f, this));

        this->action_.set (r);
        continue;
      }

      if (n.name () == "ext-action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_action_type > r (
          ext_action_traits::create (i, f, this));

        this->ext_action_.set (r);
        continue;
      }
    }
  }

  Expectation* Expectation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Expectation (*this, f, c);
  }

  Expectation::
  ~Expectation ()
  {
  }

  // Record
  //

  Record::
  Record ()
  : ::xml_schema::type (),
    RecordData_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  Record::
  Record (const Record& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    RecordData_ (x.RecordData_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  Record::
  Record (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    RecordData_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Record::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RecordData
      //
      if (n.name () == "RecordData" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RecordData_type > r (
          RecordData_traits::create (i, f, this));

        this->RecordData_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  Record* Record::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Record (*this, f, c);
  }

  Record::
  ~Record ()
  {
  }

  // HistoryItem
  //

  HistoryItem::
  HistoryItem ()
  : ::xml_schema::type (),
    DateTime_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this),
    action_ (::xml_schema::flags (), this),
    ext_action_ (::xml_schema::flags (), this)
  {
  }

  HistoryItem::
  HistoryItem (const HistoryItem& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DateTime_ (x.DateTime_, f, this),
    restriction_ (x.restriction_, f, this),
    action_ (x.action_, f, this),
    ext_action_ (x.ext_action_, f, this)
  {
  }

  HistoryItem::
  HistoryItem (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DateTime_ (f, this),
    restriction_ (f, this),
    action_ (f, this),
    ext_action_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void HistoryItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DateTime
      //
      if (n.name () == "DateTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DateTime_type > r (
          DateTime_traits::create (i, f, this));

        if (!this->DateTime_)
        {
          this->DateTime_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }

      if (n.name () == "action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< action_type > r (
          action_traits::create (i, f, this));

        this->action_.set (r);
        continue;
      }

      if (n.name () == "ext-action" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_action_type > r (
          ext_action_traits::create (i, f, this));

        this->ext_action_.set (r);
        continue;
      }
    }
  }

  HistoryItem* HistoryItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HistoryItem (*this, f, c);
  }

  HistoryItem::
  ~HistoryItem ()
  {
  }

  // ReferenceName
  //

  ReferenceName::
  ReferenceName ()
  : ::xml_schema::string (),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ReferenceName::
  ReferenceName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ReferenceName::
  ReferenceName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ReferenceName::
  ReferenceName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ReferenceName::
  ReferenceName (const ReferenceName& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    lang_ (x.lang_, f, this)
  {
  }

  ReferenceName::
  ReferenceName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ReferenceName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  ReferenceName* ReferenceName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReferenceName (*this, f, c);
  }

  ReferenceName::
  ~ReferenceName ()
  {
  }

  // URL
  //

  URL::
  URL ()
  : ::xml_schema::string ()
  {
  }

  URL::
  URL (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  URL::
  URL (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  URL::
  URL (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  URL::
  URL (const URL& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  URL::
  URL (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  URL::
  URL (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  URL::
  URL (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  URL* URL::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class URL (*this, f, c);
  }

  URL::
  ~URL ()
  {
  }

  // System
  //

  System::
  System ()
  : ::xml_schema::type (),
    Node_ (::xml_schema::flags (), this),
    Service_ (::xml_schema::flags (), this),
    OperatingSystem_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this),
    interface_ (::xml_schema::flags (), this),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    spoofed_ (::xml_schema::flags (), this)
  {
  }

  System::
  System (const System& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Node_ (x.Node_, f, this),
    Service_ (x.Service_, f, this),
    OperatingSystem_ (x.OperatingSystem_, f, this),
    restriction_ (x.restriction_, f, this),
    interface_ (x.interface_, f, this),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this),
    spoofed_ (x.spoofed_, f, this)
  {
  }

  System::
  System (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Node_ (f, this),
    Service_ (f, this),
    OperatingSystem_ (f, this),
    restriction_ (f, this),
    interface_ (f, this),
    category_ (f, this),
    ext_category_ (f, this),
    spoofed_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void System::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Node
      //
      if (n.name () == "Node" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Node_type > r (
          Node_traits::create (i, f, this));

        this->Node_.push_back (r);
        continue;
      }

      // Service
      //
      if (n.name () == "Service" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Service_type > r (
          Service_traits::create (i, f, this));

        this->Service_.push_back (r);
        continue;
      }

      // OperatingSystem
      //
      if (n.name () == "OperatingSystem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< OperatingSystem_type > r (
          OperatingSystem_traits::create (i, f, this));

        this->OperatingSystem_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }

      if (n.name () == "interface" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< interface_type > r (
          interface_traits::create (i, f, this));

        this->interface_.set (r);
        continue;
      }

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< category_type > r (
          category_traits::create (i, f, this));

        this->category_.set (r);
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_category_type > r (
          ext_category_traits::create (i, f, this));

        this->ext_category_.set (r);
        continue;
      }

      if (n.name () == "spoofed" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< spoofed_type > r (
          spoofed_traits::create (i, f, this));

        this->spoofed_.set (r);
        continue;
      }
    }
  }

  System* System::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class System (*this, f, c);
  }

  System::
  ~System ()
  {
  }

  // RecordData
  //

  RecordData::
  RecordData ()
  : ::xml_schema::type (),
    DateTime_ (::xml_schema::flags (), this),
    RecordPattern_ (::xml_schema::flags (), this),
    RecordItem_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  RecordData::
  RecordData (const RecordData& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DateTime_ (x.DateTime_, f, this),
    RecordPattern_ (x.RecordPattern_, f, this),
    RecordItem_ (x.RecordItem_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  RecordData::
  RecordData (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DateTime_ (f, this),
    RecordPattern_ (f, this),
    RecordItem_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RecordData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DateTime
      //
      if (n.name () == "DateTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DateTime_type > r (
          DateTime_traits::create (i, f, this));

        if (!this->DateTime_)
        {
          this->DateTime_.set (r);
          continue;
        }
      }

      // RecordPattern
      //
      if (n.name () == "RecordPattern" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RecordPattern_type > r (
          RecordPattern_traits::create (i, f, this));

        this->RecordPattern_.push_back (r);
        continue;
      }

      // RecordItem
      //
      if (n.name () == "RecordItem" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< RecordItem_type > r (
          RecordItem_traits::create (i, f, this));

        this->RecordItem_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  RecordData* RecordData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordData (*this, f, c);
  }

  RecordData::
  ~RecordData ()
  {
  }

  // Node
  //

  Node::
  Node ()
  : ::xml_schema::type (),
    Counter_ (::xml_schema::flags (), this),
    DateTime_ (::xml_schema::flags (), this),
    NodeName_ (::xml_schema::flags (), this),
    Address_ (::xml_schema::flags (), this),
    Location_ (::xml_schema::flags (), this),
    NodeRole_ (::xml_schema::flags (), this)
  {
  }

  Node::
  Node (const Node& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Counter_ (x.Counter_, f, this),
    DateTime_ (x.DateTime_, f, this),
    NodeName_ (x.NodeName_, f, this),
    Address_ (x.Address_, f, this),
    Location_ (x.Location_, f, this),
    NodeRole_ (x.NodeRole_, f, this)
  {
  }

  Node::
  Node (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Counter_ (f, this),
    DateTime_ (f, this),
    NodeName_ (f, this),
    Address_ (f, this),
    Location_ (f, this),
    NodeRole_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Node::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Counter
      //
      if (n.name () == "Counter" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Counter_type > r (
          Counter_traits::create (i, f, this));

        if (!this->Counter_)
        {
          this->Counter_.set (r);
          continue;
        }
      }

      // DateTime
      //
      if (n.name () == "DateTime" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< DateTime_type > r (
          DateTime_traits::create (i, f, this));

        if (!this->DateTime_)
        {
          this->DateTime_.set (r);
          continue;
        }
      }

      // NodeName
      //
      if (n.name () == "NodeName" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< NodeName_type > r (
          NodeName_traits::create (i, f, this));

        this->NodeName_.push_back (r);
        continue;
      }

      // Address
      //
      if (n.name () == "Address" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        this->Address_.push_back (r);
        continue;
      }

      // Location
      //
      if (n.name () == "Location" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Location_type > r (
          Location_traits::create (i, f, this));

        this->Location_.push_back (r);
        continue;
      }

      // NodeRole
      //
      if (n.name () == "NodeRole" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< NodeRole_type > r (
          NodeRole_traits::create (i, f, this));

        this->NodeRole_.push_back (r);
        continue;
      }

      break;
    }
  }

  Node* Node::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Node (*this, f, c);
  }

  Node::
  ~Node ()
  {
  }

  // Service
  //

  Service::
  Service ()
  : ::xml_schema::type (),
    Port_ (::xml_schema::flags (), this),
    Portlist_ (::xml_schema::flags (), this),
    ProtoType_ (::xml_schema::flags (), this),
    ProtoCode_ (::xml_schema::flags (), this),
    ProtoField_ (::xml_schema::flags (), this),
    Application_ (::xml_schema::flags (), this),
    ip_protocol_ (::xml_schema::flags (), this)
  {
  }

  Service::
  Service (const Service& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Port_ (x.Port_, f, this),
    Portlist_ (x.Portlist_, f, this),
    ProtoType_ (x.ProtoType_, f, this),
    ProtoCode_ (x.ProtoCode_, f, this),
    ProtoField_ (x.ProtoField_, f, this),
    Application_ (x.Application_, f, this),
    ip_protocol_ (x.ip_protocol_, f, this)
  {
  }

  Service::
  Service (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Port_ (f, this),
    Portlist_ (f, this),
    ProtoType_ (f, this),
    ProtoCode_ (f, this),
    ProtoField_ (f, this),
    Application_ (f, this),
    ip_protocol_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Service::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Port
      //
      if (n.name () == "Port" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Port_type > r (
          Port_traits::create (i, f, this));

        if (!this->Port_)
        {
          this->Port_.set (r);
          continue;
        }
      }

      // Portlist
      //
      if (n.name () == "Portlist" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Portlist_type > r (
          Portlist_traits::create (i, f, this));

        if (!this->Portlist_)
        {
          this->Portlist_.set (r);
          continue;
        }
      }

      // ProtoType
      //
      if (n.name () == "ProtoType" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ProtoType_type > r (
          ProtoType_traits::create (i, f, this));

        if (!this->ProtoType_)
        {
          this->ProtoType_.set (r);
          continue;
        }
      }

      // ProtoCode
      //
      if (n.name () == "ProtoCode" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ProtoCode_type > r (
          ProtoCode_traits::create (i, f, this));

        if (!this->ProtoCode_)
        {
          this->ProtoCode_.set (r);
          continue;
        }
      }

      // ProtoField
      //
      if (n.name () == "ProtoField" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< ProtoField_type > r (
          ProtoField_traits::create (i, f, this));

        if (!this->ProtoField_)
        {
          this->ProtoField_.set (r);
          continue;
        }
      }

      // Application
      //
      if (n.name () == "Application" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< Application_type > r (
          Application_traits::create (i, f, this));

        this->Application_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ip_protocol" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ip_protocol_type > r (
          ip_protocol_traits::create (i, f, this));

        this->ip_protocol_.set (r);
        continue;
      }
    }
  }

  Service* Service::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Service (*this, f, c);
  }

  Service::
  ~Service ()
  {
  }

  // OperatingSystem
  //

  OperatingSystem::
  OperatingSystem ()
  : ::xml_schema::type (),
    URL_ (::xml_schema::flags (), this),
    swid_ (::xml_schema::flags (), this),
    configid_ (::xml_schema::flags (), this),
    vendor_ (::xml_schema::flags (), this),
    family_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this),
    patch_ (::xml_schema::flags (), this)
  {
  }

  OperatingSystem::
  OperatingSystem (const OperatingSystem& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    URL_ (x.URL_, f, this),
    swid_ (x.swid_, f, this),
    configid_ (x.configid_, f, this),
    vendor_ (x.vendor_, f, this),
    family_ (x.family_, f, this),
    name_ (x.name_, f, this),
    version_ (x.version_, f, this),
    patch_ (x.patch_, f, this)
  {
  }

  OperatingSystem::
  OperatingSystem (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    URL_ (f, this),
    swid_ (f, this),
    configid_ (f, this),
    vendor_ (f, this),
    family_ (f, this),
    name_ (f, this),
    version_ (f, this),
    patch_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void OperatingSystem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        if (!this->URL_)
        {
          this->URL_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "swid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< swid_type > r (
          swid_traits::create (i, f, this));

        this->swid_.set (r);
        continue;
      }

      if (n.name () == "configid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< configid_type > r (
          configid_traits::create (i, f, this));

        this->configid_.set (r);
        continue;
      }

      if (n.name () == "vendor" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vendor_type > r (
          vendor_traits::create (i, f, this));

        this->vendor_.set (r);
        continue;
      }

      if (n.name () == "family" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< family_type > r (
          family_traits::create (i, f, this));

        this->family_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }

      if (n.name () == "patch" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< patch_type > r (
          patch_traits::create (i, f, this));

        this->patch_.set (r);
        continue;
      }
    }
  }

  OperatingSystem* OperatingSystem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OperatingSystem (*this, f, c);
  }

  OperatingSystem::
  ~OperatingSystem ()
  {
  }

  // RecordPattern
  //

  RecordPattern::
  RecordPattern ()
  : ::xml_schema::string (),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    offset_ (::xml_schema::flags (), this),
    offsetunit_ (::xml_schema::flags (), this),
    ext_offsetunit_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this)
  {
  }

  RecordPattern::
  RecordPattern (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    offset_ (::xml_schema::flags (), this),
    offsetunit_ (::xml_schema::flags (), this),
    ext_offsetunit_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this)
  {
  }

  RecordPattern::
  RecordPattern (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    offset_ (::xml_schema::flags (), this),
    offsetunit_ (::xml_schema::flags (), this),
    ext_offsetunit_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this)
  {
  }

  RecordPattern::
  RecordPattern (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (::xml_schema::flags (), this),
    ext_type_ (::xml_schema::flags (), this),
    offset_ (::xml_schema::flags (), this),
    offsetunit_ (::xml_schema::flags (), this),
    ext_offsetunit_ (::xml_schema::flags (), this),
    instance_ (::xml_schema::flags (), this)
  {
  }

  RecordPattern::
  RecordPattern (const RecordPattern& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    ext_type_ (x.ext_type_, f, this),
    offset_ (x.offset_, f, this),
    offsetunit_ (x.offsetunit_, f, this),
    ext_offsetunit_ (x.ext_offsetunit_, f, this),
    instance_ (x.instance_, f, this)
  {
  }

  RecordPattern::
  RecordPattern (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    ext_type_ (f, this),
    offset_ (f, this),
    offsetunit_ (f, this),
    ext_offsetunit_ (f, this),
    instance_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void RecordPattern::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "ext-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_type_type > r (
          ext_type_traits::create (i, f, this));

        this->ext_type_.set (r);
        continue;
      }

      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< offset_type > r (
          offset_traits::create (i, f, this));

        this->offset_.set (r);
        continue;
      }

      if (n.name () == "offsetunit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< offsetunit_type > r (
          offsetunit_traits::create (i, f, this));

        this->offsetunit_.set (r);
        continue;
      }

      if (n.name () == "ext-offsetunit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_offsetunit_type > r (
          ext_offsetunit_traits::create (i, f, this));

        this->ext_offsetunit_.set (r);
        continue;
      }

      if (n.name () == "instance" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< instance_type > r (
          instance_traits::create (i, f, this));

        this->instance_.set (r);
        continue;
      }
    }
  }

  RecordPattern* RecordPattern::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordPattern (*this, f, c);
  }

  RecordPattern::
  ~RecordPattern ()
  {
  }

  // RecordItem
  //

  RecordItem::
  RecordItem ()
  : ::xml_schema::string (),
    dtype_ (::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  RecordItem::
  RecordItem (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    dtype_ (::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  RecordItem::
  RecordItem (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    dtype_ (::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  RecordItem::
  RecordItem (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    dtype_ (::xml_schema::flags (), this),
    ext_dtype_ (::xml_schema::flags (), this),
    meaning_ (::xml_schema::flags (), this),
    formatid_ (::xml_schema::flags (), this),
    restriction_ (::xml_schema::flags (), this)
  {
  }

  RecordItem::
  RecordItem (const RecordItem& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    dtype_ (x.dtype_, f, this),
    ext_dtype_ (x.ext_dtype_, f, this),
    meaning_ (x.meaning_, f, this),
    formatid_ (x.formatid_, f, this),
    restriction_ (x.restriction_, f, this)
  {
  }

  RecordItem::
  RecordItem (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    dtype_ (f, this),
    ext_dtype_ (f, this),
    meaning_ (f, this),
    formatid_ (f, this),
    restriction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void RecordItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dtype_type > r (
          dtype_traits::create (i, f, this));

        this->dtype_.set (r);
        continue;
      }

      if (n.name () == "ext-dtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_dtype_type > r (
          ext_dtype_traits::create (i, f, this));

        this->ext_dtype_.set (r);
        continue;
      }

      if (n.name () == "meaning" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< meaning_type > r (
          meaning_traits::create (i, f, this));

        this->meaning_.set (r);
        continue;
      }

      if (n.name () == "formatid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatid_type > r (
          formatid_traits::create (i, f, this));

        this->formatid_.set (r);
        continue;
      }

      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< restriction_type > r (
          restriction_traits::create (i, f, this));

        this->restriction_.set (r);
        continue;
      }
    }
  }

  RecordItem* RecordItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RecordItem (*this, f, c);
  }

  RecordItem::
  ~RecordItem ()
  {
  }

  // NodeName
  //

  NodeName::
  NodeName ()
  : ::xml_schema::string (),
    lang_ (::xml_schema::flags (), this)
  {
  }

  NodeName::
  NodeName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  NodeName::
  NodeName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  NodeName::
  NodeName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  NodeName::
  NodeName (const NodeName& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    lang_ (x.lang_, f, this)
  {
  }

  NodeName::
  NodeName (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void NodeName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  NodeName* NodeName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NodeName (*this, f, c);
  }

  NodeName::
  ~NodeName ()
  {
  }

  // Address
  //

  Address::
  Address ()
  : ::xml_schema::string (),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    vlan_name_ (::xml_schema::flags (), this),
    vlan_num_ (::xml_schema::flags (), this)
  {
  }

  Address::
  Address (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    vlan_name_ (::xml_schema::flags (), this),
    vlan_num_ (::xml_schema::flags (), this)
  {
  }

  Address::
  Address (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    vlan_name_ (::xml_schema::flags (), this),
    vlan_num_ (::xml_schema::flags (), this)
  {
  }

  Address::
  Address (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    vlan_name_ (::xml_schema::flags (), this),
    vlan_num_ (::xml_schema::flags (), this)
  {
  }

  Address::
  Address (const Address& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this),
    vlan_name_ (x.vlan_name_, f, this),
    vlan_num_ (x.vlan_num_, f, this)
  {
  }

  Address::
  Address (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    category_ (f, this),
    ext_category_ (f, this),
    vlan_name_ (f, this),
    vlan_num_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Address::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< category_type > r (
          category_traits::create (i, f, this));

        this->category_.set (r);
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_category_type > r (
          ext_category_traits::create (i, f, this));

        this->ext_category_.set (r);
        continue;
      }

      if (n.name () == "vlan-name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vlan_name_type > r (
          vlan_name_traits::create (i, f, this));

        this->vlan_name_.set (r);
        continue;
      }

      if (n.name () == "vlan-num" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vlan_num_type > r (
          vlan_num_traits::create (i, f, this));

        this->vlan_num_.set (r);
        continue;
      }
    }
  }

  Address* Address::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Address (*this, f, c);
  }

  Address::
  ~Address ()
  {
  }

  // Location
  //

  Location::
  Location ()
  : ::xml_schema::string (),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Location::
  Location (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Location::
  Location (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Location::
  Location (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    lang_ (::xml_schema::flags (), this)
  {
  }

  Location::
  Location (const Location& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    lang_ (x.lang_, f, this)
  {
  }

  Location::
  Location (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Location::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  Location* Location::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Location (*this, f, c);
  }

  Location::
  ~Location ()
  {
  }

  // NodeRole
  //

  NodeRole::
  NodeRole ()
  : ::xml_schema::string (),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  NodeRole::
  NodeRole (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  NodeRole::
  NodeRole (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  NodeRole::
  NodeRole (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    category_ (::xml_schema::flags (), this),
    ext_category_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  NodeRole::
  NodeRole (const NodeRole& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    category_ (x.category_, f, this),
    ext_category_ (x.ext_category_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  NodeRole::
  NodeRole (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    category_ (f, this),
    ext_category_ (f, this),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void NodeRole::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< category_type > r (
          category_traits::create (i, f, this));

        this->category_.set (r);
        continue;
      }

      if (n.name () == "ext-category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ext_category_type > r (
          ext_category_traits::create (i, f, this));

        this->ext_category_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }
  }

  NodeRole* NodeRole::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NodeRole (*this, f, c);
  }

  NodeRole::
  ~NodeRole ()
  {
  }

  // Application
  //

  Application::
  Application ()
  : ::xml_schema::type (),
    URL_ (::xml_schema::flags (), this),
    swid_ (::xml_schema::flags (), this),
    configid_ (::xml_schema::flags (), this),
    vendor_ (::xml_schema::flags (), this),
    family_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this),
    patch_ (::xml_schema::flags (), this)
  {
  }

  Application::
  Application (const Application& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    URL_ (x.URL_, f, this),
    swid_ (x.swid_, f, this),
    configid_ (x.configid_, f, this),
    vendor_ (x.vendor_, f, this),
    family_ (x.family_, f, this),
    name_ (x.name_, f, this),
    version_ (x.version_, f, this),
    patch_ (x.patch_, f, this)
  {
  }

  Application::
  Application (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    URL_ (f, this),
    swid_ (f, this),
    configid_ (f, this),
    vendor_ (f, this),
    family_ (f, this),
    name_ (f, this),
    version_ (f, this),
    patch_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Application::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // URL
      //
      if (n.name () == "URL" && n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
      {
        ::std::auto_ptr< URL_type > r (
          URL_traits::create (i, f, this));

        if (!this->URL_)
        {
          this->URL_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "swid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< swid_type > r (
          swid_traits::create (i, f, this));

        this->swid_.set (r);
        continue;
      }

      if (n.name () == "configid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< configid_type > r (
          configid_traits::create (i, f, this));

        this->configid_.set (r);
        continue;
      }

      if (n.name () == "vendor" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vendor_type > r (
          vendor_traits::create (i, f, this));

        this->vendor_.set (r);
        continue;
      }

      if (n.name () == "family" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< family_type > r (
          family_traits::create (i, f, this));

        this->family_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }

      if (n.name () == "patch" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< patch_type > r (
          patch_traits::create (i, f, this));

        this->patch_.set (r);
        continue;
      }
    }
  }

  Application* Application::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Application (*this, f, c);
  }

  Application::
  ~Application ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace iodef_1_0
{
  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
      ::iodef_1_0::IncidentID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
      ::iodef_1_0::IncidentID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
      ::iodef_1_0::IncidentID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IncidentID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IncidentID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IncidentID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IncidentID_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IncidentID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IncidentID_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
      ::iodef_1_0::IncidentID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
      ::iodef_1_0::IncidentID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
      ::iodef_1_0::IncidentID_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
        ::iodef_1_0::IncidentID_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IncidentID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::IncidentID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IncidentID",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::IncidentID >
  IncidentID_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IncidentID" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::IncidentID > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::IncidentID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IncidentID",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Description > r (
      ::iodef_1_0::Description_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Description > r (
      ::iodef_1_0::Description_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Description > r (
      ::iodef_1_0::Description_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Description_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Description_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::Description_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Description_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Description_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::Description_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::Description > r (
      ::iodef_1_0::Description_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Description > r (
      ::iodef_1_0::Description_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::Description > r (
      ::iodef_1_0::Description_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::Description > r (
        ::iodef_1_0::Description_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Description" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Description > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Description, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Description",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::Description >
  Description_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Description" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::Description > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::Description, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Description",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
      ::iodef_1_0::iodef_sci_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
      ::iodef_1_0::iodef_sci_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
      ::iodef_1_0::iodef_sci_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::iodef_sci_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::iodef_sci_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::iodef_sci_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::iodef_sci_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::iodef_sci_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::iodef_sci_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
      ::iodef_1_0::iodef_sci_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
      ::iodef_1_0::iodef_sci_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
      ::iodef_1_0::iodef_sci_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
        ::iodef_1_0::iodef_sci_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "iodef_sci" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::iodef_sci, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "iodef_sci",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::iodef_sci >
  iodef_sci_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "iodef_sci" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::iodef_sci > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::iodef_sci, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "iodef_sci",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IODEF_Document_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IODEF_Document_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::IODEF_Document_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
      ::iodef_1_0::IODEF_Document_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
        ::iodef_1_0::IODEF_Document_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IODEF-Document" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::IODEF_Document, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IODEF-Document",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::IODEF_Document >
  IODEF_Document_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IODEF-Document" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::IODEF_Document > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::IODEF_Document, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IODEF-Document",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
      ::iodef_1_0::NewDataSet_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
      ::iodef_1_0::NewDataSet_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
      ::iodef_1_0::NewDataSet_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::NewDataSet_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::NewDataSet_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::iodef_1_0::NewDataSet_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::NewDataSet_ (isrc, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::NewDataSet_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::iodef_1_0::NewDataSet_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
      ::iodef_1_0::NewDataSet_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
      ::iodef_1_0::NewDataSet_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
      ::iodef_1_0::NewDataSet_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
        ::iodef_1_0::NewDataSet_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "NewDataSet" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::NewDataSet, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "NewDataSet",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }

  ::std::auto_ptr< ::iodef_1_0::NewDataSet >
  NewDataSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "NewDataSet" &&
        n.namespace_ () == "urn:ietf:params:xml:ns:iodef-1.0")
    {
      ::std::auto_ptr< ::iodef_1_0::NewDataSet > r (
        ::xsd::cxx::tree::traits< ::iodef_1_0::NewDataSet, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "NewDataSet",
      "urn:ietf:params:xml:ns:iodef-1.0");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

